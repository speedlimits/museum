diff --git a/build/cmake/CMakeLists.txt b/build/cmake/CMakeLists.txt
deleted file mode 100644
index a6e7ad9..0000000
--- a/build/cmake/CMakeLists.txt
+++ /dev/null
@@ -1,1680 +0,0 @@
-#Sirikata Build Script
-#CMakeLists.txt
-#
-#Copyright (c) 2008, Patrick Reiter Horn
-#All rights reserved.
-#
-#Redistribution and use in source and binary forms, with or without
-#modification, are permitted provided that the following conditions are met:
-#
-#    * Redistributions of source code must retain the above copyright notice,
-#      this list of conditions and the following disclaimer.
-#    * Redistributions in binary form must reproduce the above copyright notice,
-#      this list of conditions and the following disclaimer in the documentation
-#      and/or other materials provided with the distribution.
-#    * Neither the name of the Sirikata nor the names of its contributors
-#      may be used to endorse or promote products derived from this software
-#      without specific prior written permission.
-#
-#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-#ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-#WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-#DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-#ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-#(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-#LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-#ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-#(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-#SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#cmake options
-
-CMAKE_MINIMUM_REQUIRED(VERSION 2.4)
-SET(CMAKE_VERBOSE_MAKEFILE OFF)
-SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS TRUE)
-
-IF(COMMAND CMAKE_POLICY)
-  # Use new policy for absolute path libraries.  We have no reason to depend on the
-  # old version which adds library search paths unnecessarily
-  CMAKE_POLICY(SET CMP0003 NEW)
-ENDIF(COMMAND CMAKE_POLICY)
-
-IF(NOT WIN32 AND NOT APPLE)
-  SET(ISLINUX TRUE)
-ENDIF()
-
-IF(WIN32)
-ADD_DEFINITIONS(-D_CRT_SECURE_NO_WARNINGS -D_WIN32_WINNT=0x0500 -D_SCL_SECURE_NO_WARNINGS -EHsc -DBOOST_ALL_DYN_LINK)
-SET(CMAKE_CXX_FLAGS "-D_CRT_SECURE_NO_WARNINGS -D_SCL_SECURE_NO_WARNINGS")
-#-fno-rtti
-SET(CMAKE_CXX_FLAGS_DEFAULT "-g -D_CRT_SECURE_NO_WARNINGS -D_SCL_SECURE_NO_WARNINGS" CACHE STRING
-    "Built cxxflags with default settings."
-    FORCE )
-SET( CMAKE_C_FLAGS_DEFAULT "-g -Wall -D_CRT_SECURE_NO_WARNINGS -D_SCL_SECURE_NO_WARNINGS" CACHE STRING
-    "Built cflags with default settings."
-    FORCE )
-
-ELSE()
-
-IF(NOT CMAKE_BUILD_TYPE)
-#the below lines work around a bug when cmake first is configured without <CONFIG>
-  SET(FORCE_USE_DEBUG_LOCATION "TRUE")
-  SET(CMAKE_BUILD_TYPE Debug CACHE STRING
-      "Build types include: Default Debug Release None RelWithDebInfo." FORCE
-      )
-ENDIF()
-STRING(TOUPPER ${CMAKE_BUILD_TYPE} UPPERCASE_BUILD_TYPE)
-STRING(COMPARE EQUAL ${UPPERCASE_BUILD_TYPE} "DEBUG" ISDEBUG)
-
-SET(ADDED_DEFINITIONS -Wall -Wno-unused-function -Wno-unused-variable -fvisibility=hidden -fPIC -Wnon-virtual-dtor  -Wreorder -Wstrict-null-sentinel -Wsign-promo )
-
-#-Woverloaded_virtual
-#-Wabi
-#-Wold-style-cast
-#-fno-rtti
-#-fno-rtti
-SET(CMAKE_CXX_FLAGS_DEFAULT "-g -Wall -Wno-unused-function -Wno-unused-variable -fvisibility=hidden" CACHE STRING
-    "Built cxxflags with default settings."
-    FORCE )
-SET( CMAKE_C_FLAGS_DEFAULT "-g -Wall -Wno-unused-function -Wno-unused-variable -fvisibility=hidden" CACHE STRING
-    "Built cflags with default settings."
-    FORCE )
-ENDIF()
-SET( CMAKE_EXE_LINKER_FLAGS_DEFAULT
-    "" CACHE STRING
-    "Linking binaries with default settings."
-    FORCE )
-SET( CMAKE_SHARED_LINKER_FLAGS_DEFAULT
-    "" CACHE STRING
-    "Building shared libraries with default settings."
-    FORCE )
-MARK_AS_ADVANCED(
-    CMAKE_CXX_FLAGS_DEFAULT
-    CMAKE_C_FLAGS_DEFAULT
-    CMAKE_EXE_LINKER_FLAGS_DEFAULT
-    CMAKE_SHARED_LINKER_FLAGS_DEFAULT )
-
-#project global flags
-
-PROJECT(Sirikata CXX)
-
-IF(NOT TOP_LEVEL)
-  SET(TOP_LEVEL ${CMAKE_CURRENT_SOURCE_DIR}/../..)
-ENDIF()
-GET_FILENAME_COMPONENT(TOP_LEVEL ${TOP_LEVEL} ABSOLUTE)
-
-#add-ins
-
-IF(NOT CMAKE_MODULE_PATH)
-  SET(CMAKE_MODULE_PATH ${TOP_LEVEL}/build/modules)
-ENDIF()
-GET_FILENAME_COMPONENT(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ABSOLUTE)
-
-MACRO(VERIFY_VERSION package_name major minor subminor)
-  IF (${package_name}_MAJOR_VERSION LESS ${major})
-    MESSAGE(FATAL_ERROR "${package_name} out of date: ${major}.${minor}.${subminor}")
-  ELSEIF(${package_name}_MAJOR_VERSION EQUAL ${major})
-    IF(${package_name}_MINOR_VERSION LESS ${minor})
-       MESSAGE(FATAL_ERROR "${package_name} out of date: ${major}.${minor}.${subminor}")
-    ELSEIF(${package_name}_MINOR_VERSION EQUAL ${major})
-      IF(${package_name}_SUBMINOR_VERSION LESS ${subminor})
-        MESSAGE(FATAL_ERROR "${package_name} out of date: ${major}.${minor}.${subminor}")
-      ENDIF()
-    ENDIF()
-  ENDIF()
-ENDMACRO(VERIFY_VERSION)
-
-
-INCLUDE(ListUtil)
-INCLUDE(ParseArguments)
-INCLUDE(AddPBJTarget)
-FIND_PACKAGE(PythonInterp)
-
-
-MACRO(ADD_CXXTEST_CPP_TARGET)
-  PARSE_ARGUMENTS(CXXTEST "DEPENDS;OUTPUTDIR;LIBRARYDIR" "" ${ARGN})
-  CAR(CXXTEST_NAME ${CXXTEST_DEFAULT_ARGS})
-  CDR(CXXTEST_FILES ${CXXTEST_DEFAULT_ARGS})
-
-  SET(CXXTEST_EXEC_TARGET ${CXXTEST_NAME})
-
-  SET(CXXTEST_TEST_FILES)
-  SET(CXXTEST_H_FILES)
-
-  SET(CXXTEST_OPTIONS --runner=StdioPrinter --include=util/Standard.hh)
-  #IF(CXXTEST_OUTPUTDIR)
-  #  SET(CXXTEST_OPTIONS ${CXXTEST_OPTIONS} -o ${CXXTEST_OUTPUTDIR})
-  #ENDIF(CXXTEST_OUTPUTDIR)
-
-  SET(CXXTEST_CPP_FILE ${CMAKE_CURRENT_BINARY_DIR}/test.cc)
-
-  IF(PYTHON_EXECUTABLE)
-    SET(CXXTEST_COMPILER ${PYTHON_EXECUTABLE})
-    SET(CXXTEST_GEN ${CXXTEST_LIBRARYDIR}/cxxtestgen.py)
-  ELSE()
-    FIND_PACKAGE(Perl)
-    IF(PERL_EXECUTABLE)
-      SET(CXXTEST_CPP_FILE test.cc)      #perl cannot output to a full path.
-      SET(CXXTEST_COMPILER ${PERL_EXECUTABLE})
-      SET(CXXTEST_GEN ${CXXTEST_LIBRARYDIR}/cxxtestgen.pl)
-    ELSE()
-      MESSAGE(STATUS "!!! Cannot locate python or perl -- tests will not be compiled.")
-    ENDIF()
-  ENDIF()
-  FOREACH(FILE ${CXXTEST_FILES})
-    SET(CXXTEST_H_FILE ${TOP_LEVEL}/${FILE})
-    SET(CXXTEST_TEST_FILES ${CXXTEST_TEST_FILES} ${CXXTEST_H_FILE})
-  ENDFOREACH()
-  IF (CXXTEST_COMPILER)
-    SET(FINAL_CXXTEST_COMMAND ${CXXTEST_COMPILER} ${CXXTEST_GEN} ${CXXTEST_OPTIONS} -o ${CXXTEST_CPP_FILE} ${CXXTEST_TEST_FILES})
-    ADD_CUSTOM_COMMAND(OUTPUT ${CXXTEST_CPP_FILE}
-                       COMMAND ${CXXTEST_COMPILER} ${CXXTEST_GEN} ${CXXTEST_OPTIONS} -o ${CXXTEST_CPP_FILE} ${CXXTEST_TEST_FILES}
-                       DEPENDS ${CXXTEST_TEST_FILES} ${CXXTEST_DEPENDS}
-                       COMMENT "Building ${CXXTEST_TEST_FILES} -> ${CXXTEST_CPP_FILE}")
-  ELSE()
-    ADD_CUSTOM_COMMAND(OUTPUT ${CXXTEST_CPP_FILE}
-                       COMMAND exit 1
-                       COMMENT "Unable to build ${CXXTEST_CPP_FILE} because python and perl were not found.")
-  ENDIF()
-
-  SET_DIRECTORY_PROPERTIES(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES ${CXXTEST_CPP_FILE})
-
-ENDMACRO(ADD_CXXTEST_CPP_TARGET)
-
-#dependencies
-IF(NOT PLATFORM_LIBS)
-  SET(PLATFORM_LIBS ${TOP_LEVEL}/dependencies/)
-ENDIF()
-GET_FILENAME_COMPONENT(PLATFORM_LIBS ${PLATFORM_LIBS} ABSOLUTE)
-IF(NOT PLATFORM_LIBS)
-  MESSAGE(STATUS "Could not find dependencies directory ${TOP_LEVEL}/dependencies/")
-ENDIF()
-MESSAGE(STATUS "Using PLATFORM_LIBS=${PLATFORM_LIBS}")
-SET(ScriptsRoot ${TOP_LEVEL}/liboh/scripts)
-SET(DISABLE_M32 FALSE)
-SET(FORCE_32BIT FALSE)
-SET(DISABLE_AWESOMIUM FALSE)
-
-IF(ISLINUX)
-  IF(FORCE_32BIT OR EXISTS ${PLATFORM_LIBS}/arch-32bit)
-    MESSAGE(STATUS "Performing 32-bit build")
-    IF(NOT ${DISABLE_M32})
-    MESSAGE(STATUS "Really Performing 32-bit build")
-      SET(ADDED_DEFINITIONS ${ADDED_DEFINITIONS} -m32)
-      IF(sirikata_LDFLAGS)
-        SET(sirikata_LDFLAGS ${sirikata_LDFLAGS} -m32)
-      ELSE()
-        SET(sirikata_LDFLAGS -m32)
-      ENDIF()
-
-    ENDIF()
-  ELSE()
-    MESSAGE(STATUS "Performing 64-bit build")
-    # Must be built 32-bit to disable awesomium
-    SET(DISABLE_AWESOMIUM TRUE)
-  ENDIF()
-ENDIF()
-IF(APPLE)
-  IF(CMAKE_SYSTEM_VERSION)
-    IF(CMAKE_SYSTEM_VERSION MATCHES "[12345678]\\.[0-9]*\\.[0-9]*")
-      SET(DISABLE_AWESOMIUM TRUE)
-    ENDIF()
-  ENDIF()
-ENDIF()
-
-#libraries
-SET(MONO_MINIMUM_VERSION 2.0)
-#dependency: mono
-IF(NOT MONO_ROOT)
-  IF(WIN32)
-    SET(MONO_ROOT ${PLATFORM_LIBS}/mono-2.4)
-  ELSEIF(APPLE)
-    # TODO: Add path to some prebuilt version of Mono for Macs
-  ELSE()
-    SET(MONO_ROOT ${PLATFORM_LIBS}/installed-mono)
-  ENDIF()
-ENDIF()
-FIND_PACKAGE(Mono)
-IF(MONO_FOUND)
-  ADD_DEFINITIONS(-DHAVE_MONO)
-  ADD_DEFINITIONS(-DMONO_VERSION_MAJOR=${MONO_MAJOR_VERSION})
-  ADD_DEFINITIONS(-DMONO_VERSION_MINOR=${MONO_MINOR_VERSION})
-  ADD_DEFINITIONS(-DMONO_VERSION_MICRO=${MONO_SUBMINOR_VERSION})
-  IF(EXISTS ${PLATFORM_LIBS}/IronPython)
-    SET(IRON_PYTHON_ROOT ${PLATFORM_LIBS}/IronPython)
-    SET(IRON_PYTHON_LIBRARIES
-      -r:${IRON_PYTHON_ROOT}/IronPython.dll
-      -r:${IRON_PYTHON_ROOT}/IronPython.Modules.dll
-      -r:${IRON_PYTHON_ROOT}/Microsoft.Scripting.dll
-      -r:${IRON_PYTHON_ROOT}/Microsoft.Scripting.Core.dll
-#      -r:${IRON_PYTHON_ROOT}/Microsoft.Scripting.ExtensionAttribute.dll
-       )
-  ENDIF(EXISTS ${PLATFORM_LIBS}/IronPython)
-  FIND_PACKAGE(Cecil)
-ENDIF(MONO_FOUND)
-
-#dependency: protocolbuffers
-IF(EXISTS ${PLATFORM_LIBS}/installed-protobufs/bin)
-  SET(PROTOCOLBUFFERS_ROOT ${PLATFORM_LIBS}/installed-protobufs)
-ELSEIF(EXISTS ${PLATFORM_LIBS}/protobufs/bin)
-  SET(PROTOCOLBUFFERS_ROOT ${PLATFORM_LIBS}/protobufs)
-ELSE()
-  SET(PROTOCOLBUFFERS_ROOT ${PLATFORM_LIBS})
-ENDIF()
-FIND_PACKAGE(ProtocolBuffers)
-IF(NOT PROTOCOLBUFFERS_FOUND)
-  MESSAGE(FATAL_ERROR "Cannot find Protocol Buffers
-Did you install the dependencies?
-To install dependencies go to the top level and run:
-
-make depends
-")
-ENDIF()
-
-#dependency: ANTLR
-IF(EXISTS ${PLATFORM_LIBS}/libantlr3c-3.1.3)
-  SET(ANTLR_ROOT ${PLATFORM_LIBS}/libantlr3c-3.1.3)
-ELSEIF(EXISTS ${PLATFORM_LIBS}/antlr3c-3.1.3)
-  SET(ANTLR_ROOT ${PLATFORM_LIBS}/antlr3c-3.1.3)
-ELSEIF(EXISTS ${PLATFORM_LIBS}/libantlr3c)
-  SET(ANTLR_ROOT ${PLATFORM_LIBS}/libantlr3c)
-ELSEIF(EXISTS ${PLATFORM_LIBS}/antlr3c)
-  SET(ANTLR_ROOT ${PLATFORM_LIBS}/antlr3c)
-ELSE()
-  SET(ANTLR_ROOT ${PLATFORM_LIBS})
-ENDIF()
-IF(NOT WIN32)
-IF(NOT APPLE)
-  SET(ANTLR_ROOT ${PLATFORM_LIBS})
-ENDIF()
-ENDIF()
-FIND_PACKAGE(ANTLR)
-IF(NOT ANTLR_FOUND)
-  MESSAGE(FATAL_ERROR "Cannot find antlr")
-ENDIF()
-
-
-#dependency: boost > 1.35
-IF(NOT BOOST_ROOT)
-  # IF(WIN32)
-  #   SET(Boost_USE_STATIC_LIBS ON)
-  # ENDIF()
-  IF(EXISTS ${PLATFORM_LIBS}/installed-boost/lib)
-    SET(BOOST_ROOT ${PLATFORM_LIBS}/installed-boost)
-  ELSEIF(EXISTS ${PLATFORM_LIBS}/boost_1_35_0/lib)
-    SET(BOOST_ROOT ${PLATFORM_LIBS}/boost_1_35_0)
-  ELSE()
-    SET(BOOST_ROOT ${PLATFORM_LIBS})
-  ENDIF()
-ENDIF()
-SET(Boost_FIND_REQUIRED TRUE)
-IF(WIN32)
-  FIND_PACKAGE(Boost COMPONENTS system program_options thread filesystem)
-ELSE(WIN32)
-  FIND_PACKAGE(Boost COMPONENTS system)
-
-  STRING(REPLACE "boost_system" "boost_program_options" Boost_PROGRAM_OPTIONS_LIBRARY ${Boost_SYSTEM_LIBRARY})
-  STRING(REPLACE "boost_system" "boost_program_options" Boost_PROGRAM_OPTIONS_LIBRARY_DEBUG ${Boost_SYSTEM_LIBRARY_DEBUG})
-  STRING(REPLACE "boost_system" "boost_program_options" Boost_PROGRAM_OPTIONS_LIBRARY_RELEASE ${Boost_SYSTEM_LIBRARY_RELEASE})
-
-  STRING(REPLACE "boost_system" "boost_thread" Boost_THREAD_LIBRARY ${Boost_SYSTEM_LIBRARY})
-  STRING(REPLACE "boost_system" "boost_thread" Boost_THREAD_LIBRARY_DEBUG ${Boost_SYSTEM_LIBRARY_DEBUG})
-  STRING(REPLACE "boost_system" "boost_thread" Boost_THREAD_LIBRARY_RELEASE ${Boost_SYSTEM_LIBRARY_RELEASE})
-
-  STRING(REPLACE "boost_system" "boost_filesystem" Boost_FILESYSTEM_LIBRARY ${Boost_SYSTEM_LIBRARY})
-  STRING(REPLACE "boost_system" "boost_filesystem" Boost_FILESYSTEM_LIBRARY_DEBUG ${Boost_SYSTEM_LIBRARY_DEBUG})
-  STRING(REPLACE "boost_system" "boost_filesystem" Boost_FILESYSTEM_LIBRARY_RELEASE ${Boost_SYSTEM_LIBRARY_RELEASE})
-
-  STRING(REPLACE "boost_system" "boost_regex" Boost_REGEX_LIBRARY ${Boost_SYSTEM_LIBRARY})
-  STRING(REPLACE "boost_system" "boost_regex" Boost_REGEX_LIBRARY_DEBUG ${Boost_SYSTEM_LIBRARY_DEBUG})
-  STRING(REPLACE "boost_system" "boost_regex" Boost_REGEX_LIBRARY_RELEASE ${Boost_SYSTEM_LIBRARY_RELEASE})
-ENDIF(WIN32)
-VERIFY_VERSION(Boost 1 35 0)
-
-SET(Boost_LIBRARIES
-    ${Boost_SYSTEM_LIBRARY_${UPPERCASE_BUILD_TYPE}}
-    ${Boost_PROGRAM_OPTIONS_LIBRARY_${UPPERCASE_BUILD_TYPE}}
-    ${Boost_THREAD_LIBRARY_${UPPERCASE_BUILD_TYPE}}
-    ${Boost_FILESYSTEM_LIBRARY_${UPPERCASE_BUILD_TYPE}})
-
-#dependency: curl
-IF(NOT CURL_ROOT)
-  IF(EXISTS ${PLATFORM_LIBS}/installed-curl)
-    SET(CURL_ROOT ${PLATFORM_LIBS}/installed-curl)
-  ELSEIF(EXISTS ${PLATFORM_LIBS}/libcurl_7_18_0)
-    SET(CURL_ROOT ${PLATFORM_LIBS}/libcurl_7_18_0)
-  ELSEIF(EXISTS ${PLATFORM_LIBS}/libcurl_7_15_5)
-    SET(CURL_ROOT ${PLATFORM_LIBS}/libcurl_7_15_5)
-  ENDIF()
-  IF(WIN32)
-    GET_FILENAME_COMPONENT(CURL_ROOT ${CURL_ROOT} ABSOLUTE)
-  ENDIF()
-  IF(NOT CURL_ROOT)
-    SET(CURL_ROOT ${PLATFORM_LIBS}/libcurl_7_15_5)
-  ENDIF()
-ENDIF()
-
-FIND_PACKAGE(CURL)
-SET(TEST_LIBRARIES ${CURL_LIBRARIES})
-
-#dependency: ois
-IF(NOT OIS_ROOT)
-  IF(EXISTS ${PLATFORM_LIBS}/installed-ois)
-    SET(OIS_ROOT ${PLATFORM_LIBS}/installed-ois)
-  ELSEIF(EXISTS ${PLATFORM_LIBS}/ois-1.2)
-    SET(OIS_ROOT ${PLATFORM_LIBS}/ois-1.2)
-  ELSEIF(EXISTS ${PLATFORM_LIBS}/ois-1.0)
-    SET(OIS_ROOT ${PLATFORM_LIBS}/ois-1.0)
-  ENDIF()
-  IF(WIN32 AND OIS_ROOT)
-    GET_FILENAME_COMPONENT(OIS_ROOT ${OIS_ROOT} ABSOLUTE)
-  ENDIF()
-  IF(NOT OIS_ROOT)
-    SET(OIS_ROOT ${PLATFORM_LIBS})
-  ENDIF()
-ENDIF()
-
-FIND_PACKAGE(OIS)
-
-#dependency: ogre
-IF(NOT OGRE_ROOT)
-  IF(EXISTS ${PLATFORM_LIBS}/installed-ogre)
-    SET(OGRE_ROOT ${PLATFORM_LIBS}/installed-ogre)
-  ELSEIF(EXISTS ${PLATFORM_LIBS}/ogre-1.6.1)
-    SET(OGRE_ROOT ${PLATFORM_LIBS}/ogre-1.6.1)
-  ELSEIF(EXISTS ${PLATFORM_LIBS}/ogre-1.6.x)
-    SET(OGRE_ROOT ${PLATFORM_LIBS}/ogre-1.6.x)
-  ELSEIF(EXISTS ${PLATFORM_LIBS}/ogre)
-    SET(OGRE_ROOT ${PLATFORM_LIBS}/ogre)
-  ENDIF()
-  IF(WIN32 AND OGRE_ROOT)
-    GET_FILENAME_COMPONENT(OGRE_ROOT ${OGRE_ROOT} ABSOLUTE)
-  ENDIF()
-  IF(NOT OGRE_ROOT)
-    SET(OGRE_ROOT ${PLATFORM_LIBS})
-  ENDIF()
-ENDIF()
-
-FIND_PACKAGE(OGRE)
-IF(WIN32)
-SET(bullet_ROOT ${PLATFORM_LIBS}/bullet-2.74)
-ELSE()
-SET(bullet_ROOT ${PLATFORM_LIBS}/installed-bullet)
-ENDIF()
-SET(bullet_MINIMUM_VERSION 2.74)
-FIND_PACKAGE(Bullet)
-
-
-
-IF(NOT SQLite3_ROOT)
-  IF(WIN32)
-    SET(SQLite3_ROOT ${PLATFORM_LIBS}/sqlite-3_6_16)
-  ELSE()
-    IF(${CMAKE_SYSTEM_NAME} STREQUAL "Darwin")
-      SET(SQLite3_ROOT ${PLATFORM_LIBS})
-    ELSE()
-      SET(SQLite3_ROOT ${PLATFORM_LIBS}/installed-sqlite)
-    ENDIF()
-  ENDIF()
-ENDIF()
-
-SET(SQLite3_FIND_REQUIRED TRUE)
-FIND_PACKAGE(SQLite3)
-
-
-
-SET(sdl_MINIMUM_VERSION 1.3.0)
-IF(NOT sdl_ROOT)
-  IF(EXISTS ${PLATFORM_LIBS}/installed-sdl)
-    SET(sdl_ROOT ${PLATFORM_LIBS}/installed-sdl)
-  ELSEIF(EXISTS ${PLATFORM_LIBS}/sdl-1.3)
-    SET(sdl_ROOT ${PLATFORM_LIBS}/sdl-1.3)
-  ELSEIF(EXISTS ${PLATFORM_LIBS}/sdl-1.3.0)
-    SET(sdl_ROOT ${PLATFORM_LIBS}/sdl-1.3.0)
-  ELSEIF(EXISTS ${PLATFORM_LIBS}/sdl)
-    SET(sdl_ROOT ${PLATFORM_LIBS}/sdl)
-  ENDIF()
-  IF(WIN32 AND sdl_ROOT)
-    GET_FILENAME_COMPONENT(sdl_ROOT ${sdl_ROOT} ABSOLUTE)
-  ENDIF()
-  IF(APPLE OR NOT sdl_ROOT)
-    SET(sdl_ROOT ${PLATFORM_LIBS})
-  ENDIF()
-ENDIF()
-
-FIND_PACKAGE(SDL)
-
-#optional dependency: prox
-FIND_PACKAGE(PROX)
-IF(NOT PROX_INCLUDE_DIRS)
-  MESSAGE(FATAL_ERROR "PROX submodule not found, go to top level and run:
-
-git submodule init
-git submodule update
-")
-ENDIF()
-#dependency: awesomium
-IF(NOT AWESOMIUM_ROOT)
-  IF(EXISTS ${PLATFORM_LIBS}/awesomium_v1.01_sdk_msvc8)
-    SET(AWESOMIUM_ROOT ${PLATFORM_LIBS}/awesomium_v1.01_sdk_msvc8)
-  ELSEIF(EXISTS ${PLATFORM_LIBS}/awesomium_v1.01_sdk_msvc9)
-    SET(AWESOMIUM_ROOT ${PLATFORM_LIBS}/awesomium_v1.01_sdk_msvc9)
-  ELSEIF(EXISTS ${PLATFORM_LIBS}/installed-awesomium)
-    SET(AWESOMIUM_ROOT ${PLATFORM_LIBS}/installed-awesomium)
-  ELSEIF(EXISTS ${PLATFORM_LIBS}/awesomium)
-    SET(AWESOMIUM_ROOT ${PLATFORM_LIBS}/awesomium)
-  ENDIF()
-  IF(WIN32 AND AWESOMIUM_ROOT)
-    GET_FILENAME_COMPONENT(AWESOMIUM_ROOT ${AWESOMIUM_ROOT} ABSOLUTE)
-  ENDIF()
-  IF(NOT AWESOMIUM_ROOT)
-    SET(AWESOMIUM_ROOT ${PLATFORM_LIBS})
-  ENDIF()
-ENDIF()
-
-IF(NOT DISABLE_AWESOMIUM)
-  FIND_PACKAGE(AWESOMIUM)
-ENDIF()
-
-#dependency: cxxtest
-SET(CXXTESTRoot ${TOP_LEVEL}/externals/cxxtest)
-
-
-# macro for adding a plugin
-MACRO(ADD_PLUGIN_TARGET)
-  PARSE_ARGUMENTS(PLUGIN "SOURCES;TARGET_CXXFLAGS;TARGET_LDFLAGS;TARGET_LIBRARIES;LIBRARIES" "" ${ARGN})
-
-  CAR(PLUGIN_NAME ${PLUGIN_DEFAULT_ARGS})
-
-  ADD_LIBRARY(${PLUGIN_NAME} SHARED ${PLUGIN_SOURCES})
-  IF(PLUGIN_TARGET_LIBRARIES)
-    ADD_DEPENDENCIES(${PLUGIN_NAME} ${PLUGIN_TARGET_LIBRARIES})
-  ENDIF()
-  TARGET_LINK_LIBRARIES(${PLUGIN_NAME} ${PLUGIN_TARGET_LIBRARIES} ${PLUGIN_LIBRARIES})
-  IF(PLUGIN_TARGET_LDFLAGS)
-    STRING(REGEX REPLACE ";" " " PLUGIN_TARGET_LDFLAGS  "${PLUGIN_TARGET_LDFLAGS}")  #FIXME does not deal with space-having ldflags
-    SET_TARGET_PROPERTIES(${PLUGIN_NAME} PROPERTIES LINK_FLAGS ${PLUGIN_TARGET_LDFLAGS})
-  ENDIF()
-  IF(PLUGIN_TARGET_CXXFLAGS)
-    STRING(REGEX REPLACE ";" " " PLUGIN_TARGET_CXXFLAGS  "${PLUGIN_TARGET_CXXFLAGS}")  #FIXME does not deal with space-having ldflags
-    SET_TARGET_PROPERTIES(${PLUGIN_NAME} PROPERTIES COMPILE_FLAGS ${PLUGIN_TARGET_CXXFLAGS})
-  ENDIF()
-ENDMACRO(ADD_PLUGIN_TARGET)
-
-#variable which contains list of plugin targets we want to install
-SET(PLUGIN_INSTALL_LIST)
-
-#project directory locations
-SET(LIBCORE_DIR ${TOP_LEVEL}/libcore)
-SET(LIBSPACE_DIR ${TOP_LEVEL}/libspace)
-SET(LIBPROXIMITY_DIR ${TOP_LEVEL}/libproximity)
-SET(LIBSUBSCRIPTION_DIR ${TOP_LEVEL}/libsubscription)
-SET(LIBOH_DIR ${TOP_LEVEL}/liboh)
-SET(SPACE_DIR ${TOP_LEVEL}/space)
-SET(SUBSCRIPTION_DIR ${TOP_LEVEL}/subscription)
-SET(PROXIMITY_DIR ${TOP_LEVEL}/proximity)
-SET(CPPOH_DIR ${TOP_LEVEL}/cppoh)
-
-#include locations
-SET(LIBSPACE_INCLUDE_DIR ${LIBSPACE_DIR}/include)
-SET(LIBPROXIMITY_INCLUDE_DIR ${LIBPROXIMITY_DIR}/include)
-SET(LIBSUBSCRIPTION_INCLUDE_DIR ${LIBSUBSCRIPTION_DIR}/include)
-SET(LIBOH_INCLUDE_DIR ${LIBOH_DIR}/include)
-
-#source file locations
-SET(LIBCORE_SOURCE_DIR ${LIBCORE_DIR}/src)
-SET(LIBSPACE_SOURCE_DIR ${LIBSPACE_DIR}/src)
-SET(LIBPROXIMITY_SOURCE_DIR ${LIBPROXIMITY_DIR}/src)
-SET(LIBSUBSCRIPTION_SOURCE_DIR ${LIBSUBSCRIPTION_DIR}/src)
-SET(LIBOH_SOURCE_DIR ${LIBOH_DIR}/src)
-SET(SPACE_SOURCE_DIR ${SPACE_DIR}/src)
-SET(PROXIMITY_SOURCE_DIR ${PROXIMITY_DIR}/src)
-SET(SUBSCRIPTION_SOURCE_DIR ${SUBSCRIPTION_DIR}/src)
-SET(CPPOH_SOURCE_DIR ${CPPOH_DIR}/src)
-
-#plugins locations
-SET(LIBCORE_PLUGIN_DIR ${LIBCORE_DIR}/plugins)
-SET(LIBPROXIMITY_PLUGIN_DIR ${LIBPROXIMITY_DIR}/plugins)
-#SET(LIBSUBSCRIPTION_PLUGIN_DIR ${LIBSUBSCRIPTION_DIR}/plugins)
-SET(LIBOH_PLUGIN_DIR ${LIBOH_DIR}/plugins)
-
-#cxx flags
-# FIXME these include directories should be project specific
-
-
-
-SET(INCLUDE_DIRECTORIES
-  ${LIBCORE_SOURCE_DIR}
-  ${LIBSPACE_INCLUDE_DIR}
-  ${LIBPROXIMITY_INCLUDE_DIR}
-  ${LIBSUBSCRIPTION_INCLUDE_DIR}
-  ${LIBOH_INCLUDE_DIR}
-  ${LIBOH_DIR}/plugins/ogre/meruCompat #temporary hack
-  ${SPACE_SOURCE_DIR}
-  ${PROXIMITY_SOURCE_DIR}
-  ${SUBSCRIPTION_SOURCE_DIR}
-  ${CPPOH_SOURCE_DIR}
-  ${Boost_INCLUDE_DIRS}
-  ${CURL_INCLUDE_DIRS}
-  ${PROTOCOLBUFFERS_INCLUDE_DIRS}
-  ${ANTLR_INCLUDE_DIRS}
-  ${PROX_INCLUDE_DIRS}
-  ${CXXTESTRoot}
-  ${CMAKE_CURRENT_SOURCE_DIR} #generated files
-  ${bullet_INCLUDE_DIRS}
-  ${SQLite3_INCLUDE_DIRS}
-  )
-IF(OGRE_FOUND AND sdl_FOUND)
-SET(INCLUDE_DIRECTORIES ${INCLUDE_DIRECTORIES} ${OGRE_INCLUDE_DIRS} ${sdl_INCLUDE_DIRS})
-ENDIF()
-IF(MONO_FOUND)
-SET(INCLUDE_DIRECTORIES ${INCLUDE_DIRECTORIES} ${MONO_INCLUDE_DIRS})
-ENDIF()
-IF(AWESOMIUM_FOUND)
-SET(INCLUDE_DIRECTORIES ${INCLUDE_DIRECTORIES} ${AWESOMIUM_INCLUDE_DIRS})
-ENDIF()
-
-SET(INCLUDE_DIRECTORIES ${INCLUDE_DIRECTORIES} ${TOP_LEVEL}/externals/pbj/)
-
-INCLUDE_DIRECTORIES(BEFORE ${INCLUDE_DIRECTORIES})
-ADD_DEFINITIONS(${ADDED_DEFINITIONS})
-
-SET(PBJ_SOURCE_FILES
-  ${TOP_LEVEL}/externals/pbj/PBJParseUtil.cpp
-  ${TOP_LEVEL}/externals/pbj/PBJLexer.cpp
-  ${TOP_LEVEL}/externals/pbj/PBJParser.cpp
-  ${TOP_LEVEL}/externals/pbj/main.cpp)
-SET(PBJ_BINARY pbj)
-ADD_EXECUTABLE(${PBJ_BINARY} ${PBJ_SOURCE_FILES} )
-TARGET_LINK_LIBRARIES(${PBJ_BINARY} ${ANTLR_LIBRARIES})
-IF(NOT WIN32)
-IF(NOT APPLE)
-#SET_TARGET_PROPERTIES(${PBJ_BINARY} PROPERTIES COMPILE_FLAGS -m32)
-#SET_TARGET_PROPERTIES(${PBJ_BINARY} PROPERTIES LINK_FLAGS -m32)
-ENDIF()
-ENDIF()
-GET_TARGET_PROPERTY(PBJ_RUNABLE ${PBJ_BINARY} LOCATION)
-
-SET(INCLUDE_COMMAND)
-FOREACH(INCLUDE_NONCE ${INCLUDE_DIRECTORIES})
-  SET(INCLUDE_COMMAND  ${INCLUDE_COMMAND} -I${INCLUDE_NONCE})
-ENDFOREACH()
-
-#protocol buffers preprocessing
-SET(ProtocolBuffersRoot ${LIBCORE_DIR}/protocol)
-SET(ProtocolBuffersSources
-  Persistence Sirikata Time Subscription Test
-)
-
-
-SET(SirikataProtocolDirectory ${LIBCORE_SOURCE_DIR})
-
-# Based on dependencies, generate arguments for protocol buffers generation
-SET(PROTOCOLBUFFERS_GENS GENERATE_CPP)
-SET(SCRIPTING_PROTOCOLBUFFERS_GENS ${PROTOCOLBUFFERS_GENS})
-IF(MONO_FOUND AND PROTOCOLBUFFERS_SUPPORTS_CSHARP)
-  SET(SCRIPTING_PROTOCOLBUFFERS_GENS ${SCRIPTING_PROTOCOLBUFFERS_GENS} GENERATE_CSHARP)
-  # FIXME there should probably be another check for IronPython
-  SET(SCRIPTING_PROTOCOLBUFFERS_GENS ${SCRIPTING_PROTOCOLBUFFERS_GENS} GENERATE_PYTHON)
-ENDIF()
-
-
-SET(PROTOCOLBUFFERS_CPP_HEADER "#include \"util/Standard.hh\"\n")
-
-ADD_PBJ_TARGET(MessageHeader
-  INPUTDIR ${ProtocolBuffersRoot}
-  PLUGINNAME "Protocol"
-  IMPORTS ${ProtocolBuffersRoot}
-  OUTPUTDIR ${SirikataProtocolDirectory}
-  OUTPUTCPPFILE ${SirikataProtocolDirectory}/MessageHeader_protobuf.cc
-  CPP_HEADER ${PROTOCOLBUFFERS_CPP_HEADER}
-  ${PROTOCOLBUFFERS_GENS}
-)
-
-ADD_PBJ_TARGET(${ProtocolBuffersSources}
-  INPUTDIR ${ProtocolBuffersRoot}
-  PLUGINNAME "Prox"
-  IMPORTS ${ProtocolBuffersRoot}
-  OUTPUTDIR ${SirikataProtocolDirectory}
-  OUTPUTCPPFILE ${SirikataProtocolDirectory}/Prox_protobuf.cc
-  CPP_HEADER ${PROTOCOLBUFFERS_CPP_HEADER}
-  ${PROTOCOLBUFFERS_GENS}
-)
-
-# For scripting
-SET(ScriptingProtocolBuffersSources ${ProtocolBuffersSources} MessageHeader Physics)
-
-ADD_PBJ_TARGET(${ScriptingProtocolBuffersSources}
-  INPUTDIR ${ProtocolBuffersRoot}
-  IMPORTS ${ProtocolBuffersRoot}
-  OUTPUTDIR ${SirikataProtocolDirectory}
-  GENERATE_CSHARP GENERATE_PYTHON
-  ${SCRIPTING_PROTOCOLBUFFERS_GENS}
-)
-SET(PROTOCOLBUFFERS_SCRIPTING_OUTPUTS ${PROTOCOLBUFFERS_ALL_OUTPUTS})
-
-ADD_PBJ_TARGET(${ProtocolBuffersSources}
-  INPUTDIR ${ProtocolBuffersRoot}
-  PLUGINNAME "ObjectHost"
-  IMPORTS ${ProtocolBuffersRoot}
-  OUTPUTDIR ${SirikataProtocolDirectory}
-  OUTPUTCPPFILE ${SirikataProtocolDirectory}/ObjectHost_protobuf.cc
-  CPP_HEADER ${PROTOCOLBUFFERS_CPP_HEADER}
-  ${PROTOCOLBUFFERS_GENS}
-)
-
-ADD_PBJ_TARGET(${ProtocolBuffersSources}
-  INPUTDIR ${ProtocolBuffersRoot}
-  PLUGINNAME "Ogre"
-  IMPORTS ${ProtocolBuffersRoot}
-  OUTPUTDIR ${SirikataProtocolDirectory}
-  OUTPUTCPPFILE ${SirikataProtocolDirectory}/Ogre_protobuf.cc
-  CPP_HEADER ${PROTOCOLBUFFERS_CPP_HEADER}
-  ${PROTOCOLBUFFERS_GENS}
-)
-
-ADD_PBJ_TARGET(Sirikata Physics
-  INPUTDIR ${ProtocolBuffersRoot}
-  PLUGINNAME "Bullet"
-  IMPORTS ${ProtocolBuffersRoot}
-  OUTPUTDIR ${SirikataProtocolDirectory}
-  OUTPUTCPPFILE ${SirikataProtocolDirectory}/Bullet_protobuf.cc
-  CPP_HEADER ${PROTOCOLBUFFERS_CPP_HEADER}
-  ${PROTOCOLBUFFERS_GENS}
-)
-
-ADD_PBJ_TARGET(${ProtocolBuffersSources}
-  INPUTDIR ${ProtocolBuffersRoot}
-  PLUGINNAME "ObjectHostBinary"
-  IMPORTS ${ProtocolBuffersRoot}
-  OUTPUTDIR ${SirikataProtocolDirectory}
-  OUTPUTCPPFILE ${SirikataProtocolDirectory}/ObjectHostBinary_protobuf.cc
-  CPP_HEADER ${PROTOCOLBUFFERS_CPP_HEADER}
-  ${PROTOCOLBUFFERS_GENS}
-)
-
-ADD_PBJ_TARGET(${ProtocolBuffersSources}
-  INPUTDIR ${ProtocolBuffersRoot}
-  PLUGINNAME "Space"
-  IMPORTS ${ProtocolBuffersRoot}
-  OUTPUTDIR ${SirikataProtocolDirectory}
-  OUTPUTCPPFILE ${SirikataProtocolDirectory}/Space_protobuf.cc
-  CPP_HEADER ${PROTOCOLBUFFERS_CPP_HEADER}
-  ${PROTOCOLBUFFERS_GENS}
-)
-
-ADD_PBJ_TARGET(${ProtocolBuffersSources}
-  INPUTDIR ${ProtocolBuffersRoot}
-  PLUGINNAME "Test"
-  IMPORTS ${ProtocolBuffersRoot}
-  OUTPUTDIR ${SirikataProtocolDirectory}
-  OUTPUTCPPFILE ${SirikataProtocolDirectory}/Test_protobuf.cc
-  CPP_HEADER ${PROTOCOLBUFFERS_CPP_HEADER}
-  ${PROTOCOLBUFFERS_GENS}
-)
-
-ADD_PBJ_TARGET(Persistence
-  INPUTDIR ${ProtocolBuffersRoot}
-  PLUGINNAME "SQLite"
-  IMPORTS ${ProtocolBuffersRoot}
-  OUTPUTDIR ${SirikataProtocolDirectory}
-  OUTPUTCPPFILE ${SirikataProtocolDirectory}/SQLite_protobuf.cc
-  CPP_HEADER ${PROTOCOLBUFFERS_CPP_HEADER}
-  ${PROTOCOLBUFFERS_GENS}
-)
-
-ADD_PBJ_TARGET(${ProtocolBuffersSources}
-  INPUTDIR ${ProtocolBuffersRoot}
-  PLUGINNAME "Proximity"
-  IMPORTS ${ProtocolBuffersRoot}
-  OUTPUTDIR ${SirikataProtocolDirectory}
-  OUTPUTCPPFILE ${SirikataProtocolDirectory}/Proximity_protobuf.cc
-  CPP_HEADER ${PROTOCOLBUFFERS_CPP_HEADER}
-  ${PROTOCOLBUFFERS_GENS}
-)
-
-ADD_PBJ_TARGET(Subscription
-  INPUTDIR
-  ${ProtocolBuffersRoot}
-  PLUGINNAME "Subscription"
-  IMPORTS ${ProtocolBuffersRoot}
-  OUTPUTDIR ${SirikataProtocolDirectory}
-  OUTPUTCPPFILE ${SirikataProtocolDirectory}/Subscription_protobuf.cc
-  CPP_HEADER ${PROTOCOLBUFFERS_CPP_HEADER}
-  ${PROTOCOLBUFFERS_GENS}
-)
-
-
-#binary files to be linked into sirikata
-SET(BINARY_TO_CPP_SOURCE_FILE ${TOP_LEVEL}/externals/binarytocpp/binarytocpp.cpp)
-SET(BINARY_TO_CPP_BINARY binarytocpp)
-ADD_EXECUTABLE(${BINARY_TO_CPP_BINARY} ${BINARY_TO_CPP_SOURCE_FILE} )
-GET_TARGET_PROPERTY(BINARY_TO_CPP_RUNABLE ${BINARY_TO_CPP_BINARY} LOCATION)
-
-IF(OGRE_ZIP_PATH)
-    SET(SirikataOgreCoreZipCpp ${CMAKE_CURRENT_SOURCE_DIR}/ogreCoreZip.hpp)
-    ADD_CUSTOM_COMMAND(OUTPUT ${SirikataOgreCoreZipCpp}
-                       COMMAND ${BINARY_TO_CPP_RUNABLE} -namespace=Sirikata ogreCoreZip ${OGRE_ZIP_PATH} ${SirikataOgreCoreZipCpp}
-                       DEPENDS ${BINARY_TO_CPP_BINARY}
-                       COMMENT "Creating OgreZip cpp file")
-  SET_DIRECTORY_PROPERTIES(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES ${SirikataOgreCoreZipCpp})
-ENDIF()
-#source files
-
-SET(AdditionalProtoDepends)
-FOREACH(FILE ${ScriptingProtocolBuffersSources})
-   SET(AdditionalProtoDepends ${AdditionalProtoDepends} ${ScriptsRoot}/ironpython/protocol/${FILE}_pb2.py)
-ENDFOREACH()
-ADD_CUSTOM_TARGET(SirikataPythonProtocol ALL
-              DEPENDS ${AdditionalProtoDepends}
-              COMMENT "Checking ${AdditionalProtoDepends}")
-
-IF(MONO_FOUND)
-  SET(SirikataProtoScriptSources ${SirikataProtoScriptSources})
-  FOREACH(FILE ${ScriptingProtocolBuffersSources})
-     SET(SirikataProtoScriptSources ${SirikataProtoScriptSources}
-  ${ScriptsRoot}/csharp/protocol/${FILE}.pbj.cs ${ScriptsRoot}/csharp/protocol/${FILE}.cs )
-  ENDFOREACH()
-
-  SET(SirikataProtoScriptSources ${SirikataProtoScriptSources} ${TOP_LEVEL}/externals/pbj/PBJ.cs)
-  SET(SirikataProtoScriptRuntime_LIBRARY_DIR ${CMAKE_CURRENT_BINARY_DIR})
-  SET(SirikataProtoScriptRuntime_LIBRARY ${SirikataProtoScriptRuntime_LIBRARY_DIR}/Sirikata.Protocol.dll)
-  IF(PROTOCOLBUFFERS_SUPPORTS_CSHARP)
-    ADD_CUSTOM_TARGET(SirikataScriptProtocol ALL
-                  DEPENDS ${SirikataProtoScriptSources} ${SirikataProtoScriptRuntime_LIBRARY}
-                  COMMENT "Checking Sirikata.Protocol.dll")
-    ADD_CUSTOM_COMMAND(OUTPUT ${SirikataProtoScriptRuntime_LIBRARY}
-                   COMMAND ${GMCS_EXECUTABLE} -debug
-                                     -target:library
-                                     -out:${SirikataProtoScriptRuntime_LIBRARY}
-                                     -warn:2 -nowarn:3021
-                                     -r:${PROTOCOLBUFFERS_BIN_DIRS}/Google.ProtocolBuffers.dll
-                                     ${SirikataProtoScriptSources}
-                   DEPENDS ${SirikataProtoScriptSources}
-                   COMMENT "Building Sirikata.Protocol.dll")
-  ENDIF()
-  SET(SirikataProtoScriptRuntimeBuildOutputs ${SirikataProtoScriptRuntime_LIBRARY} ${SirikataProtoScriptRuntime_LIBRARY}.mdb)
-  SET_DIRECTORY_PROPERTIES(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES "${SirikataProtoScriptRuntimeBuildOutputs}")
-
-
-  FILE(GLOB SirikataScriptSources ${ScriptsRoot}/csharp/*.cs )
-  SET(SirikataScriptRuntime_LIBRARY_DIR ${CMAKE_CURRENT_BINARY_DIR})
-  SET(SirikataScriptRuntime_LIBRARY ${SirikataScriptRuntime_LIBRARY_DIR}/Sirikata.Runtime.dll)
-  ADD_CUSTOM_TARGET(SirikataScriptRuntime ALL
-                  DEPENDS ${SirikataScriptSources} ${SirikataScriptRuntime_LIBRARY}
-                  COMMENT "Checking Sirikata.Runtime.dll")
-  ADD_CUSTOM_COMMAND(OUTPUT ${SirikataScriptRuntime_LIBRARY}
-                   COMMAND ${GMCS_EXECUTABLE} -debug
-                                     -target:library
-                                     -out:${SirikataScriptRuntime_LIBRARY}
-                                     -warn:2
-                                     ${CECIL_LIBRARIES}
-                                     ${IRON_PYTHON_LIBRARIES}
-                                     ${SirikataScriptSources}
-                   DEPENDS ${SirikataScriptSources}
-                   COMMENT "Building Sirikata.Runtime.dll")
-  SET(SirikataScriptRuntimeBuildOutputs ${SirikataScriptRuntime_LIBRARY} ${SirikataScriptRuntime_LIBRARY}.mdb)
-  SET_DIRECTORY_PROPERTIES(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES "${SirikataScriptRuntimeBuildOutputs}")
-
-ENDIF()
-
-SET(SIRIKATA_CORE_SOURCES
-	${PROTOCOLBUFFERS_SCRIPTING_OUTPUTS}
-	${SirikataProtocolDirectory}/MessageHeader_protobuf.cc
-	${LIBCORE_SOURCE_DIR}/transfer/HTTPRequest.cpp
-	${LIBCORE_SOURCE_DIR}/transfer/FileProtocolHandler.cpp
-	${LIBCORE_SOURCE_DIR}/transfer/DiskCacheLayer.cpp
-	${LIBCORE_SOURCE_DIR}/persistence/ObjectStorage.cpp
-	${LIBCORE_SOURCE_DIR}/persistence/ReadWriteHandlerFactory.cpp
-	${LIBCORE_SOURCE_DIR}/persistence/MinitransactionHandlerFactory.cpp
-	${LIBCORE_SOURCE_DIR}/task/DependencyTask.cpp
-	${LIBCORE_SOURCE_DIR}/task/EventManager.cpp
-	${LIBCORE_SOURCE_DIR}/task/WorkQueue.cpp
-	${LIBCORE_SOURCE_DIR}/task/Event.cpp
-	${LIBCORE_SOURCE_DIR}/task/UniqueId.cpp
-	${LIBCORE_SOURCE_DIR}/task/Time.cpp
-   	${LIBCORE_SOURCE_DIR}/options/Options.cpp
-	${LIBCORE_SOURCE_DIR}/network/IOServiceFactory.cpp
-	${LIBCORE_SOURCE_DIR}/network/TCPDefinitions.cpp
-	${LIBCORE_SOURCE_DIR}/network/Stream.cpp
-	${LIBCORE_SOURCE_DIR}/network/StreamListener.cpp
-	${LIBCORE_SOURCE_DIR}/network/StreamFactory.cpp
-	${LIBCORE_SOURCE_DIR}/network/StreamListenerFactory.cpp
-	${LIBCORE_SOURCE_DIR}/util/DynamicLibrary.cpp
-	${LIBCORE_SOURCE_DIR}/util/internal_sha2.cpp
-	${LIBCORE_SOURCE_DIR}/util/Logging.cpp
-	${LIBCORE_SOURCE_DIR}/util/Plugin.cpp
-	${LIBCORE_SOURCE_DIR}/util/PluginManager.cpp
-	${LIBCORE_SOURCE_DIR}/util/Sha256.cpp
-	${LIBCORE_SOURCE_DIR}/util/ThreadSafeQueue.cpp
-	${LIBCORE_SOURCE_DIR}/util/UUID.cpp
-    ${LIBCORE_SOURCE_DIR}/util/ThreadId.cpp
-	${LIBCORE_SOURCE_DIR}/util/BoundingInfo.cpp
-        ${LIBCORE_SOURCE_DIR}/util/SentMessage.cpp
-        ${LIBCORE_SOURCE_DIR}/util/QueryTracker.cpp
-)
-
-#precompiled header
-IF(NOT WIN32)
- IF(${CMAKE_COMPILER_IS_GNUCXX})
-  SET(SIRIKATA_CORE_SOURCES
-     ${LIBCORE_SOURCE_DIR}/util/Standard.hh.gch ${SIRIKATA_CORE_SOURCES})
-  SET_DIRECTORY_PROPERTIES(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES
-    ${LIBCORE_SOURCE_DIR}/util/Standard.hh.gch)
-
-  SET(PCH_INPUT ${LIBCORE_SOURCE_DIR}/util/Standard.hh)
-  SET(PCH_OUTPUT ${LIBCORE_SOURCE_DIR}/util/Standard.hh.gch)
-  IF(ISDEBUG)
-    SET(PCH_CXX_FLAGS  ${CMAKE_CXX_FLAGS_DEBUG} )
-  ELSE()
-    SET(PCH_CXX_FLAGS  ${CMAKE_CXX_FLAGS_RELEASE} )
-  ENDIF()
-  SEPARATE_ARGUMENTS(PCH_CXX_FLAGS)
-  SET(FINAL_COMMAND ${CMAKE_CXX_COMPILER} ${PCH_CXX_FLAGS} ${INCLUDE_COMMAND} ${ADDED_DEFINITIONS} ${PCH_INPUT})
-  ADD_CUSTOM_COMMAND(OUTPUT ${PCH_OUTPUT}
-                     COMMAND ${FINAL_COMMAND}
-                     DEPENDS ${PCH_INPUT}
- ${LIBCORE_SOURCE_DIR}/options/OptionValue.hpp
- ${LIBCORE_SOURCE_DIR}/util/Any.hpp
- ${LIBCORE_SOURCE_DIR}/util/Array.hpp
- ${LIBCORE_SOURCE_DIR}/util/BoundingBox.hpp
- ${LIBCORE_SOURCE_DIR}/util/BoundingSphere.hpp
- ${LIBCORE_SOURCE_DIR}/util/Factory.hpp
- ${LIBCORE_SOURCE_DIR}/util/Location.hpp
- ${LIBCORE_SOURCE_DIR}/util/Logging.hpp
- ${LIBCORE_SOURCE_DIR}/util/Matrix3x3.hpp
- ${LIBCORE_SOURCE_DIR}/util/Noncopyable.hpp
- ${LIBCORE_SOURCE_DIR}/util/Platform.hpp
- ${LIBCORE_SOURCE_DIR}/util/Quaternion.hpp
- ${LIBCORE_SOURCE_DIR}/util/SelfWeakPtr.hpp
- ${LIBCORE_SOURCE_DIR}/util/Singleton.hpp
- ${LIBCORE_SOURCE_DIR}/util/Standard.hh
- ${LIBCORE_SOURCE_DIR}/util/TotallyOrdered.hpp
- ${LIBCORE_SOURCE_DIR}/util/Transform.hpp
- ${LIBCORE_SOURCE_DIR}/util/BoundingInfo.hpp
- ${LIBCORE_SOURCE_DIR}/util/UUID.hpp
- ${LIBCORE_SOURCE_DIR}/util/ThreadId.hpp
- ${LIBCORE_SOURCE_DIR}/util/Vector3.hpp
- ${LIBCORE_SOURCE_DIR}/util/Vector4.hpp
- ${LIBCORE_SOURCE_DIR}/util/boost_sha1.hpp
- ${LIBCORE_SOURCE_DIR}/util/boost_uuid.hpp
- ${LIBCORE_SOURCE_DIR}/util/valgrind.h
-                     COMMENT "${FINAL_COMMAND}")
-#  ADD_DEPENDENCIES(${SIRIKATA_CORE_LIB} ${PCH_OUTPUT})
- ENDIF()
-ENDIF()
-
-SET(LIBSPACE_SOURCES
-  ${SirikataProtocolDirectory}/Space_protobuf.cc
-                     ${LIBSPACE_SOURCE_DIR}/Space.cpp
-                     ${LIBSPACE_SOURCE_DIR}/ObjectConnections.cpp
-                     ${LIBSPACE_SOURCE_DIR}/Loc.cpp
-                     ${LIBSPACE_SOURCE_DIR}/Registration.cpp
-                      )
-SET(LIBPROXIMITY_SOURCES
-                  ${SirikataProtocolDirectory}/Proximity_protobuf.cc
-                  ${LIBPROXIMITY_SOURCE_DIR}/ProximityConnectionFactory.cpp
-                  ${LIBPROXIMITY_SOURCE_DIR}/ProximitySystem.cpp
-                  ${LIBPROXIMITY_SOURCE_DIR}/ProximitySystemFactory.cpp
-                  ${LIBPROXIMITY_SOURCE_DIR}/SingleStreamProximityConnection.cpp )
-
-SET(LIBSUBSCRIPTION_SOURCES
-                  ${SirikataProtocolDirectory}/Subscription_protobuf.cc
-                  ${LIBSUBSCRIPTION_SOURCE_DIR}/SubscriptionClient.cpp
-                  ${LIBSUBSCRIPTION_SOURCE_DIR}/Server.cpp
-                  ${LIBSUBSCRIPTION_SOURCE_DIR}/Broadcast.cpp
-                  ${LIBSUBSCRIPTION_SOURCE_DIR}/SubscriptionState.cpp
- )
-
-SET(LIBOH_SOURCES
-                  ${SirikataProtocolDirectory}/ObjectHost_protobuf.cc
-                  ${LIBOH_SOURCE_DIR}/ObjectHost.cpp
-                  ${LIBOH_SOURCE_DIR}/SpaceIDMap.cpp
-                  ${LIBOH_SOURCE_DIR}/HostedObject.cpp
-                  ${LIBOH_SOURCE_DIR}/ObjectHostProxyManager.cpp
-                  ${LIBOH_SOURCE_DIR}/TopLevelSpaceConnection.cpp
-                  ${LIBOH_SOURCE_DIR}/SpaceTimeOffsetManager.cpp
-                  ${LIBOH_SOURCE_DIR}/SpaceConnection.cpp
-                  ${LIBOH_SOURCE_DIR}/LightInfo.cpp
-                  ${LIBOH_SOURCE_DIR}/ProxyMeshObject.cpp
-                  ${LIBOH_SOURCE_DIR}/ProxyLightObject.cpp
-                  ${LIBOH_SOURCE_DIR}/ProxyObject.cpp
-                  ${LIBOH_SOURCE_DIR}/ProxyCameraObject.cpp
-                  ${LIBOH_SOURCE_DIR}/ProxyWebViewObject.cpp
-                  ${LIBOH_SOURCE_DIR}/SimulationFactory.cpp
-                  ${LIBOH_SOURCE_DIR}/ObjectScriptManagerFactory.cpp )
-SET(SPACE_SOURCES ${SPACE_SOURCE_DIR}/main.cpp )
-SET(PROXIMITY_SOURCES ${PROXIMITY_SOURCE_DIR}/main.cpp )
-SET(SUBSCRIPTION_SOURCES ${SUBSCRIPTION_SOURCE_DIR}/main.cpp )
-SET(CPPOH_SOURCES ${CPPOH_SOURCE_DIR}/main.cpp
-${CPPOH_SOURCE_DIR}/Config.cpp
-${CPPOH_SOURCE_DIR}/CDNConfig.cpp
-  ${SirikataProtocolDirectory}/ObjectHostBinary_protobuf.cc
- )
-
-# plugins sources
-
-SET(LIBPROXIMITY_PLUGIN_PROX_DIR ${LIBPROXIMITY_PLUGIN_DIR}/prox)
-SET(LIBPROXIMITY_PLUGIN_PROX_SOURCES
-  ${SirikataProtocolDirectory}/Prox_protobuf.cc
-  ${LIBPROXIMITY_PLUGIN_PROX_DIR}/ProxPlugin.cpp
-  ${LIBPROXIMITY_PLUGIN_PROX_DIR}/ProxBridge.cpp
-  ${LIBPROXIMITY_PLUGIN_PROX_DIR}/BruteForceProx.cpp
-  ${PROX_SOURCE_FILES})
-
-
-SET(LIBCORE_PLUGIN_SKELETON_DIR ${LIBCORE_PLUGIN_DIR}/skeleton)
-SET(LIBCORE_PLUGIN_SKELETON_SOURCES ${LIBCORE_PLUGIN_SKELETON_DIR}/PluginInterface.cpp)
-
-SET(LIBCORE_PLUGIN_SQLITE_DIR ${LIBCORE_PLUGIN_DIR}/sqlite)
-SET(LIBCORE_PLUGIN_SQLITE_SOURCES
-        ${SirikataProtocolDirectory}/SQLite_protobuf.cc
-        ${LIBCORE_PLUGIN_SQLITE_DIR}/SQLitePlugin.cpp
-        ${LIBCORE_PLUGIN_SQLITE_DIR}/SQLite.cpp
-        ${LIBCORE_PLUGIN_SQLITE_DIR}/SQLiteObjectStorage.cpp)
-
-
-SET(LIBCORE_PLUGIN_TCPSST_DIR ${LIBCORE_PLUGIN_DIR}/tcpsst)
-SET(LIBCORE_PLUGIN_TCPSST_SOURCES
-        ${LIBCORE_PLUGIN_TCPSST_DIR}/TcpsstPlugin.cpp
-        ${LIBCORE_PLUGIN_TCPSST_DIR}/TCPStream.cpp
-        ${LIBCORE_PLUGIN_TCPSST_DIR}/TCPStreamListener.cpp
-        ${LIBCORE_PLUGIN_TCPSST_DIR}/MultiplexedSocket.cpp
-        ${LIBCORE_PLUGIN_TCPSST_DIR}/ASIOConnectAndHandshake.cpp
-        ${LIBCORE_PLUGIN_TCPSST_DIR}/ASIOReadBuffer.cpp
-        ${LIBCORE_PLUGIN_TCPSST_DIR}/ASIOSocketWrapper.cpp
-        ${LIBCORE_PLUGIN_TCPSST_DIR}/ASIOStreamBuilder.cpp)
-
-
-SET(LIBOH_PLUGIN_OGREGRAPHICS_DIR ${LIBOH_PLUGIN_DIR}/ogre)
-SET(GFX ${LIBOH_PLUGIN_OGREGRAPHICS_DIR})
-SET(INPUT ${GFX}/input)
-SET(LIBOH_PLUGIN_OGREGRAPHICS_SOURCES
-  ${SirikataProtocolDirectory}/Ogre_protobuf.cc
-  ${SirikataOgreCoreZipCpp}
-  ${GFX}/OgreSystem.cpp
-  ${GFX}/OgreMeshRaytrace.cpp
-  ${GFX}/CubeMap.cpp
-  ${GFX}/OgreSystemMouseHandler.cpp
-  ${GFX}/DragActions.cpp
-  ${GFX}/InputBinding.cpp
-  ${GFX}/InputBindingEvent.cpp
-  ${GFX}/InputResponse.cpp
-  ${INPUT}/SDLInputManager.cpp
-  ${INPUT}/InputEventDescriptor.cpp
-  ${INPUT}/InputEvents.cpp
-  ${INPUT}/InputDevice.cpp
-  ${INPUT}/SDLInputDevice.cpp
-  ${GFX}/Entity.cpp
-  ${GFX}/LightEntity.cpp
-  ${GFX}/MeshEntity.cpp
-  ${GFX}/CameraEntity.cpp
-  ${GFX}/OgrePlugin.cpp
-  ${GFX}/CameraPath.cpp
-${GFX}/meruCompat/Event.cpp
-${GFX}/meruCompat/EventSource.cpp
-${GFX}/meruCompat/MeruDefs.cpp
-${GFX}/meruCompat/SequentialWorkQueue.cpp
-${GFX}/resourceManager/CDNArchive.cpp
-${GFX}/resourceManager/CDNArchiveFactory.cpp
-${GFX}/resourceManager/CDNArchivePlugin.cpp
-${GFX}/resourceManager/GraphicsCamera.cpp
-${GFX}/resourceManager/GraphicsLight.cpp
-${GFX}/resourceManager/GraphicsObject.cpp
-${GFX}/resourceManager/GraphicsRenderSettings.cpp
-${GFX}/resourceManager/GraphicsResource.cpp
-${GFX}/resourceManager/GraphicsResourceAsset.cpp
-${GFX}/resourceManager/GraphicsResourceEntity.cpp
-${GFX}/resourceManager/GraphicsResourceManager.cpp
-${GFX}/resourceManager/GraphicsResourceMaterial.cpp
-${GFX}/resourceManager/GraphicsResourceMesh.cpp
-${GFX}/resourceManager/GraphicsResourceName.cpp
-${GFX}/resourceManager/GraphicsResourceShader.cpp
-${GFX}/resourceManager/GraphicsResourceSkeleton.cpp
-${GFX}/resourceManager/GraphicsResourceTexture.cpp
-${GFX}/resourceManager/GraphicsSystem.cpp
-${GFX}/resourceManager/ManualMaterialLoader.cpp
-${GFX}/resourceManager/ReplacingDataStream.cpp
-${GFX}/resourceManager/ResourceDependencyTask.cpp
-${GFX}/resourceManager/ResourceDownloadTask.cpp
-${GFX}/resourceManager/ResourceLoadTask.cpp
-${GFX}/resourceManager/ResourceLoadingQueue.cpp
-${GFX}/resourceManager/ResourceManager.cpp
-${GFX}/resourceManager/ResourceTransfer.cpp
-${GFX}/resourceManager/ResourceUnloadTask.cpp
-${GFX}/resourceManager/UploadTool.cpp
-${GFX}/ViewportOverlay.cpp
-${GFX}/WebView.cpp
-${GFX}/WebViewManager.cpp
-        )
-
-#test source files
-SET(CXXTESTSources
-libcore/test/AnyTest.hpp
-libcore/test/AtomicTest.hpp
-#libcore/test/CacheLayerTest.hpp
-libcore/test/DownloadTest.hpp
-libcore/test/EventTest.hpp
-libcore/test/ExtrapolationTest.hpp
-libcore/test/FactoryTest.hpp
-libcore/test/ListenerTest.hpp
-libcore/test/Matrix3Test.hpp
-libcore/test/MinitransactionHandlerTest.hpp
-libcore/test/NameLookupTest.hpp
-libcore/test/ObjectStorageTest.hpp
-libcore/test/OptionTest.hpp
-#libcore/test/ProxTest.hpp
-libcore/test/QuaternionTest.hpp
-libcore/test/ReadWriteHandlerTest.hpp
-libcore/test/RoutableMessageTest.hpp
-libcore/test/SQLiteMinitransactionTest.hpp
-libcore/test/SQLiteReadWriteTest.hpp
-libcore/test/SstTest.hpp
-libcore/test/SubscriptionTest.hpp
-#libcore/test/ThreadSafeQueueTest.hpp
-libcore/test/TR1Test.hpp
-#libcore/test/UploadTest.hpp
-libcore/test/Vector3Test.hpp
- )
-#  libcore/test/ThreadSafeQueueTest.hpp
-ADD_CXXTEST_CPP_TARGET(CXXTEST ${CXXTESTSources}
-	LIBRARYDIR ${CXXTESTRoot})
-
-
-
-
-
-SET(TEST_SOURCES ${CXXTEST_CPP_FILE}
-                 ${SirikataProtocolDirectory}/Test_protobuf.cc
-                 ${LIBCORE_DIR}/test/SQLiteMinitransactionTest.cpp
-                 ${LIBCORE_DIR}/test/ObjectStorageTest.cpp
-                 ${LIBCORE_DIR}/test/MinitransactionHandlerTest.cpp
-                 ${LIBCORE_DIR}/test/SQLiteReadWriteTest.cpp
-                 ${LIBCORE_DIR}/test/ReadWriteHandlerTest.cpp
-
-)
-
-
-#linker flags
-SET(CMAKE_DEBUG_POSTFIX "_d")
-
-IF(WIN32)
-  SET(SYSTEM_DL_LIBRARY "wsock32")
-ELSE()
-  SET(SYSTEM_DL_LIBRARY "dl")
-ENDIF()
-
-SET(SIRIKATA_CORE_LIBRARIES
-    ${SYSTEM_DL_LIBRARY}
-
-    ${CURL_LIBRARIES}
-    ${Boost_LIBRARIES} )
-
-IF(AWESOMIUM_FOUND)
-  SET(AWESOMIUM_CFLAGS -DHAVE_AWESOMIUM)
-ELSE()
-  SET(AWESOMIUM_CFLAGS "")
-  SET(AWESOMIUM_LIBRARIES "")
-  SET(AWESOMIUM_LDFLAGS "")
-  SET(AWESOMIUM_LIBRARY_DIRS "")
-ENDIF()
-
-SET(FINAL_LINK_DIRS ${ANTLR_LIBRARY_DIRS} ${Boost_LIBRARY_DIRS})
-IF(OGRE_FOUND AND sdl_FOUND)
-SET(FINAL_LINK_DIRS ${FINAL_LINK_DIRS} ${OGRE_LIBRARY_DIRS} ${sdl_LIBRARY_DIRS} ${AWESOMIUM_LIBRARY_DIRS})
-ENDIF()
-IF(MONO_FOUND)
-SET(FINAL_LINK_DIRS ${FINAL_LINK_DIRS} ${MONO_LIBRARY_DIRS})
-ENDIF()
-IF(bullet_FOUND)
-SET(FINAL_LINK_DIRS ${FINAL_LINK_DIRS} ${bullet_LIBRARY_DIRS})
-ENDIF()
-IF(SQLite3_FOUND)
-SET(FINAL_LINK_DIRS ${FINAL_LINK_DIRS} ${SQLite3_LIBRARY_DIRS})
-ENDIF()
-
-LINK_DIRECTORIES(${FINAL_LINK_DIRS})
-
-SET(SIRIKATA_CORE_LIB sirikata-core)
-SET(SIRIKATA_SPACE_LIB sirikata-space)
-SET(SIRIKATA_PROXIMITY_LIB sirikata-proximity)
-SET(SIRIKATA_SUBSCRIPTION_LIB sirikata-subscription)
-SET(SIRIKATA_OH_LIB sirikata-oh)
-SET(SPACE_BINARY space)
-SET(PROXIMITY_BINARY proximity)
-SET(SUBSCRIPTION_BINARY subscription)
-SET(CPPOH_BINARY cppoh)
-SET(TEST_BINARY tests)
-
-
-# FIXME we're doing static linking now and need this to get the export/import
-# macros working properly.
-# ADD_DEFINITIONS(-DSTATIC_LINKED)
-
-#libraries
-ADD_LIBRARY(${SIRIKATA_CORE_LIB} SHARED ${SIRIKATA_CORE_SOURCES})
-SET_TARGET_PROPERTIES(${SIRIKATA_CORE_LIB} PROPERTIES COMPILE_DEFINITIONS SIRIKATA_BUILD)
-TARGET_LINK_LIBRARIES(${SIRIKATA_CORE_LIB} ${SIRIKATA_CORE_LIBRARIES} ${PROTOCOLBUFFERS_LIBRARIES})
-IF(sirikata_core_LDFLAGS OR sirikata_LDFLAGS)
-  SET(sirikata_core_LDFLAGS ${sirikata_core_LDFLAGS} ${sirikata_LDFLAGS})
-  SET_TARGET_PROPERTIES(${SIRIKATA_CORE_LIB} PROPERTIES LINK_FLAGS ${sirikata_core_LDFLAGS})
-ENDIF()
-#ADD_DEPENDENCIES(${SIRIKATA_CORE_LIB})
-
-ADD_LIBRARY(${SIRIKATA_PROXIMITY_LIB} SHARED ${LIBPROXIMITY_SOURCES})
-SET_TARGET_PROPERTIES(${SIRIKATA_PROXIMITY_LIB} PROPERTIES COMPILE_DEFINITIONS SIRIKATA_PROXIMITY_BUILD)
-ADD_DEPENDENCIES(${SIRIKATA_PROXIMITY_LIB} ${SIRIKATA_CORE_LIB})
-IF(sirikata_core_LDFLAGS)# use the core ldflags--these guys act similarly to core for their respective modules
-  SET_TARGET_PROPERTIES(${SIRIKATA_PROXIMITY_LIB} PROPERTIES LINK_FLAGS ${sirikata_core_LDFLAGS})
-ENDIF()
-TARGET_LINK_LIBRARIES(${SIRIKATA_PROXIMITY_LIB} ${SIRIKATA_CORE_LIB} ${PROTOCOLBUFFERS_LIBRARIES})
-
-ADD_LIBRARY(${SIRIKATA_SUBSCRIPTION_LIB} SHARED ${LIBSUBSCRIPTION_SOURCES})
-SET_TARGET_PROPERTIES(${SIRIKATA_SUBSCRIPTION_LIB} PROPERTIES COMPILE_DEFINITIONS SIRIKATA_SUBSCRIPTION_BUILD)
-ADD_DEPENDENCIES(${SIRIKATA_SUBSCRIPTION_LIB} ${SIRIKATA_CORE_LIB})
-IF(sirikata_core_LDFLAGS)# use the core ldflags--these guys act similarly to core for their respective modules
-  SET_TARGET_PROPERTIES(${SIRIKATA_SUBSCRIPTION_LIB} PROPERTIES LINK_FLAGS ${sirikata_core_LDFLAGS})
-ENDIF()
-TARGET_LINK_LIBRARIES(${SIRIKATA_SUBSCRIPTION_LIB} ${SIRIKATA_CORE_LIB} ${PROTOCOLBUFFERS_LIBRARIES})
-
-ADD_LIBRARY(${SIRIKATA_SPACE_LIB} SHARED ${LIBSPACE_SOURCES})
-SET_TARGET_PROPERTIES(${SIRIKATA_SPACE_LIB} PROPERTIES COMPILE_DEFINITIONS SIRIKATA_SPACE_BUILD)
-ADD_DEPENDENCIES(${SIRIKATA_SPACE_LIB} ${SIRIKATA_CORE_LIB} ${SIRIKATA_PROXIMITY_LIB})
-IF(sirikata_core_LDFLAGS)# use the core ldflags--these guys act similarly to core for their respective modules
-  SET_TARGET_PROPERTIES(${SIRIKATA_SPACE_LIB} PROPERTIES LINK_FLAGS ${sirikata_core_LDFLAGS})
-ENDIF()
-TARGET_LINK_LIBRARIES(${SIRIKATA_SPACE_LIB} ${SIRIKATA_CORE_LIB} ${SIRIKATA_PROXIMITY_LIB} ${PROTOCOLBUFFERS_LIBRARIES})
-
-ADD_LIBRARY(${SIRIKATA_OH_LIB} SHARED ${LIBOH_SOURCES})
-SET_TARGET_PROPERTIES(${SIRIKATA_OH_LIB} PROPERTIES COMPILE_DEFINITIONS SIRIKATA_OH_BUILD)
-ADD_DEPENDENCIES(${SIRIKATA_OH_LIB} ${SIRIKATA_CORE_LIB})
-IF(sirikata_core_LDFLAGS)# use the core ldflags--these guys act similarly to core for their respective modules
-  SET_TARGET_PROPERTIES(${SIRIKATA_OH_LIB} PROPERTIES LINK_FLAGS ${sirikata_core_LDFLAGS})
-ENDIF()
-TARGET_LINK_LIBRARIES(${SIRIKATA_OH_LIB} ${SIRIKATA_CORE_LIB} ${PROTOCOLBUFFERS_LIBRARIES})
-
-#plugins
-ADD_PLUGIN_TARGET(skeleton
-                    SOURCES ${LIBCORE_PLUGIN_SKELETON_SOURCES}
-                    TARGET_LDFLAGS ${sirikata_LDFLAGS}
-                    TARGET_LIBRARIES ${SIRIKATA_CORE_LIB})
-
-IF(SQLite3_FOUND)
-ADD_PLUGIN_TARGET(sqlite
-                    SOURCES ${LIBCORE_PLUGIN_SQLITE_SOURCES}
-                    TARGET_LDFLAGS ${sirikata_LDFLAGS}
-                    TARGET_LIBRARIES ${SIRIKATA_CORE_LIB}
-                    LIBRARIES ${SQLite3_LIBRARIES} ${PROTOCOLBUFFERS_LIBRARIES})
-SET(PLUGIN_INSTALL_LIST ${PLUGIN_INSTALL_LIST} sqlite)
-ENDIF()
-
-ADD_PLUGIN_TARGET(tcpsst
-                    SOURCES ${LIBCORE_PLUGIN_TCPSST_SOURCES}
-                    TARGET_LDFLAGS ${sirikata_LDFLAGS}
-                    TARGET_LIBRARIES ${SIRIKATA_CORE_LIB})
-SET(PLUGIN_INSTALL_LIST ${PLUGIN_INSTALL_LIST} tcpsst)
-
-IF(OGRE_FOUND AND sdl_FOUND)
-ADD_PLUGIN_TARGET(ogregraphics
-                    SOURCES ${LIBOH_PLUGIN_OGREGRAPHICS_SOURCES}
-                    TARGET_CXXFLAGS ${OGRE_CFLAGS} ${sdl_CFLAGS} ${AWESOMIUM_CFLAGS}
-                    TARGET_LDFLAGS ${OGRE_LDFLAGS} ${sdl_LDFLAGS} ${AWESOMIUM_LDFLAGS} ${sirikata_LDFLAGS}
-                    TARGET_LIBRARIES ${SIRIKATA_OH_LIB} ${SIRIKATA_CORE_LIB}
-                    LIBRARIES ${OGRE_LIBRARIES} ${sdl_LIBRARIES} ${AWESOMIUM_LIBRARIES}
-                              ${Boost_REGEX_LIBRARY_${UPPERCASE_BUILD_TYPE}}
-                               ${PROTOCOLBUFFERS_LIBRARIES})
-SET(PLUGIN_INSTALL_LIST ${PLUGIN_INSTALL_LIST} ogregraphics)
-ENDIF(OGRE_FOUND AND sdl_FOUND)
-
-
-IF(PROX_FOUND)
-ADD_PLUGIN_TARGET(prox
-                    SOURCES ${LIBPROXIMITY_PLUGIN_PROX_SOURCES}
-                    TARGET_CXXFLAGS ${PROX_CFLAGS}
-                    TARGET_LDFLAGS ${PROX_LDFLAGS} ${sirikata_LDFLAGS}
-                    TARGET_LIBRARIES ${SIRIKATA_PROXIMITY_LIB} ${SIRIKATA_CORE_LIB}
-                    LIBRARIES ${PROX_LIBRARIES} ${PROTOCOLBUFFERS_LIBRARIES})
-SET(PLUGIN_INSTALL_LIST ${PLUGIN_INSTALL_LIST} prox)
-ENDIF(PROX_FOUND)
-
-SET(LIBOH_PLUGIN_BULLETPHYSICS_DIR ${LIBOH_PLUGIN_DIR}/bullet)
-SET(LIBOH_PLUGIN_BULLETPHYSICS_SOURCES
- ${SirikataProtocolDirectory}/Bullet_protobuf.cc
- ${LIBOH_PLUGIN_BULLETPHYSICS_DIR}/BulletSystem.cpp
-    )
-IF(bullet_FOUND)
-ADD_PLUGIN_TARGET(bulletphysics
-                    SOURCES ${LIBOH_PLUGIN_BULLETPHYSICS_SOURCES}
-                    TARGET_CXXFLAGS ${bullet_CFLAGS}
-                    TARGET_LDFLAGS ${bullet_LDFLAGS} ${sirikata_LDFLAGS}
-                    TARGET_LIBRARIES ${SIRIKATA_OH_LIB} ${SIRIKATA_CORE_LIB}
-                    LIBRARIES ${bullet_LIBRARIES})
-SET(PLUGIN_INSTALL_LIST ${PLUGIN_INSTALL_LIST} bulletphysics)
-ENDIF()
-
-
-
-SET(LIBOH_PLUGIN_MONO_DIR ${LIBOH_PLUGIN_DIR}/monoscript)
-SET(LIBOH_PLUGIN_MONO_SOURCES
- ${LIBOH_PLUGIN_MONO_DIR}/MonoArray.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoPlugin.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoSystem.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoClass.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoAssembly.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoContext.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoConvert.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoDelegate.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoDomain.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoException.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoHostedObjectExports.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoIDictionary.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoIList.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoMethodLookupCache.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoObject.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoVWObjectScriptManager.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoVWObjectScript.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoPropertyLookupCache.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoThread.cpp
- ${LIBOH_PLUGIN_MONO_DIR}/MonoUtil.cpp
-    )
-IF(MONO_FOUND)
-ADD_PLUGIN_TARGET(monoscript
-                    SOURCES ${LIBOH_PLUGIN_MONO_SOURCES}
-                    TARGET_CXXFLAGS ${MONO_CFLAGS}
-                    TARGET_LDFLAGS ${MONO_LDFLAGS} ${sirikata_LDFLAGS}
-                    TARGET_LIBRARIES ${SIRIKATA_OH_LIB} ${SIRIKATA_CORE_LIB}
-                    LIBRARIES ${MONO_LIBRARIES})
-SET(PLUGIN_INSTALL_LIST ${PLUGIN_INSTALL_LIST} monoscript)
-ENDIF()
-
-
-#binaries
-ADD_EXECUTABLE(${TEST_BINARY} ${TEST_SOURCES})# EXCLUDE_FROM_ALL
-ADD_EXECUTABLE(${SPACE_BINARY} ${SPACE_SOURCES})
-ADD_EXECUTABLE(${PROXIMITY_BINARY} ${PROXIMITY_SOURCES})
-ADD_EXECUTABLE(${SUBSCRIPTION_BINARY} ${SUBSCRIPTION_SOURCES})
-ADD_EXECUTABLE(${CPPOH_BINARY} ${CPPOH_SOURCES})
-
-ADD_DEPENDENCIES(${TEST_BINARY} ${SIRIKATA_CORE_LIB})
-ADD_DEPENDENCIES(${SPACE_BINARY} ${SIRIKATA_CORE_LIB} ${SIRIKATA_SPACE_LIB})
-ADD_DEPENDENCIES(${PROXIMITY_BINARY} ${SIRIKATA_PROXIMITY_LIB} ${SIRIKATA_CORE_LIB})
-ADD_DEPENDENCIES(${SUBSCRIPTION_BINARY} ${SIRIKATA_SUBSCRIPTION_LIB} ${SIRIKATA_CORE_LIB})
-ADD_DEPENDENCIES(${CPPOH_BINARY} ${SIRIKATA_CORE_LIB} ${SIRIKATA_OH_LIB})
-
-SET_TARGET_PROPERTIES(${SPACE_BINARY} ${PROXIMITY_BINARY} ${SUBSCRIPTION_BINARY} ${CPPOH_BINARY} ${TEST_BINARY}
-                      PROPERTIES
-                      DEBUG_POSTFIX "_d" )
-TARGET_LINK_LIBRARIES(${TEST_BINARY} ${SIRIKATA_CORE_LIB}
-                      ${TEST_LIBRARIES} ${PROTOCOLBUFFERS_LIBRARIES} ${SIRIKATA_PROXIMITY_LIB} ${SIRIKATA_SUBSCRIPTION_LIB})
-TARGET_LINK_LIBRARIES(${SPACE_BINARY} ${SIRIKATA_CORE_LIB} ${SIRIKATA_SPACE_LIB})
-TARGET_LINK_LIBRARIES(${PROXIMITY_BINARY} ${SIRIKATA_CORE_LIB} ${SIRIKATA_PROXIMITY_LIB})
-TARGET_LINK_LIBRARIES(${SUBSCRIPTION_BINARY} ${SUBSCRIPTION_CORE_LIB} ${SIRIKATA_SUBSCRIPTION_LIB})
-SET(CPPOH_LINK_LIBRARIES ${SIRIKATA_CORE_LIB} ${SIRIKATA_OH_LIB})
-IF(OGRE_FOUND AND sdl_FOUND)
-  SET(CPPOH_LINK_LIBRARIES ${CPPOH_LINK_LIBRARIES} ogregraphics)
-ENDIF(OGRE_FOUND AND sdl_FOUND)
-IF(bullet_FOUND)
-  SET(CPPOH_LINK_LIBRARIES ${CPPOH_LINK_LIBRARIES} bulletphysics)
-ENDIF(bullet_FOUND)
-TARGET_LINK_LIBRARIES(${CPPOH_BINARY} ${CPPOH_LINK_LIBRARIES})
-
-IF(sirikata_LDFLAGS)
-  SET_TARGET_PROPERTIES(${TEST_BINARY} PROPERTIES LINK_FLAGS ${sirikata_LDFLAGS})
-  SET_TARGET_PROPERTIES(${SPACE_BINARY} PROPERTIES LINK_FLAGS ${sirikata_LDFLAGS})
-  SET_TARGET_PROPERTIES(${PROXIMITY_BINARY} PROPERTIES LINK_FLAGS ${sirikata_LDFLAGS})
-  SET_TARGET_PROPERTIES(${SUBSCRIPTION_BINARY} PROPERTIES LINK_FLAGS ${sirikata_LDFLAGS})
-  SET_TARGET_PROPERTIES(${CPPOH_BINARY} PROPERTIES LINK_FLAGS ${sirikata_LDFLAGS})
-  SET_TARGET_PROPERTIES(${BINARY_TO_CPP_BINARY} PROPERTIES LINK_FLAGS ${sirikata_LDFLAGS})
-  SET_TARGET_PROPERTIES(${PBJ_BINARY} PROPERTIES LINK_FLAGS ${sirikata_LDFLAGS})
-ENDIF()
-
-
-#precompiled headers
-IF(WIN32)
-  SET_TARGET_PROPERTIES(${SIRIKATA_CORE_LIB} ${TEST_BINARY} PROPERTIES COMPILE_FLAGS "-Ycutil/Standard.hh")
-ENDIF()
-
-
-IF(PYTHON_EXECUTABLE)
-  ADD_CUSTOM_TARGET(SCENEDB ALL
-              DEPENDS ${AdditionalProtoDepends} ${CMAKE_CURRENT_BINARY_DIR}/scene.db
-              COMMENT "Checking ${CMAKE_CURRENT_BINARY_DIR}/scene.db")
-
-  ADD_CUSTOM_COMMAND(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/scene.db
-                     COMMAND ${PYTHON_EXECUTABLE} ${TOP_LEVEL}/csv_converter.py ${TOP_LEVEL}/scenebig.csv ${CMAKE_CURRENT_BINARY_DIR}/scene.db
-                     DEPENDS ${AdditionalProtoDepends}
-                     COMMENT "Making example scene database from  ${CMAKE_CURRENT_BINARY_DIR}/scene.db")
-
-ENDIF()
-
-SET(EXEC_PERMS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_EXECUTE GROUP_READ WORLD_EXECUTE WORLD_READ)
-#installation information
-INSTALL(TARGETS
-          ${PBJ_BINARY}
-          ${SIRIKATA_CORE_LIB}
-          ${SIRIKATA_SPACE_LIB}
-          ${SIRIKATA_PROXIMITY_LIB}
-          ${SIRIKATA_SUBSCRIPTION_LIB}
-          ${SIRIKATA_OH_LIB}
-          ${PROXIMITY_LIB}
-          ${PLUGIN_INSTALL_LIST}
-          ${SPACE_BINARY}
-          ${PROXIMITY_BINARY}
-          ${SUBSCRIPTION_BINARY}
-          ${CPPOH_BINARY}
-        PERMISSIONS ${EXEC_PERMS}
-        RUNTIME
-          DESTINATION bin
-        LIBRARY
-          DESTINATION lib
-        ARCHIVE
-          DESTINATION lib
-)
-
-#install protobufs
-IF(PROTOCOLBUFFERS_ROOT)
-  IF(WIN32)
-    INSTALL(DIRECTORY ${PROTOCOLBUFFERS_ROOT}/bin/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION bin/
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.exe" EXCLUDE)
-  ELSE()
-    INSTALL(DIRECTORY ${PROTOCOLBUFFERS_ROOT}/lib/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION lib/
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.exe" EXCLUDE)
-  ENDIF()
-ENDIF()
-
-
-#install ois
-IF(OIS_ROOT AND FOUND_OIS)
-  IF(WIN32)
-    INSTALL(DIRECTORY ${OIS_ROOT}/bin/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION bin/
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.exe" EXCLUDE)
-  ELSE()
-    INSTALL(DIRECTORY ${OIS_ROOT}/lib/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            PATTERN "*.a" EXCLUDE
-            PATTERN "*.la" EXCLUDE
-            DESTINATION lib/
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.exe" EXCLUDE)
-  ENDIF()
-ENDIF()
-
-
-#install sql
-IF(SQLite3_ROOT)
-  IF(WIN32)
-    INSTALL(DIRECTORY ${SQLite3_ROOT}/lib/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION bin/
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.exe" EXCLUDE
-            PATTERN "*.lib" EXCLUDE)
-  ELSE()
-    INSTALL(DIRECTORY ${SQLite3_ROOT}/lib/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION lib/
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.a" EXCLUDE
-            PATTERN "*.la" EXCLUDE
-            PATTERN "*.exe" EXCLUDE)
-  ENDIF()
-ENDIF()
-
-#install SDL
-IF(sdl_FOUND AND sdl_ROOT)
-  IF(WIN32)
-    INSTALL(DIRECTORY ${sdl_ROOT}/bin/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION bin/
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.exe" EXCLUDE
-            PATTERN "*.lib" EXCLUDE)
-  ELSEIF(APPLE)
-    INSTALL(DIRECTORY ${sdl_ROOT}/lib/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION lib/
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.a" EXCLUDE
-            PATTERN "*.la" EXCLUDE
-            PATTERN "*.exe" EXCLUDE)
-  ELSE()
-    INSTALL(DIRECTORY ${sdl_LIBRARY_DIRS}/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION lib/
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.a" EXCLUDE
-            PATTERN "*.la" EXCLUDE
-            PATTERN "*.exe" EXCLUDE)
-  ENDIF()
-ENDIF()
-
-IF(bullet_FOUND AND bullet_ROOT)
-  IF(WIN32)
-    INSTALL(DIRECTORY ${bullet_ROOT}/bin/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION bin/
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.exe" EXCLUDE)
-  ELSE()
-    INSTALL(DIRECTORY ${bullet_ROOT}/lib/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION lib/
-            PATTERN "*.a" EXCLUDE
-            PATTERN "*.la" EXCLUDE
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.exe" EXCLUDE)
-  ENDIF()
-ENDIF()
-
-IF(OGRE_FOUND)
-  IF(WIN32)
-    INSTALL(DIRECTORY ${OGRE_ROOT}/bin/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION bin/
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.exe" EXCLUDE)
-  ELSE()
-    FOREACH(OGRE_LIBRARY_DIR ${OGRE_LIBRARY_DIRS})
-      INSTALL(DIRECTORY ${OGRE_LIBRARY_DIR}/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION lib/
-            #PATTERN "*.so"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.la" EXCLUDE
-            PATTERN "*.a" EXCLUDE
-            PATTERN "*.me" EXCLUDE
-            PATTERN "*.h" EXCLUDE
-            )
-     ENDFOREACH()
-
-  ENDIF()
-  IF(AWESOMIUM_ROOT)
-    IF(WIN32)
-      INSTALL(DIRECTORY ${AWESOMIUM_ROOT}/
-              FILE_PERMISSIONS ${EXEC_PERMS}
-              DESTINATION bin/
-              PATTERN "*.a" EXCLUDE
-              PATTERN "*.la" EXCLUDE
-	      PATTERN "*.h" EXCLUDE
-	      PATTERN "*.lib" EXCLUDE
-              #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-              PATTERN "*.exe" EXCLUDE)
-    ELSE()
-      INSTALL(DIRECTORY ${AWESOMIUM_ROOT}/lib/
-              FILE_PERMISSIONS ${EXEC_PERMS}
-              DESTINATION lib/
-              #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.exe" EXCLUDE)
-    ENDIF()
-  ENDIF()
-ENDIF()
-
-#install boost
-IF(BOOST_ROOT)
-  IF(WIN32)
-    FOREACH(Boost_LIBRARY_DIR ${PLATFORM_LIBS}/boost_1_35_0/lib ${PLATFORM_LIBS}/boost_1_37_0/lib ${PLATFORM_LIBS}installed-boost/lib)
-      IF(EXISTS ${Boost_LIBRARY_DIR})
-      INSTALL(DIRECTORY ${Boost_LIBRARY_DIR}/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION bin/
-            #PATTERN "*.so"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.la" EXCLUDE
-            PATTERN "*.a" EXCLUDE
-            PATTERN "*.me" EXCLUDE
-            PATTERN "*.hpp" EXCLUDE
-	    PATTERN "*.lib" EXCLUDE
-            PATTERN "*wave-vc90-mt-1_37.dll" EXCLUDE
-            PATTERN "*wave-vc90-mt-gd-1_37.dll" EXCLUDE
-            PATTERN "*wave-vc80-mt-1_35.dll" EXCLUDE
-            PATTERN "*wave-vc80-mt-gd-1_35.dll" EXCLUDE
-            )
-     ENDIF()
-     ENDFOREACH()
-  ELSE()
-    INSTALL(DIRECTORY ${BOOST_ROOT}/lib/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION lib/
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.exe" EXCLUDE)
-  ENDIF()
-ENDIF()
-
-IF(MONO_FOUND)
-  INSTALL(PROGRAMS
-          ${SirikataScriptRuntime}
-        DESTINATION lib/)
-  INSTALL(PROGRAMS
-        ${SirikataScriptRuntime_LIBRARY}
-        DESTINATION lib/)
-
-  IF(PROTOCOLBUFFERS_SUPPORTS_CSHARP)
-    INSTALL(PROGRAMS
-              ${SirikataScriptProtocol}
-            DESTINATION lib/)
-    INSTALL(PROGRAMS
-              ${SirikataProtoScriptRuntime_LIBRARY}
-            DESTINATION lib/)
-  ENDIF()
-
-  INSTALL(DIRECTORY
-          ${IRON_PYTHON_ROOT}/
-          FILE_PERMISSIONS ${EXEC_PERMS}
-          DESTINATION lib/)
-  IF(MONO_ROOT)
-    INSTALL(PROGRAMS
-        ${MONO_ROOT}/lib/mono/2.0/System.Xml.dll
-        DESTINATION lib/)
-    INSTALL(DIRECTORY
-          ${MONO_ROOT}/lib/
-          FILE_PERMISSIONS ${EXEC_PERMS}
-          DESTINATION lib/
-          #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-	  PATTERN "*zlib1.dll" EXCLUDE
-          PATTERN "*.xsd" EXCLUDE
-          PATTERN "*.config" EXCLUDE
-          PATTERN "*.rsp" EXCLUDE
-          PATTERN "*.targets" EXCLUDE
-          PATTERN "*.zip" EXCLUDE
-          PATTERN "*.cs" EXCLUDE
-          PATTERN "*.tree" EXCLUDE
-          PATTERN "*.mdb" EXCLUDE
-          PATTERN "*.exe" EXCLUDE
-          PATTERN "*.la" EXCLUDE
-          PATTERN "*.a" EXCLUDE
-          PATTERN "*.xml*" EXCLUDE
-#         PATTERN "*.pc" EXCLUDE
-#          PATTERN "*.so*" EXCLUDE
-          PERMISSIONS ${EXEC_PERMS})
-  ENDIF()
-  IF(WIN32)
-    INSTALL(DIRECTORY ${MONO_ROOT}/bin/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION bin/
-  	    PATTERN "*zlib1.dll" EXCLUDE
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.exe" EXCLUDE)
-  ENDIF()
-ENDIF()
-
-#install curl #MUST BE DONE AFTER MONO to get correct libz
-IF(CURL_ROOT)
-  IF(WIN32)
-    INSTALL(DIRECTORY ${CURL_ROOT}/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION bin/
-            PATTERN "*.lib" EXCLUDE
-            PATTERN "*README" EXCLUDE
-            PATTERN "*COPYING" EXCLUDE
-            PATTERN "*Makefile" EXCLUDE
-            PATTERN "*.am" EXCLUDE
-            PATTERN "*.in" EXCLUDE
-            PATTERN "*CHANGES" EXCLUDE
-            PATTERN "*.exp" EXCLUDE
-            PATTERN "*.h" EXCLUDE
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.exe" EXCLUDE)
-  ELSE()
-    INSTALL(DIRECTORY ${CURL_ROOT}/lib/
-            FILE_PERMISSIONS ${EXEC_PERMS}
-            DESTINATION lib/
-            #PATTERN "*.dll"<-- if only we could just INCLUDE a pattern
-            PATTERN "*.exe" EXCLUDE)
-  ENDIF()
-ENDIF()
-
-INSTALL(DIRECTORY
-          # note: the trailing slashes avoid prepending the directory name
-          # itself to the installed files
-          ${LIBCORE_SOURCE_DIR}/
-          ${LIBSPACE_INCLUDE_DIR}/
-          ${LIBPROXIMITY_INCLUDE_DIR}/
-          ${LIBSUBSCRIPTION_INCLUDE_DIR}/
-          ${LIBOH_INCLUDE_DIR}/
-        DESTINATION include/sirikata
-        PATTERN "*.cpp" EXCLUDE
-        PATTERN "*.cc" EXCLUDE
-        PATTERN "*.hh" EXCLUDE
-)
-
-
-INSTALL(DIRECTORY
-          # note: the trailing slashes avoid prepending the directory name
-          # itself to the installed files
-          ${ScriptsRoot}
-        DESTINATION lib/
-        PATTERN "*.cs" EXCLUDE
-        PATTERN "*.pyc" EXCLUDE)
-
-# get the name of the binaries for running tests
-IF(WIN32)
-  GET_TARGET_PROPERTY(TEST_RUNABLE ${TEST_BINARY} LOCATION)
-ELSE()
-  IF(ISDEBUG)
-#some CRAZY bug with cmake-2.4 does not bake the _d into LOCATION
-    GET_TARGET_PROPERTY(TEST_RUNABLE ${TEST_BINARY} DEBUG_LOCATION)
-  ELSE()
-    GET_TARGET_PROPERTY(TEST_RUNABLE ${TEST_BINARY} LOCATION)
-  ENDIF()
-ENDIF()
-
-
-
-INSTALL(FILES ${TOP_LEVEL}/cdn.txt
-        DESTINATION bin/)
-IF(PYTHON_EXECUTABLE)
-  INSTALL(FILES ${CMAKE_CURRENT_BINARY_DIR}/scene.db
-          DESTINATION bin/
-          OPTIONAL )
-ENDIF()
-
-ADD_CUSTOM_TARGET(test
-  DEPENDS tests
-  COMMAND ${TEST_RUNABLE})
diff --git a/build/cmake/camera_path.csv b/build/cmake/camera_path.csv
deleted file mode 100644
index b79f1cc..0000000
--- a/build/cmake/camera_path.csv
+++ /dev/null
@@ -1,42 +0,0 @@
-"pos_x","pos_y","pos_z","rot_x","rot_y","rot_z","rot_w","delay","text"
--71.64,26.35,60.24,-0.13,-0.37,-0.05,0.92,1,"Bornholm_Guided_Tour!"
--70.64,25.93,59.21,-0.13,-0.37,-0.05,0.92,1,
--68.95,25.22,57.48,-0.13,-0.37,-0.05,0.92,1,
--67.31,24.53,55.79,-0.13,-0.37,-0.05,0.92,1,"Stopping_point"
--65.78,23.88,54.22,-0.13,-0.37,-0.05,0.92,1,
--64.14,23.19,52.53,-0.13,-0.37,-0.05,0.92,1,
--37.52,12,25.18,-0.13,-0.37,-0.05,0.92,1,
--37.52,12,25.18,-0.13,-0.37,-0.05,0.92,1,"Visitor's_Lounge"
--37.52,12,25.18,-0.13,-0.37,-0.05,0.92,1,
--23.32,2.93,22.73,-0.06,-0.08,0,0.99,1,
--23.83,0.05,10.2,-0.06,-0.08,0,0.99,1,
--23.43,0.15,1.76,0.01,-0.08,0,1,1,
--23.53,-0.11,-1.94,0.14,-0.07,0.01,0.99,1,"Gallery1"
--19.02,0.55,-7.35,0.03,-0.67,0.02,0.74,1,
--11.83,1.09,-8.13,0.03,-0.67,0.02,0.74,1,
--11.73,-0.23,-8.14,0.03,-0.67,0.02,0.74,1,
--11.59,-2.11,-8.16,0.03,-0.67,0.02,0.74,1,"Gallery2"
--11.58,-2.33,-8.16,0.03,-0.67,0.02,0.74,1,
--11.56,-2.54,-8.16,0.03,-0.67,0.02,0.74,1,
--11.54,-2.75,-8.16,0.03,-0.67,0.02,0.74,1,
--11.53,-2.97,-8.16,0.03,-0.67,0.02,0.74,1,
--11.51,-3.2,-8.17,0.03,-0.67,0.02,0.74,1,
--11.51,-3.2,-8.17,0.03,-0.73,0.03,0.69,1,
--11.51,-3.2,-8.17,0.02,-0.76,0.03,0.64,1,
--11.51,-3.2,-8.17,0.02,-0.82,0.03,0.57,1,"Observation_Deck"
--10.95,-3.16,-7.96,0.02,-0.82,0.03,0.57,1,
--8.66,-2.98,-7.14,0.02,-0.82,0.03,0.57,1,
--6.42,-3.28,-6.33,-0.03,-0.82,-0.04,0.57,1,
--6.52,-3.28,-6.07,-0.03,-0.82,-0.04,0.57,1,
--3.62,-3.59,-5.03,-0.03,-0.82,-0.04,0.57,1,
--1.95,-3.77,-4.42,-0.03,-0.82,-0.04,0.57,1,
--1.12,-3.07,-4.13,-0.03,-0.82,-0.04,0.57,1,"FLY-AWAY"
--1.05,-2.32,-4.1,-0.03,-0.82,-0.04,0.57,1,
--0.97,-1.44,-4.07,-0.03,-0.82,-0.04,0.57,1,
-3.32,-1.89,-2.53,-0.03,-0.78,-0.04,0.63,1,
-8.77,-2.45,-1.35,-0.03,-0.78,-0.04,0.63,1,
-11,-2.68,-0.87,-0.03,-0.8,-0.04,0.6,1,
-11.72,-2.75,-0.72,-0.03,-0.8,-0.04,0.6,1,
-14.35,-3.03,0.16,-0.03,-0.83,-0.04,0.55,1,
-17.22,-3.34,1.37,0.01,-0.83,0.01,0.55,1,"Thank.You"
-17.22,-3.34,1.37,0.01,-0.77,0.01,0.63,1,
diff --git a/cppoh/src/main.cpp b/cppoh/src/main.cpp
deleted file mode 100644
index 49b6892..0000000
--- a/cppoh/src/main.cpp
+++ /dev/null
@@ -1,316 +0,0 @@
-/*  Sirikata
- *  main.cpp
- *
- *  Copyright (c) 2008, Daniel Reiter Horn
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are
- *  met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name of Sirikata nor the names of its contributors may
- *    be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <oh/Platform.hpp>
-#include <util/RoutableMessageHeader.hpp>
-#include <options/Options.hpp>
-#include <util/PluginManager.hpp>
-#include <oh/SimulationFactory.hpp>
-
-#include <task/EventManager.hpp>
-#include <task/WorkQueue.hpp>
-#include "CDNConfig.hpp"
-
-#include <oh/ObjectHost.hpp>
-#include <oh/LightInfo.hpp>
-#include <oh/TopLevelSpaceConnection.hpp>
-#include <oh/SpaceConnection.hpp>
-#include <oh/HostedObject.hpp>
-#include <oh/SpaceIDMap.hpp>
-#include <network/IOServiceFactory.hpp>
-#include <util/KnownServices.hpp>
-#include <persistence/ObjectStorage.hpp>
-#include <persistence/ReadWriteHandlerFactory.hpp>
-#include <ObjectHostBinary_Persistence.pbj.hpp>
-#include <ObjectHostBinary_Sirikata.pbj.hpp>
-#include <time.h>
-namespace Sirikata {
-
-using Task::GenEventManager;
-using Transfer::TransferManager;
-
-OptionValue *cdnConfigFile;
-OptionValue *floatExcept;
-OptionValue *dbFile;
-OptionValue *host;
-InitializeGlobalOptions main_options("",
-//    simulationPlugins=new OptionValue("simulationPlugins","ogregraphics",OptionValueType<String>(),"List of plugins that handle simulation."),
-    cdnConfigFile=new OptionValue("cdnConfig","cdn = ($import=cdn.txt)",OptionValueType<String>(),"CDN configuration."),
-    floatExcept=new OptionValue("sigfpe","false",OptionValueType<bool>(),"Enable floating point exceptions"),
-    dbFile=new OptionValue("db","scene.db",OptionValueType<String>(),"Persistence database"),
-    host=new OptionValue("host","localhost",OptionValueType<String>(),"space address"),
-    NULL
-);
-
-class UUIDLister : public MessageService {
-    ObjectHost *mObjectHost;
-    SpaceID mSpace;
-    MessagePort mPort;
-    volatile bool mSuccess;
-
-public:
-    UUIDLister(ObjectHost*oh, const SpaceID &space)
-        : mObjectHost(oh), mSpace(space), mPort(Services::REGISTRATION) {
-        mObjectHost->registerService(mPort, this);
-    }
-    ~UUIDLister() {
-        mObjectHost->unregisterService(mPort);
-    }
-    bool forwardMessagesTo(MessageService *other) {
-        return false;
-    }
-    bool endForwardingMessagesTo(MessageService *other) {
-        return false;
-    }
-    void processMessage(const RoutableMessageHeader &hdr, MemoryReference body) {
-        Persistence::Protocol::Response resp;
-        resp.ParseFromArray(body.data(), body.length());
-        if (hdr.has_return_status() || resp.has_return_status()) {
-            SILOG(cppoh,info,"Failed to connect to database: "<<hdr.has_return_status()<<", "<<resp.has_return_status());
-            mSuccess = true;
-            return;
-        }
-        Protocol::UUIDListProperty uuidList;
-        if (resp.reads(0).has_return_status()) {
-            SILOG(cppoh,info,"Failed to find ObjectList in database.");
-            mSuccess = true;
-            return;
-        }
-        uuidList.ParseFromString(resp.reads(0).data());
-        for (int i = 0; i < uuidList.value_size(); i++) {
-            SILOG(cppoh,info,"Loading object "<<ObjectReference(uuidList.value(i)));
-            HostedObjectPtr obj = HostedObject::construct<HostedObject>(mObjectHost, uuidList.value(i));
-            obj->initializeRestoreFromDatabase(mSpace, HostedObjectPtr());
-        }
-        mSuccess = true;
-    }
-    void go() {
-        mSuccess = false;
-        Persistence::Protocol::ReadWriteSet rws;
-        Persistence::Protocol::IStorageElement el = rws.add_reads();
-        el.set_field_name("ObjectList");
-//        el.set_object_uuid(UUID::null());
-//        el.set_field_id(0);
-        RoutableMessageHeader hdr;
-        hdr.set_source_object(ObjectReference::spaceServiceID());
-        hdr.set_source_port(mPort);
-        hdr.set_destination_port(Services::PERSISTENCE);
-        hdr.set_destination_object(ObjectReference::spaceServiceID());
-        std::string body;
-        rws.SerializeToString(&body);
-        mObjectHost->processMessage(hdr, MemoryReference(body));
-    }
-    void goWait(Network::IOService *ioServ, Task::WorkQueue *queue) {
-        mSuccess = false;
-        go();
-        while (!mSuccess) {
-            // needs to happen in one thread for now...
-            queue->dequeuePoll();
-            //Network::IOServiceFactory::pollService(ioServ); // kills ioservice if there's nothing to be processed...
-        }
-    }
-};
-
-}
-
-#ifdef __GNUC__
-#include <fenv.h>
-#endif
-
-int main ( int argc,const char**argv ) {
-
-    int myargc = argc+2;
-    const char **myargv = new const char*[myargc];
-    memcpy(myargv, argv, argc*sizeof(const char*));
-    myargv[argc] = "--moduleloglevel";
-    myargv[argc+1] = "transfer=fatal,ogre=fatal,task=fatal,resource=fatal";
-
-    using namespace Sirikata;
-
-    PluginManager plugins;
-    const char* pluginNames[] = { "tcpsst", "monoscript", "sqlite", "ogregraphics", "bulletphysics", NULL};
-    for(const char** plugin_name = pluginNames; *plugin_name != NULL; plugin_name++)
-        plugins.load( DynamicLibrary::filename(*plugin_name) );
-
-    OptionSet::getOptions ( "" )->parse ( myargc,myargv );
-
-#ifdef __GNUC__
-#ifndef __APPLE__
-    if (floatExcept->as<bool>()) {
-        feenableexcept(FE_DIVBYZERO|FE_INVALID|FE_OVERFLOW|FE_UNDERFLOW);
-    }
-#endif
-#endif
-
-    OptionMapPtr transferOptions (new OptionMap);
-    {
-        std::string contents(cdnConfigFile->as<String>());
-        std::string::size_type pos(0);
-        parseConfig(contents, transferOptions, transferOptions, pos);
-        std::cout << *transferOptions;
-    }
-
-    initializeProtocols();
-
-    Network::IOService *ioServ = Network::IOServiceFactory::makeIOService();
-    Task::WorkQueue *workQueue = new Task::LockFreeWorkQueue;
-    Task::GenEventManager *eventManager = new Task::GenEventManager(workQueue);
-
-    SpaceID mainSpace(UUID("12345678-1111-1111-1111-DEFA01759ACE",UUID::HumanReadable()));
-    SpaceIDMap *spaceMap = new SpaceIDMap;
-    spaceMap->insert(mainSpace, Network::Address(host->as<String>(),"5943"));
-    String localDbFile=dbFile->as<String>();
-    if (localDbFile.length()&&localDbFile[0]!='/'&&localDbFile[0]!='\\') {
-        FILE * fp=fopen(localDbFile.c_str(),"rb");
-        for (int i=0;i<4&&fp==NULL;++i) {
-            localDbFile="../"+localDbFile;
-            fp=fopen(localDbFile.c_str(),"rb");
-        }
-        if (fp) fclose(fp);
-        else localDbFile=dbFile->as<String>();
-    }
-    Persistence::ReadWriteHandler *database=Persistence::ReadWriteHandlerFactory::getSingleton()
-        .getConstructor("sqlite")(String("--databasefile ")+localDbFile);
-
-    ObjectHost *oh = new ObjectHost(spaceMap, workQueue, ioServ);
-    oh->registerService(Services::PERSISTENCE, database);
-
-    {
-        UUIDLister lister(oh, mainSpace);
-        lister.goWait(ioServ, workQueue);
-    }
-
-    ProxyManager *provider = oh->getProxyManager(mainSpace);
-    if (!provider) {
-        SILOG(cppoh,error,String("Unable to load database in ") + String(dbFile->as<String>()));
-        std::cout << "Press enter to continue" << std::endl;
-        std::cerr << "Press enter to continue" << std::endl;
-        fgetc(stdin);
-        return 1;
-    }
-
-    TransferManager *tm;
-    try {
-        tm = initializeTransferManager((*transferOptions)["cdn"], eventManager);
-    } catch (OptionDoesNotExist &err) {
-        SILOG(input,fatal,"Fatal Error: Failed to load CDN config: " << err.what());
-        std::cout << "Press enter to continue" << std::endl;
-        std::cerr << "Press enter to continue" << std::endl;
-        fgetc(stdin);
-        return 1;
-    }
-    OptionSet::getOptions("")->parse(myargc,myargv);
-
-    String graphicsCommandArguments;
-    {
-        std::ostringstream os;
-        os << "--transfermanager=" << tm << " ";
-        os << "--eventmanager=" << eventManager << " ";
-        os << "--workqueue=" << workQueue << " ";
-        graphicsCommandArguments = os.str();
-    }
-    if (!provider) {
-        SILOG(cppoh,error,"Failed to get TopLevelSpaceConnection for main space "<<mainSpace);
-    }
-
-    bool continue_simulation = true;
-
-    typedef std::vector<TimeSteppedSimulation*> SimList;
-    SimList sims;
-
-    struct SimulationRequest {
-        const char* name;
-        bool required;
-    };
-    const uint32 nSimRequests = 2;
-    SimulationRequest simRequests[nSimRequests] = {
-        {"ogregraphics", true},
-        {"bulletphysics", false}
-    };
-    for(uint32 ir = 0; ir < nSimRequests && continue_simulation; ir++) {
-        String simName = simRequests[ir].name;
-        SILOG(cppoh,info,String("Initializing ") + simName);
-        TimeSteppedSimulation *sim =
-            SimulationFactory::getSingleton()
-            .getConstructor ( simName ) ( provider,graphicsCommandArguments );
-        if (!sim) {
-            if (simRequests[ir].required) {
-                SILOG(cppoh,error,String("Unable to load ") + simName + String(" plugin. The PATH environment variable is ignored, so make sure you have copied the DLLs from dependencies/ogre/bin/ into the current directory. Sorry about this!"));
-                std::cout << "Press enter to continue" << std::endl;
-                std::cerr << "Press enter to continue" << std::endl;
-                fgetc(stdin);
-                continue_simulation = false;
-            }
-            else {
-                SILOG(cppoh,info,String("Couldn't load ") + simName + String(" plugin."));
-            }
-        }
-        else {
-            SILOG(cppoh,info,String("Successfully initialized ") + simName);
-            sims.push_back(sim);
-			sim->forwardMessagesTo(oh);
-        }
-    }
-    while ( continue_simulation ) {
-	usleep(30000);
-        for(SimList::iterator it = sims.begin(); it != sims.end(); it++) {
-            continue_simulation = continue_simulation && (*it)->tick();
-        }
-        oh->tick();
-        Network::IOServiceFactory::pollService(ioServ);
-    }
-	for(SimList::iterator it = sims.begin(); it != sims.end(); it++) {
-		(*it)->endForwardingMessagesTo(oh);
-	}
-    delete oh;
-
-    // delete after OH in case objects want to do last-minute state flushes
-    delete database;
-
-    destroyTransferManager(tm);
-    delete eventManager;
-    delete workQueue;
-
-    for(SimList::reverse_iterator it = sims.rbegin(); it != sims.rend(); it++) {
-        delete *it;
-    }
-    sims.clear();
-    plugins.gc();
-    SimulationFactory::destroy();
-
-    Network::IOServiceFactory::destroyIOService(ioServ);
-    delete spaceMap;
-
-    delete []myargv;
-
-    return 0;
-}
diff --git a/csv_converter.py b/csv_converter.py
deleted file mode 100644
index fdef1cd..0000000
--- a/csv_converter.py
+++ /dev/null
@@ -1,311 +0,0 @@
-""" csv_converter -- utility for converting csv to sqlite """
-"""  Sirikata utility scripts
- *  csv_converter.py
- *
- *  Copyright (c) 2009, Patrick Reiter Horn
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are
- *  met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name of Sirikata nor the names of its contributors may
- *    be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-"""
-import sys
-noisy=False
-try:
-    try:
-        import sqlite3
-    except:
-        from pysqlite2 import dbapi2 as sqlite3
-    import os
-    import csv
-    import math
-    import random
-    import time
-    import uuid
-    from urllib import unquote_plus
-except:
-    print "Missing library: ", sys.exc_info()[0],", not generating scene.db" 
-    sys.exit(0);
-basepath=''
-if len(sys.argv):
-    where1=sys.argv[0].rfind("/")
-    where2=sys.argv[0].rfind("\\")
-    if where1!=-1:
-        if where2!=-1 and where2>where1:
-            where1=where2
-    else:
-        where1=where2
-    if where1!=-1:
-        basepath=sys.argv[0][0:where1]+'/'
-    
-sys.path.append(basepath+'liboh/scripts/ironpython')
-sys.path.append(basepath+'liboh/scripts/ironpython/site-packages')
-
-from protocol import Sirikata_pb2 as Sirikata
-from protocol import Persistence_pb2 as Persistence
-from protocol.MessageHeader_pb2 import Header
-
-PHYSICAL_MODES = {
-    'graphiconly': Sirikata.PhysicalParameters.NONPHYSICAL,
-    'staticmesh': Sirikata.PhysicalParameters.STATIC,
-#    'dynamicmesh': Sirikata.PhysicalParameters.DYNAMIC,
-    'dynamicbox': Sirikata.PhysicalParameters.DYNAMICBOX,
-    'dynamicsphere': Sirikata.PhysicalParameters.DYNAMICSPHERE,
-    'dynamiccylinder': Sirikata.PhysicalParameters.DYNAMICCYLINDER,
-    'character': Sirikata.PhysicalParameters.CHARACTER,
-    '': Sirikata.PhysicalParameters.NONPHYSICAL
-}
-
-LIGHT_TYPES = {
-    'point': Sirikata.LightInfoProperty.POINT,
-    'spotlight': Sirikata.LightInfoProperty.SPOTLIGHT,
-    'directional': Sirikata.LightInfoProperty.DIRECTIONAL,
-    '': Sirikata.LightInfoProperty.POINT
-}
-
-ALLOWED_TYPES = {'mesh':1, 'camera':1, 'light':1}
-
-def randomUUID():
-    return uuid.uuid4()
-
-def veclen(fltarray):
-    return (fltarray[0]*fltarray[0] +
-            fltarray[1]*fltarray[1] +
-            fltarray[2]*fltarray[2])
-
-class CsvToSql:
-    def __init__(self, conn):
-        self.conn = conn
-        self.name_to_uuid = {}
-        self.uuid_objects = {}
-        self.table_name = 'persistence'
-
-    def getTableName(self, uuid):
-        return uuid.get_bytes()
-
-    def getKeyName(self, name, index=0):
-        return "%s_%d" % (name, index)
-
-    def getUUID(self, name):
-        if not name:
-            return randomUUID()
-        if name not in self.name_to_uuid:
-            self.name_to_uuid[name] = randomUUID()
-        return self.name_to_uuid[name]
-
-    def addUUID(self, row):
-        myid = self.getUUID(row['name'])
-        if myid in self.uuid_objects:
-            myid = randomUUID()
-        self.uuid_objects[myid] = row
-        return myid
-
-    def addTable(self, curs):
-        table_create = "CREATE TABLE IF NOT EXISTS ";
-        table_create += "\""+self.table_name+"\"";
-        table_create += "(object TEXT, key TEXT, value TEXT, PRIMARY KEY(object, key))"
-        curs.execute(table_create)
-
-    def protovec(self, listval, csvrow, fieldname):
-        listval.append(float(csvrow[fieldname+'_x']))
-        listval.append(float(csvrow[fieldname+'_y']))
-        listval.append(float(csvrow[fieldname+'_z']))
-
-    def set(self, curs, uuid, key, value, which=0):
-        object_name = self.getTableName(uuid)
-        key_name = self.getKeyName(key, which)
-        table_insert = "INSERT INTO \"" + self.table_name + "\""
-        table_insert += " VALUES (?, ?, ?)"
-        value = "".join(chr(c) for c in value);
-        curs.execute(table_insert, (buffer(object_name), key_name, buffer(value)))
-
-    def go(self, openfile, **csvargs):
-        cursor = self.conn.cursor()
-        self.addTable(cursor)
-
-        uuidlist = Sirikata.UUIDListProperty()
-
-        reader = csv.DictReader(openfile, **csvargs)
-        for row in reader:
-            try:
-                if row['objtype'] not in ALLOWED_TYPES:
-                    continue # blank or bad row
-
-                u = self.addUUID(row)
-                self.processRow(u, row, cursor)
-                uuidlist.value.append(u.get_bytes())
-            except:
-                print row
-                raise
-        nulluuid = uuid.UUID(int=0)
-        self.set(cursor, nulluuid, 'ObjectList', uuidlist.SerializeToString())
-        self.conn.commit()
-        cursor.close()
-
-    def processRow(self, uuid, row, cursor):
-        location = Sirikata.ObjLoc()
-        self.protovec(location.position, row, 'pos')
-        if (row['orient_w']):
-            self.protovec(location.orientation, row, 'orient')
-        else:
-            # Convert from angle
-            phi = float(row['orient_x'])*math.pi/180.
-            theta = float(row['orient_y'])*math.pi/180.
-            psi = float(row['orient_z'])*math.pi/180.
-            location.orientation.append(math.sin(phi/2)*math.cos(theta/2)*math.cos(psi/2)
-                                      + math.cos(phi/2)*math.sin(theta/2)*math.sin(psi/2)) #x
-            location.orientation.append(math.cos(phi/2)*math.sin(theta/2)*math.cos(psi/2)
-                                      + math.sin(phi/2)*math.cos(theta/2)*math.sin(psi/2)) #y
-            location.orientation.append(math.cos(phi/2)*math.cos(theta/2)*math.sin(psi/2)
-                                      + math.sin(phi/2)*math.sin(theta/2)*math.cos(psi/2)) #z
-            # w is not stored to save space, since quaternions are normalized
-            #location.orientation.append(math.cos(phi/2)*math.cos(theta/2)*math.cos(psi/2)
-            #                          + math.sin(phi/2)*math.sin(theta/2)*math.sin(psi/2)) #w
-        if row.get('vel_x',''):
-            self.protovec(location.velocity, row, 'vel')
-        if row.get('rot_axis_x',''):
-            self.protovec(location.rotational_axis, row, 'rot_axis')
-        if row.get('rot_speed',''):
-            location.angular_speed = float(row['rot_speed'])
-        self.set(cursor, uuid, 'Loc', location.SerializeToString())
-
-        if row.get('script',''):
-            scrprop = Sirikata.StringProperty()
-            scrprop.value = row['script']
-            self.set(cursor, uuid, '_Script', scrprop.SerializeToString())
-            if noisy:
-                print row['script']
-            scrprop = Sirikata.StringMapProperty()
-            for kv in row['scriptparams'].split('&'):
-                key, value = kv.split('=',1)
-                scrprop.keys.append(unquote_plus(key))
-                scrprop.values.append(unquote_plus(value))
-                if noisy:
-                    print 'param',key,'=',value
-            self.set(cursor, uuid, '_ScriptParams', scrprop.SerializeToString())
-
-        if row.get('parent',''):
-            parentprop = Sirikata.ParentProperty()
-            parentprop.value = self.getUUID(row['parent']).get_bytes()
-            self.set(cursor, uuid, 'Parent', parentprop.SerializeToString())
-        if row['objtype']=='mesh':
-            scale = Sirikata.Vector3fProperty()
-            self.protovec(scale.value, row, 'scale')
-            self.set(cursor, uuid, 'MeshScale', scale.SerializeToString())
-            physical = Sirikata.PhysicalParameters()
-            physical.mode = PHYSICAL_MODES['']
-            if row.get('subtype',''):
-                physical.mode = PHYSICAL_MODES[row['subtype']]
-            if physical.mode != PHYSICAL_MODES['']:
-                physical.density = float(row['density'])
-                physical.friction = float(row['friction'])
-                physical.bounce = float(row['bounce'])
-                physical.collide_mask = int(row['colMask'])
-                physical.collide_msg = int(row['colMsg'])
-                if "gravity" in row:
-                    if not row['gravity'] == "":
-                        physical.gravity = float(row['gravity'])
-                    else:
-                        physical.gravity = 1.0
-                else:
-                    physical.gravity = 1.0
-                if row.get('hull_x',''):
-                    self.protovec(physical.hull, row, 'hull')
-                self.set(cursor, uuid, 'PhysicalParameters', physical.SerializeToString())
-            meshuri = Sirikata.StringProperty()
-            meshuri.value = row['meshURI']
-            self.set(cursor, uuid, 'MeshURI', meshuri.SerializeToString())
-            if (row.get('name','')):
-                meshuri = Sirikata.StringProperty()
-                meshuri.value = row['name']
-                self.set(cursor, uuid, 'Name', meshuri.SerializeToString())
-            if noisy:
-                print "** Adding a Mesh ",uuid,"named",row.get('name',''),"with",row['meshURI']
-        elif row['objtype']=='light':
-            if noisy:
-                print "** Adding a Light ",uuid
-            lightinfo = Sirikata.LightInfoProperty()
-            self.protovec(lightinfo.diffuse_color, row, 'diffuse')
-            self.protovec(lightinfo.specular_color, row, 'specular')
-            lightinfo.power = float(row['power'])
-            if row.get('ambient_x',''):
-                self.protovec(lightinfo.ambient_color, row, 'ambient')
-            elif row.get('ambient',''):
-                ambientPower = float(row['ambient'])
-                diffuseColorLength = veclen(lightinfo.diffuse_color)
-                for i in range(3):
-                    if diffuseColorLength:
-                        lightinfo.ambient_color.append(lightinfo.diffuse_color[i]*
-                                                       (ambientPower/diffuseColorLength)/lightinfo.power)
-                    else:
-                        lightinfo.ambient_color.append(0.0)
-            if row.get('shadow_x',''):
-                self.protovec(lightinfo.shadow_color, row, 'shadow')
-            elif row.get('shadowpower',''):
-                shadowPower = float(row['shadowpower'])
-                specularColorLength = veclen(lightinfo.specular_color)
-                for i in range(3):
-                    if specularColorLength:
-                        lightinfo.shadow_color.append(lightinfo.specular_color[i]*(shadowPower/specularColorLength)/lightinfo.power)
-                    else:
-                        lightinfo.shadow_color.append(0.0)
-            lightinfo.light_range = float(row['range'])
-            if 'constantfall' in row:
-                lightinfo.constant_falloff = float(row['constantfall'])
-            elif 'constfall' in row:
-                lightinfo.constant_falloff = float(row['constfall'])
-            lightinfo.linear_falloff = float(row['linearfall'])
-            lightinfo.quadratic_falloff = float(row['quadfall'])
-            lightinfo.cone_inner_radians = float(row['cone_in'])
-            lightinfo.cone_outer_radians = float(row['cone_out'])
-            lightinfo.cone_falloff = float(row['cone_fall'])
-            lightinfo.casts_shadow = bool(row['shadow'])
-            if noisy:
-                print lightinfo
-            self.set(cursor, uuid, 'LightInfo', lightinfo.SerializeToString())
-        elif row['objtype']=='camera':
-            if noisy:
-                print "** Adding a Camera ",uuid
-            self.set(cursor, uuid, 'IsCamera', '')
-
-if __name__=='__main__':
-    if len(sys.argv) > 1:
-        csvfile = sys.argv[1]
-    else:
-        csvfile = 'scene.csv'
-    if len(sys.argv) > 2:
-        sqlfile = sys.argv[2]
-    else:
-        sqlfile = 'scene.db'
-    if len(sys.argv) > 3:
-        noisy=True
-    try:
-        os.rename(sqlfile, sqlfile+'.bak')
-    except OSError:
-        pass
-
-    conn = sqlite3.connect(sqlfile)
-    converter = CsvToSql(conn)
-    converter.go(open(csvfile))
-    print "Generating scene: SUCCESS!"
diff --git a/libcore/src/util/Location.hpp b/libcore/src/util/Location.hpp
deleted file mode 100644
index 8b38ba8..0000000
--- a/libcore/src/util/Location.hpp
+++ /dev/null
@@ -1,151 +0,0 @@
-/*  Sirikata Utilities -- Math Library
- *  Location.hpp
- *
- *  Copyright (c) 2009, Daniel Reiter Horn
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are
- *  met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name of Sirikata nor the names of its contributors may
- *    be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _LOCATION_HPP_
-#define _LOCATION_HPP_
-
-#include "Transform.hpp"
-
-namespace Sirikata {
-
-class Location: public Transform {
-    Vector3<float32> mVelocity;
-    Vector3<float32> mAxisOfRotation;
-    float32 mAngularSpeed;
-
-    void changeToWorld(const Location &reference) {
-        setVelocity(reference.getVelocity() + reference.getOrientation() * getVelocity());
-        addAngularRotation(reference.getAxisOfRotation(), reference.getAngularSpeed());
-        setVelocity(getVelocity() +
-                    reference.getAngularSpeed() * (
-                        reference.getAxisOfRotation().cross(getPosition().downCast<float32>())));
-
-        Transform temp = Transform::toWorld(reference);
-        setPosition(temp.getPosition());
-        setOrientation(temp.getOrientation());
-    }
-    void changeToLocal(const Location &reference) {
-        Transform temp = Transform::toLocal(reference);
-        setPosition(temp.getPosition());
-        setOrientation(temp.getOrientation());
-
-        setVelocity(getVelocity() -
-                    reference.getAngularSpeed() * (
-                        reference.getAxisOfRotation().cross(getPosition().downCast<float32>())));
-        addAngularRotation(reference.getAxisOfRotation(), -reference.getAngularSpeed());
-        Quaternion inverseOtherOrientation (reference.getOrientation().inverse());
-        setVelocity(inverseOtherOrientation * (getVelocity() - reference.getVelocity()));
-    }
-public:
-    Location(){}
-    Location(const Vector3<float64>&position,
-             const Quaternion&orientation,
-             const Vector3<float32> &velocity,
-             const Vector3<float32> angularVelocityAxis,
-             float32 angularVelocityRadians):Transform(position,orientation),mVelocity(velocity),mAxisOfRotation(angularVelocityAxis), mAngularSpeed(angularVelocityRadians) {}
-    bool operator ==(const Location&other)const {
-        bool eq=getPosition()==other.getPosition();
-        bool veq=other.mVelocity==mVelocity;
-        bool qeq=getOrientation()==other.getOrientation();
-        bool aeq=mAxisOfRotation==other.mAxisOfRotation;
-        bool seq=mAngularSpeed==other.mAngularSpeed;
-        return eq&&veq&&qeq&&aeq&&seq;
-    }
-
-    const Vector3<float32>&getVelocity()const {
-        return mVelocity;
-    }
-    void setVelocity(const Vector3<float32> velocity) {
-        mVelocity=velocity;
-    }
-    const Transform &getTransform() const {
-        return *this;
-    }
-    const Vector3<float32>&getAxisOfRotation() const {
-        return mAxisOfRotation;
-    }
-    void setAxisOfRotation(const Vector3<float32>&axis) {
-        mAxisOfRotation=axis;
-    }
-    float32 getAngularSpeed() const{
-        return mAngularSpeed;
-    }
-    void setAngularSpeed(float32 radianspersecond) {
-        mAngularSpeed=radianspersecond;
-    }
-    void addAngularRotation(const Vector3<float32> &axis, float32 radianspersecond) {
-        mAxisOfRotation=mAxisOfRotation*mAngularSpeed+axis*radianspersecond;
-        mAngularSpeed=mAxisOfRotation.length();
-        if (mAngularSpeed)
-            mAxisOfRotation/=mAngularSpeed;
-    }
-    Location blend(const Location&newLocation,float32 percentNew) const{
-        float32 percentOld=(1.0f-percentNew);
-        Vector3<float32> angAxis=mAxisOfRotation*mAngularSpeed*percentOld;
-        angAxis+=newLocation.getAxisOfRotation()*newLocation.getAngularSpeed()*percentNew;
-        float angSpeed=angAxis.length();
-        if (angSpeed) angAxis/=angSpeed;
-        return Location (newLocation.getPosition()*percentNew+getPosition()*percentOld,
-                         (newLocation.getOrientation()*percentNew+getOrientation()*percentOld).normal(),
-                         newLocation.getVelocity()*percentNew+getVelocity()*percentOld,
-                         angAxis,
-                         angSpeed);
-    }
-    Location toWorld(const Location &reference) const {
-        Location copy(*this);
-        copy.changeToWorld(reference);
-        return copy;
-    }
-    Location toLocal(const Location &reference) const {
-        Location copy(*this);
-        copy.changeToLocal(reference);
-        return copy;
-    }
-    template<class TimeDuration> Location extrapolate(const TimeDuration&dt)const {
-        return Location(getPosition()+Vector3<float64>(getVelocity())*dt.toSeconds(),
-                        getAngularSpeed()
-                         ? getOrientation()*Quaternion(getAxisOfRotation(),
-                                                       (float)(getAngularSpeed()*dt.toSeconds()))
-                         : getOrientation(),
-                        getVelocity(),
-                        getAxisOfRotation(),
-                        getAngularSpeed());
-    }
-};
-inline std::ostream &operator<< (std::ostream &os, const Location &loc) {
-    os << "[" << loc.getTransform() << "; vel=" <<
-        loc.getVelocity() << "; angVel = " << loc.getAngularSpeed() <<
-        " around " << loc.getAxisOfRotation() << "]";
-    return os;
-}
-
-}
-#endif
diff --git a/libcore/src/util/Matrix3x3.hpp b/libcore/src/util/Matrix3x3.hpp
deleted file mode 100644
index 2ce34cf..0000000
--- a/libcore/src/util/Matrix3x3.hpp
+++ /dev/null
@@ -1,214 +0,0 @@
-/*  Sirikata Utilities -- Math Library
- *  Matrix3x3.hpp
- *
- *  Copyright (c) 2009, Daniel Reiter Horn
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are
- *  met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name of Sirikata nor the names of its contributors may
- *    be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _MATRIX3X3_HPP_
-#define _MATRIX3X3_HPP_
-namespace Sirikata {
-class COLUMNS{};
-class ROWS{};
-
-template <typename scalar> class Matrix3x3 {
-public:
-    typedef Vector3<scalar> Vector3x;
-private:
-    Vector3x mCol[3];
-public:
-    typedef scalar real;
-    Matrix3x3(){}
-    static const Matrix3x3& nil() {
-        static Matrix3x3 nil(Vector3x::nil(),
-                             Vector3x::nil(),
-                             Vector3x::nil(),
-                             COLUMNS());
-        return nil;
-    }
-    static const Matrix3x3& identity() {
-        static Matrix3x3 identity (Vector3x::unitX(),
-                                   Vector3x::unitY(),
-                                   Vector3x::unitZ(),
-                                   COLUMNS());
-        return identity;
-    }
-    Matrix3x3(const Vector3x&col1, const Vector3x&col2, const Vector3x&col3, COLUMNS c){
-        setCol(0,col1);
-        setCol(1,col2);
-        setCol(2,col3);
-    }
-    Matrix3x3(const Vector3x&row1, const Vector3x&row2, const Vector3x&row3, ROWS r){
-        setRow(0,row1);
-        setRow(1,row2);
-        setRow(2,row3);
-    }
-    const Vector3x& getCol(unsigned int which) const {
-        assert(which<3);
-        return mCol[which];
-    }
-    void setCol(unsigned int which,const Vector3x &col) {
-        assert(which<3);
-        mCol[which]=col;
-    }
-    Vector3x getRow(unsigned int which) const {
-        assert(which<3);
-        return Vector3x(mCol[0][which],
-            mCol[1][which],
-            mCol[2][which]);
-    }
-    void setRow(unsigned int which, const Vector3x &row) {
-        assert(which<3);
-        mCol[0][which]=row[0];
-        mCol[1][which]=row[1];
-        mCol[2][which]=row[2];
-    }
-    scalar&operator() (unsigned int row, unsigned int column) {
-        return mCol[column][row];
-    }
-    scalar operator() (unsigned int row, unsigned int column) const{
-        return mCol[column][row];
-    }
-    template <typename T> Vector3<T> operator *(const Vector3<T>&other)const {
-        return mCol[0]*other.x+mCol[1]*other.y+mCol[2]*other.z;
-    }
-    Matrix3x3 operator *(scalar other)const {
-        return Matrix3x3(getCol(0)*other,getCol(1)*other,getCol(2)*other,COLUMNS());
-    }
-    Matrix3x3 operator /(scalar other)const {
-        return Matrix3x3(getCol(0)/other,getCol(1)/other,getCol(2)/other,COLUMNS());
-    }
-    bool operator == (const Matrix3x3&other)const{
-        return getCol(0)==other.getCol(0)&&getCol(1)==other.getCol(1)&&getCol(2)==other.getCol(2);
-    }
-    bool operator != (const Matrix3x3&other)const{
-        return getCol(0)!=other.getCol(0)&&getCol(1)!=other.getCol(1)&&getCol(2)!=other.getCol(2);
-    }
-    Matrix3x3 operator+ (const Matrix3x3&other)const {
-        return Matrix3x3(getCol(0)+other.getCol(0),
-                       getCol(1)+other.getCol(1),
-                       getCol(2)+other.getCol(2),
-                       COLUMNS());
-    }
-    Matrix3x3 operator- (const Matrix3x3&other)const {
-        return Matrix3x3(getCol(0)-other.getCol(0),
-                       getCol(1)-other.getCol(1),
-                       getCol(2)-other.getCol(2),
-                       COLUMNS());
-    }
-    Matrix3x3 operator- ()const {
-        return Matrix3x3(-getCol(0),
-                       -getCol(1),
-                       -getCol(2),
-                       COLUMNS());
-    }
-    Matrix3x3& operator+= (const Matrix3x3&other) {
-        mCol[0]+=other.getCol(0);
-        mCol[1]+=other.getCol(1);
-        mCol[2]+=other.getCol(2);
-        return *this;
-    }
-    Matrix3x3& operator-= (const Matrix3x3&other) {
-        mCol[0]-=other.getCol(0);
-        mCol[1]-=other.getCol(1);
-        mCol[2]-=other.getCol(2);
-        return *this;
-    }
-    Matrix3x3 operator* (const Matrix3x3&other)const {
-        Vector3<scalar> ocol0=other.getCol(0);
-        Vector3<scalar> ocol1=other.getCol(1);
-        Vector3<scalar> ocol2=other.getCol(2);
-        return Matrix3x3(mCol[0]*ocol0.x+mCol[1]*ocol0.y+mCol[2]*ocol0.z,
-                         mCol[0]*ocol1.x+mCol[1]*ocol1.y+mCol[2]*ocol1.z,
-                         mCol[0]*ocol2.x+mCol[1]*ocol2.y+mCol[2]*ocol2.z,
-                         COLUMNS());
-    }
-    Matrix3x3& operator*= (const Matrix3x3&other) {
-        Vector3<scalar> ocol0=other.getCol(0);
-        Vector3<scalar> ocol1=other.getCol(1);
-        Vector3<scalar> ocol2=other.getCol(2);
-        //cannot do this *= inplace
-        ocol0=mCol[0]*ocol0.x+mCol[1]*ocol0.y+mCol[2]*ocol0.z;
-        ocol1=mCol[0]*ocol1.x+mCol[1]*ocol1.y+mCol[2]*ocol1.z;
-        ocol2=mCol[0]*ocol2.x+mCol[1]*ocol2.y+mCol[2]*ocol2.z;
-        //have to copy back
-        mCol[0]=ocol0;
-        mCol[1]=ocol1;
-        mCol[2]=ocol2;
-        return *this;
-    }
-    Matrix3x3& operator*= (scalar other) {
-        mCol[0]*=other;
-        mCol[1]*=other;
-        mCol[2]*=other;
-        return *this;
-    }
-    Matrix3x3& operator/= (scalar other) {
-        mCol[0]/=other;
-        mCol[1]/=other;
-        mCol[2]/=other;
-        return *this;
-    }
-    Matrix3x3 transpose() const {
-        return Matrix3x3(getCol(0),
-                      getCol(1),
-                      getCol(2),
-                      ROWS());
-    }
-    ///@FIXME: should this be a double or a scalar
-    double determinant() const {
-        return mCol[0].x*(double)mCol[1].y*mCol[2].z-
-               mCol[0].x*(double)mCol[2].y*mCol[1].z +
-               mCol[1].x*(double)mCol[2].y*mCol[0].z -
-               mCol[1].x*(double)mCol[0].y*mCol[2].z +
-               mCol[2].x*(double)mCol[0].y*mCol[1].z -
-               mCol[2].x*(double)mCol[1].y*mCol[0].z;
-    }
-    std::string toString() const {
-        std::ostringstream os;
-        os<<"{ col1:"<<mCol[0]<<" col2:"<<mCol[1]<<" col3:"<<mCol[2]<<'}';
-        return os.str();
-    }
-};
-template<typename scalar> inline std::ostream& operator <<(std::ostream& os, const Matrix3x3<scalar> &rhs) {
-    os<<"{ col1:"<<rhs.getCol(0)<<" col2:"<<rhs.getCol(1)<<" col3:"<<rhs.getCol(2)<<'}';
-    return os;
-}
-
-template <typename T,typename S> Vector3<T> operator *(const Vector3<T>&vec, const Matrix3x3<S>&mat) {
-    return Vector3<T>(mat.getCol(0).dot(vec),
-                      mat.getCol(1).dot(vec),
-                      mat.getCol(2).dot(vec));
-}
-template <typename T> Matrix3x3<T> operator *(T other, const Matrix3x3<T>&mat) {
-    return Matrix3x3<T>(mat.getCol(0)*other,mat.getCol(1)*other,mat.getCol(2)*other,COLUMNS());
-}
-template <typename T> Matrix3x3<T> operator /(T other, const Matrix3x3<T>&mat) {
-    return Matrix3x3<T>(other/mat.getCol(0),other/mat.getCol(1),other/mat.getCol(2),COLUMNS());
-}
-}
-#endif
diff --git a/libcore/src/util/Transform.hpp b/libcore/src/util/Transform.hpp
deleted file mode 100644
index de057fd..0000000
--- a/libcore/src/util/Transform.hpp
+++ /dev/null
@@ -1,122 +0,0 @@
-/*  Sirikata Utilities -- Math Library
- *  Transform.hpp
- *
- *  Copyright (c) 2009, Daniel Reiter Horn
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are
- *  met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name of Sirikata nor the names of its contributors may
- *    be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _TRANSFORM_HPP_
-#define _TRANSFORM_HPP_
-
-#include "Quaternion.hpp"
-
-namespace Sirikata {
-
-class Transform: protected Vector3<float64> {
-    Quaternion mOrientation;
-public:
-    Transform(){}
-    Transform(const Vector3<float64>&position, 
-             const Quaternion&orientation):mOrientation(orientation) {
-        x=position.x;
-        y=position.y;
-        z=position.z;
-    }
-    bool operator ==(const Transform&other)const {
-        bool eq=x==other.x&&y==other.y&&z==other.z;
-        bool qeq=mOrientation==other.mOrientation;
-        return eq && qeq;
-    }
-    class Error {
-        float64 mDistanceError;
-        float32 mAngularError;
-    public:
-        Error(float64 distanceError, float32 angularError){
-            mDistanceError=distanceError;
-            mAngularError=angularError;
-        }
-        Error(const Transform&correct, const Transform&incorrect) {
-            mDistanceError=(incorrect.getPosition()-correct.getPosition()).length();
-            mAngularError=(float32)(2.0*std::acos(correct.getOrientation().normal()
-                                             .dot(incorrect.getOrientation().normal())));
-        }
-        bool operator<= (const Error&other)const {
-            return mDistanceError<=other.mDistanceError&&mAngularError<=other.mAngularError;
-        }
-    };
-    class ErrorPredicate {
-        Error mBound;
-    public:
-        ErrorPredicate(const Error&bound):mBound(bound){}
-        ///Returns true if the error is too high... i.e. the error is not less than the bound
-        bool operator() (const Transform &correct, const Transform &incorrect) const{
-            return !(Error(correct,incorrect)<=mBound);
-        }
-    }; 
-    const Vector3<float64>&getPosition()const {
-        return *this;
-    }
-    void setPosition(const Vector3<float64>& position) {
-        x=position.x;
-        y=position.y;
-        z=position.z;
-    }
-    const Quaternion&getOrientation() const{
-        return mOrientation;
-    }
-    void setOrientation(const Quaternion&orientation) {
-        mOrientation=orientation;
-    }
-    /// Alters this Transformation.
-    Transform toWorld(const Transform &reference) const {
-        return Transform(reference.getPosition() +
-                             reference.getOrientation() * getPosition(),
-                         reference.getOrientation() * getOrientation());
-    }
-    Transform toLocal(const Transform &reference) const {
-        Quaternion inverseOtherOrientation (reference.getOrientation().inverse());
-        return Transform(inverseOtherOrientation * (
-                             getPosition() - reference.getPosition()),
-                         inverseOtherOrientation * getOrientation());
-    }
-    Transform blend(const Transform&newTransform,float32 percentNew) const{
-        float32 percentOld=(1.0f-percentNew);
-        return Transform (newTransform.getPosition()*percentNew+getPosition()*percentOld,
-                         (newTransform.getOrientation()*percentNew+getOrientation()*percentOld).normal());
-    }
-};
-
-inline std::ostream &operator<< (std::ostream &os, const Transform &trans) {
-    os << "(" << trans.getPosition() << "; orientation " <<
-        trans.getOrientation() << ")";
-    return os;
-}
-
-
-
-}
-#endif
diff --git a/libcore/src/util/Vector2.hpp b/libcore/src/util/Vector2.hpp
deleted file mode 100644
index a214e0e..0000000
--- a/libcore/src/util/Vector2.hpp
+++ /dev/null
@@ -1,211 +0,0 @@
-/*  Sirikata Utilities -- Math Library
- *  Vector2.hpp
- *
- *  Copyright (c) 2009, Daniel Reiter Horn
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are
- *  met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name of Sirikata nor the names of its contributors may
- *    be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _SIRIKATA_VECTOR2_HPP_
-#define _SIRIKATA_VECTOR2_HPP_
-
-#include <string>
-#include <cassert>
-#include <sstream>
-
-namespace Sirikata {
-template <typename scalar> class Vector2 {
-public:
-    static const unsigned char size = 2;
-    typedef scalar real;
-    union {
-        struct {
-            scalar x;
-            scalar y;
-        };
-        scalar v[2];
-    };
-    Vector2(scalar x, scalar y) {
-        this->x=x;
-        this->y=y;
-    }
-    template <class V> explicit Vector2(const V&other) {
-        x=other[0];
-        y=other[1];
-    }
-    Vector2(){}
-    template <class V> static Vector2 fromSSE(const V&other){
-        return Vector2(other.x(),other.y());
-    }
-    scalar&operator[](const unsigned int i) {
-        assert(i<2);
-        return v[i];
-    }
-#if 0
-    template<class T> operator T() const{
-        return T(x,y);
-    }
-#else
-    template<class T> T convert() const{
-        return T(x,y);
-    }
-#endif
-    void set(scalar x, scalar y) {
-        this->x=x;
-        this->y=y;
-    }
-    scalar operator[](const unsigned int i) const{
-        assert(i<2);
-        return v[i];
-    }
-    Vector2&operator=(scalar other) {
-        x=other;
-        y=other;
-        return *this;
-    }
-    static Vector2 nil() {
-        return Vector2(0,0);
-    }
-    static Vector2 unitX() {
-        return Vector2(1,0);
-    }
-    static Vector2 unitY() {
-        return Vector2(0,1);
-    }
-    static Vector2 unitNegX() {
-        return Vector2(-1,0);
-    }
-    static Vector2 unitNegY() {
-        return Vector2(0,-1);
-    }
-    Vector2 operator*(scalar scale) const {
-        return Vector2(x*scale,y*scale);
-    }
-    Vector2 operator/(scalar scale) const {
-        return Vector2(x/scale,y/scale);
-    }
-    Vector2 operator+(const Vector2&other) const {
-        return Vector2(x+other.x,y+other.y);
-    }
-    Vector2 componentMultiply(const Vector2&other) const {
-        return Vector2(x*other.x,y*other.y);
-    }
-    Vector2 operator-(const Vector2&other) const {
-        return Vector2(x-other.x,y-other.y);
-    }
-    Vector2 operator-() const {
-        return Vector2(-x,-y);
-    }
-    Vector2& operator*=(scalar scale) {
-        x*=scale;
-        y*=scale;
-        return *this;
-    }
-    Vector2& operator/=(scalar scale) {
-        x/=scale;
-        y/=scale;
-        return *this;
-    }
-    Vector2& operator+=(const Vector2& other) {
-        x+=other.x;
-        y+=other.y;
-        return *this;
-    }
-    Vector2& operator-=(const Vector2& other) {
-        x-=other.x;
-        y-=other.y;
-        return *this;
-    }
-    scalar cross(const Vector2&other) const {
-        return x*other.y-y*other.x;
-    }
-    scalar dot(const Vector2 &other) const{
-        return x*other.x+y*other.y;
-    }
-    Vector2 perp() const {
-        return Vector2(-y, x);
-    }
-    Vector2 min(const Vector2&other)const {
-        return Vector2(other.x<x?other.x:x,
-                       other.y<y?other.y:y);
-    }
-    Vector2 max(const Vector2&other)const {
-        return Vector2(other.x>x?other.x:x,
-                       other.y>y?other.y:y);
-    }
-    scalar lengthSquared()const {
-        return dot(*this);
-    }
-    scalar length()const {
-        return (scalar)sqrt(dot(*this));
-    }
-    bool operator==(const Vector2&other)const {
-        return x==other.x&&y==other.y;
-    }
-    bool operator!=(const Vector2&other)const {
-        return x!=other.x||y!=other.y;
-    }
-    Vector2 normal()const {     // FIXME: Change this to normalized()
-        scalar len=length();
-        if (len>0)
-            return *this/len;
-        return *this;
-    }
-    scalar normalizeThis() {
-        scalar len=length();
-        if (len>0)
-            this/=len;
-        return len;
-    }
-    std::string toString()const {
-        std::ostringstream os;
-        os<<'<'<<x<<","<<y<<'>';
-        return os.str();
-    }
-    Vector2 reflect(const Vector2& normal)const {
-        return Vector2(*this-normal*((scalar)2.0*this->dot(normal)));
-    }
-};
-
-template<typename scalar> inline Vector2<scalar> operator *(scalar lhs, const Vector2<scalar> &rhs) {
-    return Vector2<scalar>(lhs*rhs.x,lhs*rhs.y,lhs*rhs.z);
-}
-template<typename scalar> inline Vector2<scalar> operator /(scalar lhs, const Vector2<scalar> &rhs) {
-    return Vector2<scalar>(lhs/rhs.x,lhs/rhs.y);
-}
-template<typename scalar> inline std::ostream& operator <<(std::ostream& os, const Vector2<scalar> &rhs) {
-    os<<'<'<<rhs.x<<","<<rhs.y<<","<<'>';
-    return os;
-}
-template<typename scalar> inline std::istream& operator >>(std::istream& is, Vector2<scalar> &rhs) {
-    // FIXME this should be more robust.  It currently relies on the exact format provided by operator <<
-    char dummy;
-    is >> dummy >> rhs.x >> dummy >> rhs.y >> dummy;
-    return is;
-}
-
-}
-#endif
diff --git a/libcore/src/util/Vector3.hpp b/libcore/src/util/Vector3.hpp
deleted file mode 100644
index 51e9096..0000000
--- a/libcore/src/util/Vector3.hpp
+++ /dev/null
@@ -1,232 +0,0 @@
-/*  Sirikata Utilities -- Math Library
- *  Vector3.hpp
- *
- *  Copyright (c) 2009, Daniel Reiter Horn
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are
- *  met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name of Sirikata nor the names of its contributors may
- *    be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _SIRIKATA_VECTOR3_HPP_
-#define _SIRIKATA_VECTOR3_HPP_
-
-#include <string>
-#include <cassert>
-#include <sstream>
-
-namespace Sirikata {
-template <typename scalar> class Vector3 {
-public:
-    static const unsigned char size = 3;
-    typedef scalar real;
-    union {
-        struct {
-            scalar x;
-            scalar y;
-            scalar z;
-        };
-        scalar v[3];
-    };
-    Vector3(scalar x, scalar y, scalar z) {
-        this->x=x;
-        this->y=y;
-        this->z=z;
-    }
-    template <class V> explicit Vector3(const V&other) {
-        x=other[0];
-        y=other[1];
-        z=other[2];
-    }
-    Vector3(){}
-    template <class V> static Vector3 fromSSE(const V&other){
-        return Vector3(other.x(),other.y(),other.z());
-    }
-    scalar&operator[](const unsigned int i) {
-        assert(i<3);
-        return v[i];
-    }
-#if 0
-    template<class T> operator T() const{
-        return T(x,y,z);
-    }
-#else
-    template<class T> T convert() const{
-        return T(x,y,z);
-    }
-#endif
-    template<class T> Vector3<T> downCast() const{
-        return Vector3<T>((T)x,(T)y,(T)z);
-    }
-    
-    scalar operator[](const unsigned int i) const{
-        assert(i<3);
-        return v[i];
-    }
-    void set(scalar x, scalar y, scalar z) {
-        this->x=x;
-        this->y=y;
-        this->z=z;
-    }
-
-    Vector3&operator=(scalar other) {
-        x=other;
-        y=other;
-        z=other;
-        return *this;
-    }
-    static Vector3 nil() {
-        return Vector3(0,0,0);
-    }
-    static Vector3 unitX() {
-        return Vector3(1,0,0);
-    }
-    static Vector3 unitY() {
-        return Vector3(0,1,0);
-    }
-    static Vector3 unitZ() {
-        return Vector3(0,0,1);
-    }
-    static Vector3 unitNegX() {
-        return Vector3(-1,0,0);
-    }
-    static Vector3 unitNegY() {
-        return Vector3(0,-1,0);
-    }
-    static Vector3 unitNegZ() {
-        return Vector3(0,0,-1);
-    }
-    Vector3 operator*(scalar scale) const {
-        return Vector3(x*scale,y*scale,z*scale);
-    }
-    Vector3 operator/(scalar scale) const {
-        return Vector3(x/scale,y/scale,z/scale);
-    }
-    Vector3 operator+(const Vector3&other) const {
-        return Vector3(x+other.x,y+other.y,z+other.z);
-    }
-    Vector3 componentMultiply(const Vector3&other) const {
-        return Vector3(x*other.x,y*other.y,z*other.z);
-    }
-    Vector3 operator-(const Vector3&other) const {
-        return Vector3(x-other.x,y-other.y,z-other.z);
-    }
-    Vector3 operator-() const {
-        return Vector3(-x,-y,-z);
-    }
-    Vector3& operator*=(scalar scale) {
-        x*=scale;
-        y*=scale;
-        z*=scale;
-        return *this;
-    }
-    Vector3& operator/=(scalar scale) {
-        x/=scale;
-        y/=scale;
-        z/=scale;
-        return *this;
-    }
-    Vector3& operator+=(const Vector3& other) {
-        x+=other.x;
-        y+=other.y;
-        z+=other.z;
-        return *this;
-    }
-    Vector3& operator-=(const Vector3& other) {
-        x-=other.x;
-        y-=other.y;
-        z-=other.z;
-        return *this;
-    }
-    Vector3 cross(const Vector3&other) const {
-        return Vector3(y*other.z-z*other.y,
-                       z*other.x-x*other.z,
-                       x*other.y-y*other.x);
-    }
-    scalar dot(const Vector3 &other) const{
-        return x*other.x+y*other.y+z*other.z;
-    }
-    Vector3 min(const Vector3&other)const {
-        return Vector3(other.x<x?other.x:x,
-                       other.y<y?other.y:y,
-                       other.z<z?other.z:z);
-    }
-    Vector3 max(const Vector3&other)const {
-        return Vector3(other.x>x?other.x:x,
-                       other.y>y?other.y:y,
-                       other.z>z?other.z:z);
-    }
-    scalar lengthSquared()const {
-        return dot(*this);
-    }
-    scalar length()const {
-        return (scalar)sqrt(dot(*this));
-    }
-    bool operator==(const Vector3&other)const {
-        return x==other.x&&y==other.y&&z==other.z;
-    }
-    bool operator!=(const Vector3&other)const {
-        return x!=other.x||y!=other.y||z!=other.z;
-    }
-    Vector3 normal()const {     // FIXME: Change this to normalized()
-        scalar len=length();
-        if (len>1e-08)
-            return *this/len;
-        return *this;
-    }
-    scalar normalizeThis() {
-        scalar len=length();
-        if (len>1e-08)
-            *this/=len;
-        return len;
-    }
-    std::string toString()const {
-        std::ostringstream os;
-        os<<'<'<<x<<","<<y<<","<<z<<'>';
-        return os.str();
-    }
-    Vector3 reflect(const Vector3& normal)const {
-        return Vector3(*this-normal*((scalar)2.0*this->dot(normal)));
-    }
-};
-
-template<typename scalar> inline Vector3<scalar> operator *(scalar lhs, const Vector3<scalar> &rhs) {
-    return Vector3<scalar>(lhs*rhs.x,lhs*rhs.y,lhs*rhs.z);
-}
-template<typename scalar> inline Vector3<scalar> operator /(scalar lhs, const Vector3<scalar> &rhs) {
-    return Vector3<scalar>(lhs/rhs.x,lhs/rhs.y,lhs/rhs.z);
-}
-template<typename scalar> inline std::ostream& operator <<(std::ostream& os, const Vector3<scalar> &rhs) {
-    os<<'<'<<rhs.x<<","<<rhs.y<<","<<rhs.z<<'>';
-    return os;
-}
-template<typename scalar> inline std::istream& operator >>(std::istream& is, Vector3<scalar> &rhs) {
-    // FIXME this should be more robust.  It currently relies on the exact format provided by operator <<
-    char dummy;
-    is >> dummy >> rhs.x >> dummy >> rhs.y >> dummy >> rhs.z >> dummy;
-    return is;
-}
-
-}
-#endif
diff --git a/libcore/src/util/Vector4.hpp b/libcore/src/util/Vector4.hpp
deleted file mode 100644
index d744668..0000000
--- a/libcore/src/util/Vector4.hpp
+++ /dev/null
@@ -1,230 +0,0 @@
-/*  Sirikata Utilities -- Math Library
- *  Vector4.hpp
- *
- *  Copyright (c) 2009, Daniel Reiter Horn
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are
- *  met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name of Sirikata nor the names of its contributors may
- *    be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SIRIKATA_VECTOR4_HPP_
-#define _SIRIKATA_VECTOR4_HPP_
-
-#include <string>
-#include <cassert>
-#include <sstream>
-
-namespace Sirikata {
-template <typename scalar> class Vector3;
-
-template <typename scalar> class Vector4 {
-public:
-    static const unsigned char size = 4;
-    typedef scalar real;
-    union {
-        struct {
-            scalar x;
-            scalar y;
-            scalar z;
-            scalar w;
-        };
-        scalar v[4];
-    };
-    Vector4(scalar x, scalar y, scalar z, scalar w) {
-        this->x=x;
-        this->y=y;
-        this->z=z;
-        this->w=w;
-    }
-    Vector4(){}
-    template<class T>T convert(const T*ptr=NULL) const{
-        return T(x,y,z,w);
-    }
-    template<class T> Vector4<T> downCast() const{
-        return Vector4<T>((T)x,(T)y,(T)z,(T)w);
-    }
-
-    template <class V> static Vector4 fromArray(const V&other){
-        return Vector4(other[0],other[1],other[2],other[3]);
-    }
-
-    template <class V> static Vector4 fromSSE(const V&other){
-        return Vector4(other.x(),other.y(),other.z(),other.w());
-    }
-    void set(scalar x, scalar y, scalar z, scalar w) {
-        this->x=x;
-        this->y=y;
-        this->z=z;
-        this->w=w;
-    }
-    scalar&operator[](const unsigned int i) {
-        assert(i<4);
-        return v[i];
-    }
-    scalar operator[](const unsigned int i) const{
-        assert(i<4);
-        return v[i];
-    }
-    Vector4&operator=(scalar other) {
-        x=other;
-        y=other;
-        z=other;
-        w=other;
-        return *this;
-    }
-    static Vector4 nil() {
-        return Vector4(0,0,0,0);
-    }
-    static Vector4 unitX() {
-        return Vector4(1,0,0,0);
-    }
-    static Vector4 unitY() {
-        return Vector4(0,1,0,0);
-    }
-    static Vector4 unitZ() {
-        return Vector4(0,0,1,0);
-    }
-    static Vector4 unitNegX() {
-        return Vector4(-1,0,0,0);
-    }
-    static Vector4 unitNegY() {
-        return Vector4(0,-1,0,0);
-    }
-    static Vector4 unitNegZ() {
-        return Vector4(0,0,-1,0);
-    }
-    Vector4 operator*(scalar scale) const {
-        return Vector4(x*scale,y*scale,z*scale,w*scale);
-    }
-    Vector4 operator/(scalar scale) const {
-        return Vector4(x/scale,y/scale,z/scale,w/scale);
-    }
-    Vector4 operator+(const Vector4&other) const {
-        return Vector4(x+other.x,y+other.y,z+other.z,w+other.w);
-    }
-    Vector4 operator-(const Vector4&other) const {
-        return Vector4(x-other.x,y-other.y,z-other.z,w-other.w);
-    }
-    Vector4 operator-() const {
-        return Vector4(-x,-y,-z,-w);
-    }
-    Vector4& operator*=(scalar scale) {
-        x*=scale;
-        y*=scale;
-        z*=scale;
-        w*=scale;
-        return *this;
-    }
-    Vector4& operator/=(scalar scale) {
-        x/=scale;
-        y/=scale;
-        z/=scale;
-        w/=scale;
-        return *this;
-    }
-    Vector4& operator+=(const Vector4& other) {
-        x+=other.x;
-        y+=other.y;
-        z+=other.z;
-        w+=other.w;
-        return *this;
-    }
-    Vector4& operator-=(const Vector4& other) {
-        x-=other.x;
-        y-=other.y;
-        z-=other.z;
-        w-=other.w;
-        return *this;
-    }
-    Vector4 componentMultiply(const Vector4&other) const {
-        return Vector4(x*other.x,y*other.y,z*other.z,w*other.w);
-    }
-    scalar dot(const Vector4 &other) const{
-        return x*other.x+y*other.y+z*other.z+w*other.w;
-    }
-    Vector4 min(const Vector4&other)const {
-        return Vector4(other.x<x?other.x:x,
-                       other.y<y?other.y:y,
-                       other.z<z?other.z:z,
-                       other.w<w?other.w:w);
-    }
-    Vector4 max(const Vector4&other)const {
-        return Vector4(other.x>x?other.x:x,
-                       other.y>y?other.y:y,
-                       other.z>z?other.z:z,
-                       other.w>w?other.w:w);
-    }
-    scalar lengthSquared()const {
-        return dot(*this);
-    }
-    scalar length()const {
-        return (scalar)sqrt(dot(*this));
-    }
-    bool operator==(const Vector4&other)const {
-        return x==other.x&&y==other.y&&z==other.z&&w==other.w;
-    }
-    bool operator!=(const Vector4&other)const {
-        return x!=other.x||y!=other.y||z!=other.z||w!=other.w;
-    }
-    Vector4 normal()const {     // FIXME: Change this to normalized()
-        scalar len=length();
-        if (len>1e-08)
-            return *this/len;
-        return *this;
-    }
-    scalar normalizeThis() {
-        scalar len=length();
-        if (len>1e-08)
-            *this/=len;
-        return len;
-    }
-    std::string toString()const {
-        std::ostringstream os;
-        os<<'<'<<x<<","<<y<<","<<z<<","<<w<<'>';
-        return os.str();
-    }
-};
-
-template<typename scalar> inline Vector4<scalar> operator *(scalar lhs, const Vector4<scalar> &rhs) {
-    return Vector4<scalar>(lhs*rhs.x,lhs*rhs.y,lhs*rhs.z,lhs*rhs.w);
-}
-template<typename scalar> inline Vector4<scalar> operator /(scalar lhs, const Vector4<scalar> &rhs) {
-    return Vector4<scalar>(lhs/rhs.x,lhs/rhs.y,lhs/rhs.z,lhs/rhs.w);
-}
-template<typename scalar> inline std::ostream& operator <<(std::ostream& os, const Vector4<scalar> &rhs) {
-    os<<'<'<<rhs.x<<","<<rhs.y<<","<<rhs.z<<","<<rhs.w<<'>';
-    return os;
-}
-template<typename scalar> inline std::istream& operator >>(std::istream& is, Vector4<scalar> &rhs) {
-    // FIXME this should be more robust.  It currently relies on the exact format provided by operator <<
-    char dummy;
-    is >> dummy >> rhs.x >> dummy >> rhs.y >> dummy >> rhs.z >> dummy >> rhs.w >> dummy;
-    return is;
-}
-
-}
-
-#endif //_SIRIKATA_VECTOR4_HPP_
diff --git a/libcore/test/ExtrapolationTest.hpp b/libcore/test/ExtrapolationTest.hpp
deleted file mode 100644
index 38cdc29..0000000
--- a/libcore/test/ExtrapolationTest.hpp
+++ /dev/null
@@ -1,222 +0,0 @@
-/*  Sirikata Tests -- Sirikata Test Suite
- *  ExtrapolationTest.hpp
- *
- *  Copyright (c) 2009, Daniel Reiter Horn
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are
- *  met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name of Sirikata nor the names of its contributors may
- *    be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#include <cxxtest/TestSuite.h>
-#include "util/Extrapolation.hpp"
-#include "util/Location.hpp"
-class ExtrapolationTest : public CxxTest::TestSuite
-{
-    typedef Sirikata::Location Location;
-    typedef Sirikata::Transform Transform;
-    typedef Sirikata::Vector3d Vector3d;
-    typedef Sirikata::Quaternion Quaternion;
-    typedef Sirikata::Vector3f Vector3f;
-    typedef Sirikata::Extrapolator<Location> ExtrapolatorBase;
-    typedef Location::ErrorPredicate ErrorPredicate;
-    typedef Sirikata::TimedWeightedExtrapolator<Location,ErrorPredicate> Extrapolator;
-public:
-    void testPredict( void )
-    {
-        using namespace Sirikata;
-        ErrorPredicate ep(Location::Error(3,3));
-        Time now=Time::now(Duration::zero());
-		Duration inc=Duration::seconds(.25);
-		Duration hinc=Duration::seconds(.125);
-        ExtrapolatorBase * base=new Extrapolator(inc,
-                                                 now,
-                                                 Location(Vector3d(256,16,1),
-                                                          Quaternion(Vector3f(0,1,0),0),
-                                                          Vector3f(0,0,0),
-                                                          Vector3f(0,1,0),
-                                                          0),ep);
-        TS_ASSERT(base->needsUpdate(now+inc,
-                                    Location(Vector3d(256,16,1)*2.0,
-                                             Quaternion(Vector3f(0,1,0),0),
-                                             Vector3f(0,0,0),
-                                             Vector3f(0,1,0),
-                                             0)));
-        base->updateValue(now+inc,Location(Vector3d(256,16,1)*2.0,
-                                           Quaternion(Vector3f(0,1,0),0),
-                                           Vector3f(1,0,0),
-                                           Vector3f(0,1,0),
-                                           0));
-        assert_near(base->extrapolate(now+inc+hinc),
-                         Location(Vector3d(256,16,1)*.5+
-                                  Vector3d(256,16,1)+
-                                  Vector3d(.125,0,0)*.5,
-                                  Quaternion(Vector3f(0,1,0),0),
-                                  Vector3f(.5,0,0),
-                                  Vector3f(0,0,0),
-                                  0));
-        delete base;
-    }
-
-    template <class T>
-    bool check_near(T a, T b) {
-        float delta = 1e-5f;
-        return ((b > a-delta) && (b < a+delta));
-    }
-
-    template <class T>
-    bool check_near(const Sirikata::Vector3<T> &a, const Sirikata::Vector3<T> &b) {
-        return check_near(a.x, b.x) &&
-            check_near(a.y, b.y) &&
-            check_near(a.z, b.z);
-    }
-    bool check_near(const Sirikata::Quaternion &a,const Sirikata::Quaternion &b) {
-        return check_near(a.w, b.w) &&
-            check_near(Vector3f(a.x,a.y,a.z),Vector3f(b.x,b.y,b.z));
-    }
-
-    void assert_near(const Transform &a,const Transform &b) {
-        assert_near(
-            Location(a.getPosition(),
-                     a.getOrientation(),
-                     Vector3f::nil(),Vector3f::nil(),0),
-            Location(b.getPosition(),
-                     b.getOrientation(),
-                     Vector3f::nil(),Vector3f::nil(),0));
-    }
-    void assert_near(const Location &a,const Location &b) {
-        bool fail=false;
-        std::ostringstream str;
-        if (!check_near(a.getPosition(), b.getPosition())) {
-            str << "Positions "<<a.getPosition()<<" and "<<
-                b.getPosition()<<" differ."<<std::endl;
-            fail=true;
-        }
-        if (!check_near(a.getOrientation(), b.getOrientation())) {
-            str << "Orientations "<<a.getOrientation()<<" and "<<
-                b.getOrientation()<<" differ."<<std::endl;
-            fail=true;
-        }
-        if (!check_near(a.getVelocity(), b.getVelocity())) {
-            str << "Velocities "<<a.getVelocity()<<" and "<<
-                b.getVelocity()<<" differ."<<std::endl;
-            fail=true;
-        }
-        if (!check_near(a.getAxisOfRotation(), b.getAxisOfRotation())) {
-            str << "Axes "<<a.getAxisOfRotation()<<" and "<<
-                b.getAxisOfRotation()<<" differ."<<std::endl;
-            fail=true;
-        }
-        if (!check_near(a.getAngularSpeed(), b.getAngularSpeed())) {
-            str << "Rotation speeds "<<a.getAngularSpeed()<<" and "<<
-                b.getAngularSpeed()<<" differ."<<std::endl;
-            fail=true;
-        }
-        if (fail) {
-            TS_FAIL(str.str());
-        }
-    }
-
-
-    void testTransformIdentity(void) {
-        Transform frameOfReference(Vector3d(1,0,0),
-                                  Quaternion(0,0,0,1, Quaternion::XYZW()));
-        Transform testObject(Vector3d(1,0,0),
-                                  Quaternion(0,0,0,1, Quaternion::XYZW()));
-        Transform worldCoords(testObject.toWorld(frameOfReference).toLocal(frameOfReference));
-        assert_near(worldCoords,testObject);
-    }
-
-    void testWorldCoordinates_position() {
-        Location frameOfReference(Vector3d(1,0,0),
-                                  Quaternion(0,0,0,1, Quaternion::XYZW()),
-                                  Vector3f(0,100,0),
-                                  Vector3f(0,0,0),0);
-        Location testObject(Vector3d(1,0,0),
-                                  Quaternion(0,0,0,1, Quaternion::XYZW()),
-                                  Vector3f(0,200,100),
-                                  Vector3f(0,0,0),0);
-        Transform worldCoords(testObject);
-        worldCoords = worldCoords.toWorld(frameOfReference);
-        worldCoords = worldCoords.toLocal(frameOfReference);
-        assert_near(worldCoords, testObject);
-    }
-    void testWorldCoordinates_orientation() {
-        Location frameOfReference(Vector3d(0.0,0.0,0.0),
-                                  Quaternion(Vector3f(0.0f,1.0f,0.0f),0.77f),
-                                  Vector3f(0.0f,0.0f,0.0f),
-                                  Vector3f(0.0f,0.0f,0.0f),0.0f);
-        Location testObject(Vector3d(1.0,0.0,1.0),
-                                  Quaternion(Vector3f(1.0f,0.0f,1.0f),0),
-                                  Vector3f(0.0f,100.0f,50.0f),
-                                  Vector3f(0.0f,0.0f,1.0f),1.0f);
-        Location worldCoords(testObject);
-        worldCoords = worldCoords.toWorld(frameOfReference);
-        worldCoords = worldCoords.toLocal(frameOfReference);
-        assert_near(worldCoords, testObject);
-    }
-    void testWorldCoordinates_positionorientation() {
-        Location frameOfReference(Vector3d(10.0,20.0,0.0),
-                                  Quaternion(Vector3f(0.0f,1.0f,0.0f),0.77f),
-                                  Vector3f(1000.0f,50.0f,50.0f),
-                                  Vector3f(0.0f,0.0f,0.0f),0.0f);
-        Location testObject(Vector3d(1.0,0.0,1.0),
-                                  Quaternion(Vector3f(1.0f,0.0f,1.0f),0.0f),
-                                  Vector3f(0.0f,100.0f,50.0f),
-                                  Vector3f(0.0f,0.0f,1.0f),1.0f);
-        Location worldCoords(testObject);
-        worldCoords = worldCoords.toWorld(frameOfReference);
-        worldCoords = worldCoords.toLocal(frameOfReference);
-        assert_near(worldCoords, testObject);
-    }
-    void testWorldCoordinates_angvel() {
-        Location frameOfReference(Vector3d(10.0f,20.0f,0.0f),
-                                  Quaternion(Vector3f(0.0f,1.0f,0.0f),0.77f),
-                                  Vector3f(1000.0f,50.0f,50.0f),
-                                  Vector3f(0.0f,0.71f,0.71f),-2.0f);
-        Location testObject(Vector3d(1.0f,0.0f,1.0f),
-                                  Quaternion(Vector3f(1.0f,0.0f,1.0f),0.0f),
-                                  Vector3f(0.0f,100.0f,50.0f),
-                                  Vector3f(0.0f,0.0f,0.0f),0.0f);
-        Location worldCoords(testObject);
-        worldCoords = worldCoords.toWorld(frameOfReference);
-        worldCoords = worldCoords.toLocal(frameOfReference);
-        assert_near(worldCoords, testObject);
-    }
-    void testWorldCoordinates_all() {
-        Location frameOfReference(Vector3d(10.0f,20.0f,0.0f),
-                                  Quaternion(Vector3f(0.0f,1.0f,0.0f),0.77f),
-                                  Vector3f(1000.0f,50.0f,50.0f),
-                                  Vector3f(0.0f,0.71f,0.71f),-2.0f);
-        Location testObject(Vector3d(1.0f,0.0f,1.0f),
-                                  Quaternion(Vector3f(1.0f,0.0f,1.0f),0.0f),
-                                  Vector3f(0.0f,100.0f,50.0f),
-                                  Vector3f(0.0f,0.0f,1.0f),10.0f);
-        Location worldCoords(testObject);
-        worldCoords = worldCoords.toWorld(frameOfReference);
-        worldCoords = worldCoords.toLocal(frameOfReference);
-        assert_near(worldCoords, testObject);
-    }
-
-};
diff --git a/liboh/include/oh/ProxyCreationListener.hpp b/liboh/include/oh/ProxyCreationListener.hpp
index 3e874de..db89ceb 100644
--- a/liboh/include/oh/ProxyCreationListener.hpp
+++ b/liboh/include/oh/ProxyCreationListener.hpp
@@ -1,45 +1,45 @@
-/*  Sirikata Object Host
- *  ProxyCreationListener.hpp
- *
- *  Copyright (c) 2009, Daniel Reiter Horn
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are
- *  met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name of Sirikata nor the names of its contributors may
- *    be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef _SIRIKATA_PROXY_CREATION_LISTENER_HPP_
-#define _SIRIKATA_PROXY_CREATION_LISTENER_HPP_
-namespace Sirikata {
-class ProxyObject;
-
-typedef std::tr1::shared_ptr<ProxyObject> ProxyObjectPtr;
-class SIRIKATA_OH_EXPORT ProxyCreationListener {
-public:
-    virtual ~ProxyCreationListener(){}
-    virtual void createProxy (ProxyObjectPtr)=0;
-    virtual void destroyProxy (ProxyObjectPtr)=0;
-};
-}
-#endif
+/*  Sirikata Object Host
+ *  ProxyCreationListener.hpp
+ *
+ *  Copyright (c) 2009, Daniel Reiter Horn
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are
+ *  met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name of Sirikata nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _SIRIKATA_PROXY_CREATION_LISTENER_HPP_
+#define _SIRIKATA_PROXY_CREATION_LISTENER_HPP_
+namespace Sirikata {
+class ProxyObject;
+
+typedef std::tr1::shared_ptr<ProxyObject> ProxyObjectPtr;
+class SIRIKATA_OH_EXPORT ProxyCreationListener {
+public:
+    virtual ~ProxyCreationListener(){}
+    virtual void createProxy (ProxyObjectPtr)=0;
+    virtual void destroyProxy (ProxyObjectPtr)=0;
+};
+}
+#endif
diff --git a/liboh/plugins/ogre/DragActions.cpp b/liboh/plugins/ogre/DragActions.cpp
index 5dff57b..291dfe1 100644
--- a/liboh/plugins/ogre/DragActions.cpp
+++ b/liboh/plugins/ogre/DragActions.cpp
@@ -1,878 +1,878 @@
-/*  Sirikata liboh -- Ogre Graphics Plugin
- *  DragActions.cpp
- *
- *  Copyright (c) 2009, Patrick Reiter Horn
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are
- *  met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name of Sirikata nor the names of its contributors may
- *    be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <util/Standard.hh>
-#include <oh/Platform.hpp>
-#include "OgreSystem.hpp"
-#include "CameraEntity.hpp"
-#include "LightEntity.hpp"
-#include "MeshEntity.hpp"
-#include "input/SDLInputManager.hpp"
-#include "DragActions.hpp"
-#include <oh/SpaceTimeOffsetManager.hpp>
-#include <task/Time.hpp>
-
-namespace Sirikata {
-namespace Graphics {
-
-using namespace Input;
-using namespace Task;
-
-
-////////////////////////////////////////////////////////////////////////////////
-// RelativeDrag
-////////////////////////////////////////////////////////////////////////////////
-
-class RelativeDrag : public ActiveDrag {
-    PointerDevicePtr mDevice;
-public:
-    RelativeDrag(const PointerDevicePtr &dev) : mDevice(dev) {
-        if (dev) {
-            mDevice->pushRelativeMode();
-        }
-    }
-    ~RelativeDrag() {
-        if (mDevice) {
-            mDevice->popRelativeMode();
-        }
-    }
-};
-
-
-////////////////////////////////////////////////////////////////////////////////
-// NullDrag
-////////////////////////////////////////////////////////////////////////////////
-
-class NullDrag : public ActiveDrag {
-public:
-    NullDrag(const DragStartInfo &info) {}
-    void mouseMoved(MouseDragEventPtr ev) {}
-};
-
-DragAction nullDragAction (ActiveDrag::factory<NullDrag>);
-
-
-////////////////////////////////////////////////////////////////////////////////
-// DragActionRegistry
-////////////////////////////////////////////////////////////////////////////////
-
-DragActionRegistry &DragActionRegistry::getSingleton() {
-    static DragActionRegistry *sSingleton = NULL;
-    if (!sSingleton) {
-        sSingleton = new DragActionRegistry;
-    }
-    return *sSingleton;
-}
-
-void DragActionRegistry::set(const std::string &name, const DragAction &obj) {
-    getSingleton().mRegistry[name] = obj;
-}
-
-void DragActionRegistry::unset(const std::string &name) {
-    std::tr1::unordered_map<std::string, DragAction>::iterator iter =
-        getSingleton().mRegistry.find(name);
-    if (iter != getSingleton().mRegistry.end()) {
-        getSingleton().mRegistry.erase(iter);
-    }
-}
-
-const DragAction &DragActionRegistry::get(const std::string &name) {
-    std::tr1::unordered_map<std::string, DragAction>::iterator iter =
-        getSingleton().mRegistry.find(name);
-    if (iter == getSingleton().mRegistry.end()) {
-        return nullDragAction;
-    }
-    return iter->second;
-}
-
-
-////////////////////////////////////////////////////////////////////////////////
-// Utilities
-////////////////////////////////////////////////////////////////////////////////
-
-void pixelToRadians(CameraEntity *cam, float deltaXPct, float deltaYPct, float &xRadians, float &yRadians) {
-    // This function is useless and hopelessly broken, since radians have no meaning in perspective. Use pixelToDirection instead!!!
-    SILOG(input,info,"FOV Y Radians: "<<cam->getOgreCamera()->getFOVy().valueRadians()<<"; aspect = "<<cam->getOgreCamera()->getAspectRatio());
-    xRadians = cam->getOgreCamera()->getFOVy().valueRadians() * cam->getOgreCamera()->getAspectRatio() * deltaXPct;
-    yRadians = cam->getOgreCamera()->getFOVy().valueRadians() * deltaYPct;
-    SILOG(input,info,"X = "<<deltaXPct<<"; Y = "<<deltaYPct);
-    SILOG(input,info,"Xradian = "<<xRadians<<"; Yradian = "<<yRadians);
-}
-// Uses perspective
-Vector3f pixelToDirection(CameraEntity *cam, Quaternion orient, float xPixel, float yPixel) {
-    float xRadian, yRadian;
-    //pixelToRadians(cam, xPixel/2, yPixel/2, xRadian, yRadian);
-    xRadian = sin(cam->getOgreCamera()->getFOVy().valueRadians()*.5) * cam->getOgreCamera()->getAspectRatio() * xPixel;
-    yRadian = sin(cam->getOgreCamera()->getFOVy().valueRadians()*.5) * yPixel;
-
-    return Vector3f(-orient.zAxis()*cos(cam->getOgreCamera()->getFOVy().valueRadians()*.5) +
-                    orient.xAxis() * xRadian +
-                    orient.yAxis() * yRadian);
-}
-
-
-void rotateCamera(CameraEntity *camera, float radianX, float radianY) {
-    Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
-
-    Quaternion orient(camera->getProxy().globalLocation(now).getOrientation());
-    Quaternion dragStart (camera->getProxy().extrapolateLocation(now).getOrientation());
-    Quaternion dhorient = Quaternion(Vector3f(0,1,0),radianX);
-    Quaternion dvorient = Quaternion(dhorient * orient * Vector3f(1,0,0),-radianY);
-
-    Location location = camera->getProxy().extrapolateLocation(now);
-    location.setOrientation((dvorient * dhorient * dragStart).normal());
-    camera->getProxy().resetLocation(now, location);
-}
-
-void panCamera(CameraEntity *camera, const Vector3d &oldLocalPosition, const Vector3d &toPan) {
-    Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
-
-    Quaternion orient(camera->getProxy().globalLocation(now).getOrientation());
-
-    Location location (camera->getProxy().extrapolateLocation(now));
-    location.setPosition(orient * toPan + oldLocalPosition);
-    camera->getProxy().resetLocation(now, location);
-}
-
-
-////////////////////////////////////////////////////////////////////////////////
-// MoveObjectDrag
-////////////////////////////////////////////////////////////////////////////////
-
-class MoveObjectDrag : public ActiveDrag {
-    std::vector<ProxyObjectWPtr> mSelectedObjects;
-    std::vector<Vector3d> mPositions;
-    CameraEntity *camera;
-    OgreSystem *mParent;
-    Vector3d mMoveVector;
-public:
-    // Constructor
-    MoveObjectDrag(const DragStartInfo &info)
-        : mSelectedObjects(info.objects.begin(), info.objects.end()) {
-        camera = info.camera;
-        mParent = info.sys;
-        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
-        float moveDistance = 0.f; // Will be reset on first foundObject
-        bool foundObject = false;
-        Location cameraLoc = camera->getProxy().globalLocation(now);
-        Vector3f cameraAxis = -cameraLoc.getOrientation().zAxis();
-        mMoveVector = Vector3d(0,0,0);
-
-        // Get initial positions for all of the objects.
-        // Find the closest one, and compute the vector to it from the camera (mMoveVector).
-        for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
-            ProxyObjectPtr obj (mSelectedObjects[i].lock());
-            if (!obj) {
-                mPositions.push_back(Vector3d(0,0,0));
-                continue;
-            }
-            mPositions.push_back(obj->extrapolateLocation(now).getPosition());
-            Vector3d deltaPosition (obj->globalLocation(now).getPosition() - cameraLoc.getPosition());
-            double dist = deltaPosition.dot(Vector3d(cameraAxis));
-            if (!foundObject || dist < moveDistance) {
-                foundObject = true;
-                moveDistance = dist;
-                mMoveVector = deltaPosition;
-            }
-        }
-        SILOG(input,insane,"moveSelection: Moving selected objects at distance " << mMoveVector);
-    }
-
-    void mouseMoved(MouseDragEventPtr ev) {
-        SILOG(input, insane,    "MOVE: mX = " << ev->mX
-                            <<      "; mY = " << ev->mY
-                            << ". mXStart = " << ev->mXStart
-                            << "; mYStart = " << ev->mYStart
-        );
-        if (mSelectedObjects.empty()) {
-            SILOG(input,insane,"moveSelection: Found no selected objects");
-            return;
-        }
-        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
-
-        Vector3d toMove(0,0,0);
-        double sensitivity = 20.0;
-        Location cameraLoc = camera->getProxy().globalLocation(now);
-        Vector3f cameraAxis = -cameraLoc.getOrientation().zAxis();
-
-        // Constrained motion, only along coordinate axes.
-        /// dbm new way: ignore camera, just move along global axes
-        if (mParent->getInputManager()->isModifierDown(Input::MOD_ALT)) sensitivity = 5.0;  // Alt cranks up the constrained speed
-        if (mParent->getInputManager()->isModifierDown(Input::MOD_SHIFT &&
-                mParent->getInputManager()->isModifierDown(Input::MOD_CTRL))) {             // Control-shift constrains to Y
-            toMove.y = ev->deltaY()*sensitivity;
-        }
-        else if (mParent->getInputManager()->isModifierDown(Input::MOD_SHIFT)) {            // Shift constrains to X
-            if (cameraAxis.z > 0) sensitivity *=-1;
-            toMove.x = ev->deltaX()*sensitivity;
-        }
-        else if (mParent->getInputManager()->isModifierDown(Input::MOD_CTRL)) {             // Control constrains to Z
-            if (cameraAxis.x < 0) sensitivity *=-1;
-            toMove.z = ev->deltaX()*sensitivity;
-        }
-
-        // Unconstrained motion.
-        else {                                                                              // Move in a plane parallel to the viewport
-            Vector3d startAxis (pixelToDirection(camera, cameraLoc.getOrientation(), ev->mXStart, ev->mYStart));    // Start direction
-            Vector3d endAxis (pixelToDirection(camera, cameraLoc.getOrientation(), ev->mX, ev->mY));                // End direction
-            Vector3d start, end;
-            float moveDistance = mMoveVector.dot(Vector3d(cameraAxis));                     // Distnce to the object in the view direction.
-            start = startAxis * moveDistance; // / cameraAxis.dot(startAxis);
-            end = endAxis * moveDistance; // / cameraAxis.dot(endAxis);
-            toMove = (end - start);                                                         // Motion vector
-            // Prevent moving outside of a small radius so you don't shoot an object into the horizon.
-            if (toMove.length() > 10*mParent->getInputManager()->mWorldScale->as<float>()) {
-                // moving too much.
-                toMove *= (10*mParent->getInputManager()->mWorldScale->as<float>()/toMove.length());
-            }
-        }
-
-        // Add the "toMove" offset to each object
-        for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
-            ProxyObjectPtr obj (mSelectedObjects[i].lock());
-            if (obj) {
-                Location toSet (obj->extrapolateLocation(now));
-                SILOG(input,debug,"moveSelection: OLD " << toSet.getPosition());
-                toSet.setPosition(mPositions[i] + toMove);
-                SILOG(input,debug,"moveSelection: NEW " << toSet.getPosition());
-                obj->setLocation(now, toSet);
-            }
-        }
-    }
-};
-DragActionRegistry::RegisterClass<MoveObjectDrag> moveobj("moveObject");
-
-
-////////////////////////////////////////////////////////////////////////////////
-// RotateObjectDrag
-////////////////////////////////////////////////////////////////////////////////
-
-class RotateObjectDrag : public ActiveDrag {
-    OgreSystem *mParent;
-    std::vector<ProxyObjectWPtr> mSelectedObjects;
-    std::vector<Quaternion > mOriginalRotation;
-    std::vector<Vector3d> mOriginalPosition;
-    CameraEntity *camera;
-public:
-    RotateObjectDrag(const DragStartInfo &info)
-            : mParent (info.sys),
-            mSelectedObjects (info.objects.begin(), info.objects.end()) {
-        camera = info.camera;
-        mOriginalRotation.reserve(mSelectedObjects.size());
-        mOriginalPosition.reserve(mSelectedObjects.size());
-        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
-        for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
-            ProxyObjectPtr obj (mSelectedObjects[i].lock());
-            if (obj) {
-                Location currentLoc = obj->extrapolateLocation(now);
-                mOriginalRotation.push_back(currentLoc.getOrientation());
-                mOriginalPosition.push_back(currentLoc.getPosition());
-            } else {
-                mOriginalRotation.push_back(Quaternion::identity());
-                mOriginalPosition.push_back(Vector3d::nil());
-            }
-        }
-    }
-    void mouseMoved(MouseDragEventPtr ev) {
-        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
-        
-        Location cameraLoc = camera->getProxy().globalLocation(now);
-        Vector3f cameraAxis = -cameraLoc.getOrientation().zAxis();
-        float radianX = 0;
-        float radianY = 0;
-        float radianZ = 0;
-        float sensitivity = 0.25;
-        Vector3d avgPos(0,0,0);
-        for (size_t i = 0; i< mSelectedObjects.size(); ++i) {
-            ProxyObjectPtr ent (mSelectedObjects[i].lock());
-            Location loc (ent->extrapolateLocation(now));
-            avgPos += loc.getPosition();
-        }
-        avgPos /= mSelectedObjects.size();
-
-        int ctlX, ctlZ;
-        if ((cameraAxis.x > 0 && cameraAxis.z > 0)
-                || (cameraAxis.x <= 0 && cameraAxis.z <= 0) ) {
-            ctlX = Input::MOD_SHIFT;
-            ctlZ = Input::MOD_CTRL;
-        }
-        else {
-            ctlX = Input::MOD_CTRL;
-            ctlZ = Input::MOD_SHIFT;
-        }
-        if (mParent->getInputManager()->isModifierDown(Input::MOD_ALT)) {
-            sensitivity = 0.1;
-        }
-        if (mParent->getInputManager()->isModifierDown(ctlX)) {
-            if (mParent->getInputManager()->isModifierDown(ctlZ)) {
-                radianZ = 3.14159 * 2 * -ev->deltaX() * sensitivity;
-            }
-            else {
-                if (cameraAxis.z > 0) sensitivity *=-1;
-            }
-            radianX = 3.14159 * 2 * -ev->deltaY() * sensitivity;
-        }
-        else if (mParent->getInputManager()->isModifierDown(ctlZ)) {
-            if (cameraAxis.x <= 0) sensitivity *=-1;
-            radianZ = 3.14159 * 2 * -ev->deltaY() * sensitivity;
-        }
-        else {
-            radianY = 3.14159 * 2 * ev->deltaX() * sensitivity;
-        }
-        Quaternion dragRotation (   Quaternion(Vector3f(1,0,0),radianX)*
-                                    Quaternion(Vector3f(0,1,0),radianY)*
-                                    Quaternion(Vector3f(0,0,1),radianZ));
-
-        for (size_t i = 0; i< mSelectedObjects.size(); ++i) {
-            ProxyObjectPtr ent (mSelectedObjects[i].lock());
-            if (!ent) continue;
-            Location loc (ent->extrapolateLocation(now));
-            Vector3d localTrans = mOriginalPosition[i] - avgPos;
-            loc.setPosition(avgPos + dragRotation*localTrans);
-            loc.setOrientation(dragRotation*mOriginalRotation[i]);
-            ent->resetLocation(now, loc);
-        }
-    }
-};
-DragActionRegistry::RegisterClass<RotateObjectDrag> rotateobj("rotateObject");
-
-
-////////////////////////////////////////////////////////////////////////////////
-// ScaleObjectDrag
-////////////////////////////////////////////////////////////////////////////////
-
-class ScaleObjectDrag : public RelativeDrag {
-    OgreSystem *mParent;
-    std::vector<ProxyObjectWPtr> mSelectedObjects;
-    float dragMultiplier;
-    std::vector<Vector3d> mOriginalPosition;
-    float mTotalScale;
-    CameraEntity *camera;
-public:
-    ScaleObjectDrag(const DragStartInfo &info)
-            : RelativeDrag(info.ev->getDevice()),
-            mParent (info.sys),
-            mSelectedObjects (info.objects.begin(), info.objects.end()),
-            mTotalScale(1.0) {
-        camera = info.camera;
-        mOriginalPosition.reserve(mSelectedObjects.size());
-        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
-        for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
-            ProxyObjectPtr obj(mSelectedObjects[i].lock());
-            Location currentLoc = obj->extrapolateLocation(now);
-            mOriginalPosition.push_back(currentLoc.getPosition());
-        }
-        dragMultiplier = mParent->getInputManager()->mDragMultiplier->as<float>();
-    }
-    void mouseMoved(MouseDragEventPtr ev) {
-        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
-        Vector3d avgPos(0,0,0);
-        if (ev->deltaLastY() != 0) {
-            float scaleamt = exp(dragMultiplier*ev->deltaLastY());
-            mTotalScale *= scaleamt;
-            int count = 0;
-            for (size_t i = 0; i< mSelectedObjects.size(); ++i) {
-                ProxyObjectPtr ent (mSelectedObjects[i].lock());
-                if (!ent) {
-                    continue;
-                }
-                Location loc (ent->extrapolateLocation(now));
-                avgPos += loc.getPosition();
-                ++count;
-            }
-            if (!count) return;
-            avgPos /= count;
-            for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
-                ProxyObjectPtr ent (mSelectedObjects[i].lock());
-                if (!ent) {
-                    continue;
-                }
-                Location loc (ent->extrapolateLocation(now));
-                Vector3d localTrans = mOriginalPosition[i] - avgPos;
-                loc.setPosition(avgPos + localTrans*mTotalScale);
-                SILOG(input, insane,   "debug avgPos: " << avgPos
-                                    << ", localTrans: " << localTrans
-                                    <<      ", scale: " << mTotalScale
-                );
-                ent->resetLocation(now, loc);
-                std::tr1::shared_ptr<ProxyMeshObject> meshptr (
-                    std::tr1::dynamic_pointer_cast<ProxyMeshObject>(ent));
-                if (meshptr) {
-                    meshptr->setScale(meshptr->getScale() * scaleamt);
-                }
-            }
-        }
-        if (ev->deltaLastX() != 0) {
-            //rotateXZ(AxisValue::fromCentered(ev->deltaLastX()));
-            //rotateCamera(mParent->mPrimaryCamera, ev->deltaLastX() * AXIS_TO_RADIANS, 0);
-        }
-    }
-};
-DragActionRegistry::RegisterClass<ScaleObjectDrag> scaleobj("scaleObject");
-
-
-////////////////////////////////////////////////////////////////////////////////
-// RotateCameraDrag
-////////////////////////////////////////////////////////////////////////////////
-
-class RotateCameraDrag : public RelativeDrag {
-    CameraEntity *camera;
-public:
-    RotateCameraDrag(const DragStartInfo &info): RelativeDrag(info.ev->getDevice()) {
-        camera = info.camera;
-    }
-    void mouseMoved(MouseDragEventPtr mouseev) {
-        float radianX, radianY;
-        pixelToRadians(camera, 2*mouseev->deltaLastX(), 2*mouseev->deltaLastY(), radianX, radianY);
-        rotateCamera(camera, radianX, radianY);
-    }
-};
-DragActionRegistry::RegisterClass<RotateCameraDrag> rotatecam("rotateCamera");
-
-
-////////////////////////////////////////////////////////////////////////////////
-// PanCameraDrag
-////////////////////////////////////////////////////////////////////////////////
-
-class PanCameraDrag : public ActiveDrag {
-    Vector3d mStartPan;
-    CameraEntity *camera;
-    bool mRelativePan;
-    double mPanDistance;
-    OgreSystem *mParent;
-    Vector3f toMove;
-public:
-    PanCameraDrag(const DragStartInfo &info) {
-        int hitCount=0;
-        camera = info.camera;
-        mParent = info.sys;
-        double distance;
-        Vector3f normal;
-        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
-        Location cameraLoc = camera->getProxy().globalLocation(now);
-        toMove = Vector3f(
-            pixelToDirection(camera, cameraLoc.getOrientation(), info.ev->mXStart, info.ev->mYStart));
-        mRelativePan = false;
-        mStartPan = camera->getProxy().extrapolateLocation(now).getPosition();
-		if (mParent->getInputManager()->isModifierDown(Input::MOD_CTRL)) {
-			float WORLD_SCALE = mParent->getInputManager()->mWorldScale->as<float>();
-            mPanDistance = WORLD_SCALE;
-		} else if (!mParent->getInputManager()->isModifierDown(Input::MOD_SHIFT) &&
-				   info.sys->rayTrace(cameraLoc.getPosition(), toMove, hitCount, distance, normal)) {
-            mPanDistance = distance;
-        } else if (!info.objects.empty()) {
-            Vector3d totalPosition(averageSelectedPosition(now, info.objects.begin(), info.objects.end()));
-
-            mPanDistance = (totalPosition - cameraLoc.getPosition()).length();
-        } else {
-            float WORLD_SCALE = mParent->getInputManager()->mWorldScale->as<float>();
-            mPanDistance = WORLD_SCALE;
-        }
-    }
-    void mouseMoved(MouseDragEventPtr ev) {
-        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
-        Location cameraLoc = camera->getProxy().globalLocation(now);
-        if (mPanDistance) {
-            float radianX, radianY;
-            pixelToRadians(camera, ev->deltaX(), ev->deltaY(), radianX, radianY);
-            panCamera(camera, mStartPan, Vector3d(-radianX*mPanDistance, -radianY*mPanDistance, 0));
-        }
-    }
-};
-DragActionRegistry::RegisterClass<PanCameraDrag> pancamera("panCamera");
-
-
-////////////////////////////////////////////////////////////////////////////////
-// ZoomCameraDrag
-////////////////////////////////////////////////////////////////////////////////
-
-void zoomInOut(Input::AxisValue value, const Input::InputDevicePtr &dev, CameraEntity *camera, const std::set<ProxyObjectWPtr>& objects, OgreSystem *parent) {
-    if (!dev) return;
-    float floatval = value.getCentered();
-    Vector2f axes(
-        dev->getAxis(Input::AXIS_CURSORX).getCentered(),
-        dev->getAxis(Input::AXIS_CURSORY).getCentered()
-    );
-    zoomInOut(floatval, axes, camera, objects, parent);
-}
-
-void zoomInOut(float value, const Vector2f& axes, CameraEntity *camera, const std::set<ProxyObjectWPtr>& objects, OgreSystem *parent) {
-    SILOG(input,debug,"zoom "<<value);
-
-    Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
-    Location cameraLoc = camera->getProxy().globalLocation(now);
-    Vector3d toMove;
-
-    toMove = Vector3d(pixelToDirection(camera, cameraLoc.getOrientation(), axes.x, axes.y));
-
-    double distance;
-    Vector3f normal;
-    float WORLD_SCALE = parent->getInputManager()->mWorldScale->as<float>();
-    int hitCount=0;
-    if (!parent->getInputManager()->isModifierDown(Input::MOD_CTRL) &&
-        !parent->getInputManager()->isModifierDown(Input::MOD_SHIFT)) {
-        toMove *= WORLD_SCALE;
-    } else if (parent->rayTrace(cameraLoc.getPosition(), direction(cameraLoc.getOrientation()), hitCount, distance, normal) &&
-               (distance*.75 < WORLD_SCALE || parent->getInputManager()->isModifierDown(Input::MOD_SHIFT))) {
-        toMove *= distance*.75;
-    } else if (!objects.empty()) {
-        Vector3d totalPosition (averageSelectedPosition(now, objects.begin(), objects.end()));
-        toMove *= (totalPosition - cameraLoc.getPosition()).length() * .75;
-    } else {
-        toMove *= WORLD_SCALE;
-    }
-    toMove *= value; // up == zoom in
-    cameraLoc.setPosition(cameraLoc.getPosition() + toMove);
-    camera->getProxy().resetLocation(now, cameraLoc);
-}
-
-class ZoomCameraDrag : public RelativeDrag {
-    OgreSystem *mParent;
-    CameraEntity *mCamera;
-    std::set<ProxyObjectWPtr> mSelection;
-public:
-    ZoomCameraDrag(const DragStartInfo &info)
-        : RelativeDrag(info.ev->getDevice()) {
-        mParent = info.sys;
-        mCamera = info.camera;
-        mSelection = info.objects;
-    }
-    void mouseMoved(MouseDragEventPtr ev) {
-        if (ev->deltaLastY() != 0) {
-            float dragMultiplier = mParent->getInputManager()->mDragMultiplier->as<float>();
-            zoomInOut(AxisValue::fromCentered(dragMultiplier*ev->deltaLastY()), ev->getDevice(), mCamera, mSelection, mParent);
-        }
-    }
-};
-DragActionRegistry::RegisterClass<ZoomCameraDrag> zoomCamera("zoomCamera");
-
-
-////////////////////////////////////////////////////////////////////////////////
-// OrbitObjectDrag
-////////////////////////////////////////////////////////////////////////////////
-
-/*
-    void orbitObject_BROKEN(AxisValue value) {
-        SILOG(input,debug,"rotate "<<value);
-
-        if (mSelectedObjects.empty()) {
-            SILOG(input,debug,"rotateXZ: Found no selected objects");
-            return;
-        }
-        CameraEntity *camera = mParent->mPrimaryCamera;
-        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
-
-        Location cameraLoc = camera->getProxy().globalLocation(now);
-        Vector3d totalPosition (averageSelectedPosition(now));
-        Vector3d distance (cameraLoc.getPosition() - totalPosition);
-
-        float radianX = value.getCentered() * 1.0;
-        Quaternion dhorient = Quaternion(Vector3f(0,1,0), radianX);
-        distance = dhorient * distance;
-        Quaternion dhorient2 = Quaternion(Vector3f(0,1,0), -radianX);
-        cameraLoc.setPosition(totalPosition + dhorient * distance);
-        cameraLoc.setOrientation(dhorient2 * cameraLoc.getOrientation());
-        camera->getProxy().resetLocation(now, cameraLoc);
-    }
-
- */
-
-class OrbitObjectDrag : public RelativeDrag {
-    OgreSystem *mParent;
-    CameraEntity *camera;
-    std::vector<ProxyObjectWPtr> mSelectedObjects;
-//    Vector3d mOrbitCenter;
-//    Vector3d mOriginalPosition;
-public:
-    OrbitObjectDrag(const DragStartInfo &info)
-        : RelativeDrag(info.ev->getDevice()),
-         mSelectedObjects(info.objects.begin(), info.objects.end()) {
-        mParent = info.sys;
-        camera = info.camera;
-    }
-    void mouseMoved(MouseDragEventPtr ev) {
-        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
-        Location cameraLoc = camera->getProxy().globalLocation(now);
-        Vector3d amount (ev->deltaX(), ev->deltaY(), 0);
-/*
-        Vector3f toMove (
-            pixelToDirection(camera, cameraLoc.getOrientation(),
-                             dev->getAxis(PointerDevice::CURSORX).getCentered(),
-                             dev->getAxis(PointerDevice::CURSORY).getCentered()));
-        if (mParent->rayTrace(cameraLoc.getPosition(), toMove, normal distance)) {
-            rotateCamera(camera, amount.x, amount.y);
-            panCamera(camera, amount * distance);
-        } else */
-        if (!mSelectedObjects.empty()) {
-            Vector3d totalPosition (averageSelectedPosition(now, mSelectedObjects.begin(), mSelectedObjects.end()));
-            double multiplier = (totalPosition - cameraLoc.getPosition()).length();
-            rotateCamera(camera, amount.x, amount.y);
-            panCamera(camera, camera->getProxy().extrapolateLocation(now).getPosition(), amount * multiplier);
-        }
-    }
-};
-
-DragActionRegistry::RegisterClass<OrbitObjectDrag> orbit("orbitObject");
-
-
-////////////////////////////////////////////////////////////////////////////////
-// Plane
-////////////////////////////////////////////////////////////////////////////////
-
-class Plane : public Vector4d {
-public:
-    // Set a plane from a vector and a point on the plane.
-    // FIXME: There should be different classes for vectors and points.
-    void set(const Vector3d &nrml, const Vector3d &point) {
-        normal() = nrml;
-        normal().normalizeThis();
-        w = -normal().dot(point);
-    }
-
-    // This interface uses a single precision normal and a double precision point.
-    void set(const Vector3f &nrml, const Vector3d &point) {
-        set(Vector3d(nrml.x, nrml.y, nrml.z), point);
-    }
-    
-    // This gets a single precision normal.
-    void getNormal(Vector3f *nrml) const {
-        nrml->x = x;
-        nrml->y = y;
-        nrml->z = z;
-    }
-
-    // Return the normal to the plane.
-    const Vector3d& normal() const {
-        return reinterpret_cast<const Vector3d&>(x);
-    }
-
-    // Move a plane in the direction of its normal.
-    void parallelTransport(double distance) {
-        w -= distance;
-    }
-    
-    // Return the distance of the point to the plane.
-    double distance(const Vector3d &point) const {
-        return x * point.x + y * point.y + z * point.z + w;
-    }
-
-    // Intersect the ray (origin, direction) with the plane and return the intersection point.
-    // We assume that the ray direction has been normalized.
-    // False is returned if the ray is parallel to the plane.
-    bool intersectRay(const Vector3d &origin, const Vector3d &direction, Vector3d *point) const {
-        double f = normal().dot(direction);
-        if (f == 0)
-            return false;   // Ray is parallel to plane, and either has no intersection or an infinity of intersections.
-        *point = origin - (direction * distance(origin) / f);
-        return true;
-    }
-
-private:    
-    // Return a mutable reference to the normal of the plane.
-    Vector3d& normal() { return reinterpret_cast<Vector3d&>(x); }
-};
-
-
-////////////////////////////////////////////////////////////////////////////////
-// MoveObjectOnWallDrag
-////////////////////////////////////////////////////////////////////////////////
-
-class MoveObjectOnWallDrag : public ActiveDrag {
-public:
-    // Constructor
-    MoveObjectOnWallDrag(const DragStartInfo &info);
-
-    // Dragger
-    void mouseMoved(MouseDragEventPtr ev);
-
-private:
-    // Return the plane of the wall, in the direction of the camera.
-    // If no wall is found, return false.
-    bool getPlaneOfWall(const Vector3d &viewDirection, Plane *plane) const;
-    
-    // Check to see if this object is in the list of those to be moved.
-    bool isObjectToBeMoved(const Entity *obj) const;
-    
-    std::vector<ProxyObjectWPtr> mSelectedObjects;
-    std::vector<Vector3d> mPositions;
-    std::vector<Quaternion> mOrientations;
-    CameraEntity *camera;
-    OgreSystem *mParent;
-    Vector3d mVectorToObject;   // Vector from the camera to the object
-    Location mCameraLocation;
-    float mDistanceFrontOfWall;  // The distance of the object from the wall.
-    Vector3d mStartPosition;
-    Quaternion mStartOrientation;
-};
-
-
-MoveObjectOnWallDrag::MoveObjectOnWallDrag(const DragStartInfo &info)
-    : mSelectedObjects(info.objects.begin(), info.objects.end())
-{
-    camera = info.camera;
-    mParent = info.sys;
-    Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
-    float distanceToObject = 0.f; // Will be reset on first foundObject
-    bool foundObject = false;
-    const float kDistanceFromWall = 10.e-2f;   // 10 cm
-    mDistanceFrontOfWall = kDistanceFromWall;
-    
-    mCameraLocation = camera->getProxy().globalLocation(now);
-    Vector3f cameraAxis = -mCameraLocation.getOrientation().zAxis();
-    mVectorToObject = Vector3d(0,0,0);
-
-    // Get initial positions for all of the objects.
-    // Find the closest one, and compute the vector to it from the camera (mVectorToObject).
-    for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
-        ProxyObjectPtr obj (mSelectedObjects[i].lock());    // This is unlocked when obj goes out of scope.
-        if (!obj) {
-            mPositions.push_back(Vector3d(0,0,0));  // FIXME: What purpose does this serve? A placeholder, maybe?
-            continue;
-        }
-        mPositions.push_back(obj->extrapolateLocation(now).getPosition());
-        mOrientations.push_back(obj->extrapolateLocation(now).getOrientation());
-        Vector3d objPosition = obj->globalLocation(now).getPosition();
-        Vector3d deltaPosition (objPosition - mCameraLocation.getPosition());
-        double dist = deltaPosition.dot(Vector3d(cameraAxis));
-        if (!foundObject || dist < distanceToObject) {
-            foundObject = true;
-            distanceToObject = dist;
-            mVectorToObject = deltaPosition;
-            mStartPosition = objPosition;
-            mStartOrientation = obj->globalLocation(now).getOrientation();
-        }
-    }
-    SILOG(input, insane, "moveSelection: Moving selected objects at distance " << mVectorToObject);
-}
-
-
-void MoveObjectOnWallDrag::mouseMoved(MouseDragEventPtr ev) {
-    if (mSelectedObjects.empty()) {
-        SILOG(input,insane,"moveSelection: Found no selected objects");
-        return;
-    }
-    Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
-    mCameraLocation = camera->getProxy().globalLocation(now); // Camera doesn't move
-    Vector3f cameraAxis = -mCameraLocation.getOrientation().zAxis();
-    Vector3d startVec(pixelToDirection(camera, mCameraLocation.getOrientation(), ev->mXStart, ev->mYStart));
-    Vector3d   endVec(pixelToDirection(camera, mCameraLocation.getOrientation(), ev->mX,      ev->mY));
-    Plane startPlane, endPlane;
-    if (!getPlaneOfWall(startVec, &startPlane)) {
-        SILOG(input, error, "MoveObjectOnWall: no start wall");
-        return;
-    }
-
-    // Compute end location
-    if (!getPlaneOfWall(endVec, &endPlane)) {
-        SILOG(input, insane, "MoveObjectOnWall: no end wall");
-        return;
-    }
-    endPlane.parallelTransport(mDistanceFrontOfWall);       // Plane where picture should lie, offset a given distance from the wall
-    Vector3d endPosition;
-    if (!endPlane.intersectRay(mCameraLocation.getPosition(), endVec, &endPosition))
-        return; // Ray is parallel to plane
-
-    // Compute translation
-    Vector3d translation = endPosition - mStartPosition;
-    
-    // Compute rotation
-    Vector3f xAxis, yAxis, zAxis;
-    endPlane.getNormal(&zAxis);
-    xAxis = Vector3f::unitY().cross(zAxis);
-    yAxis = zAxis.cross(xAxis);
-    Quaternion rotation(xAxis, yAxis, zAxis);
-    rotation = mStartOrientation.inverse() * rotation;
-
-    SILOG(input, insane,    "MOVE: mX = " << ev->mX
-                        <<      ", mY = " << ev->mY
-                        << "; mXStart = " << ev->mXStart
-                        << ", mYStart = " << ev->mYStart
-                        <<   "; trans = " << translation
-                        <<     ", rot = " << rotation
-    );
-
-    // Apply the translation and rotation to each object
-    for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
-        ProxyObjectPtr obj (mSelectedObjects[i].lock());
-        if (obj) {
-            Location toSet (obj->extrapolateLocation(now));
-            toSet.setPosition(mPositions[i] + translation);
-            toSet.setOrientation(mOrientations[i] * rotation);
-            obj->setLocation(now, toSet);
-        }
-    }
-}
-
-
-bool MoveObjectOnWallDrag::getPlaneOfWall(const Vector3d &viewDirection, Plane *plane) const {
-    Vector3d dViewPosition  =  mCameraLocation.getPosition();
-    Vector3f fViewDirection(viewDirection.x, viewDirection.y, viewDirection.z);
-    int numHits = 1, i;
-
-    for (i = 0; i < numHits; i++) {
-        double distance;        // Distance along the ray
-        Vector3f normal;
-        const Entity *obj = mParent->rayTrace(dViewPosition, fViewDirection, numHits, distance, normal, i);
-        if (obj == NULL) {      // No object found
-            if (i < numHits)    // Why not?
-                continue;       // Still more objects: keep looking
-            break;              // No more objects: return failure
-        }
-        if (!isObjectToBeMoved(obj)) {
-            Vector3d surfacePoint = dViewPosition + distance * viewDirection;
-            if (fViewDirection.dot(normal) > 0) // Normal is pointing away from the camera
-                normal = -normal;               // Get normal pointing toward the camera
-            plane->set(normal, surfacePoint);
-            return true;
-        }
-    }
-    
-    return false;
-}
-
-
-bool MoveObjectOnWallDrag::isObjectToBeMoved(const Entity *testEntity) const {
-    ProxyObjectPtr testObject(testEntity->getProxyPtr());
-    for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
-        ProxyObjectPtr obj(mSelectedObjects[i].lock());
-        if (obj && testObject.get() == obj.get())
-            return true;
-    }
-    return false;
-}
-
-
-DragActionRegistry::RegisterClass<MoveObjectOnWallDrag> moveobjectonwall("moveObjectOnWall");
-
-
-} // namespace Graphics
-} // namespace Sirikata
+/*  Sirikata liboh -- Ogre Graphics Plugin
+ *  DragActions.cpp
+ *
+ *  Copyright (c) 2009, Patrick Reiter Horn
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are
+ *  met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name of Sirikata nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <util/Standard.hh>
+#include <oh/Platform.hpp>
+#include "OgreSystem.hpp"
+#include "CameraEntity.hpp"
+#include "LightEntity.hpp"
+#include "MeshEntity.hpp"
+#include "input/SDLInputManager.hpp"
+#include "DragActions.hpp"
+#include <oh/SpaceTimeOffsetManager.hpp>
+#include <task/Time.hpp>
+
+namespace Sirikata {
+namespace Graphics {
+
+using namespace Input;
+using namespace Task;
+
+
+////////////////////////////////////////////////////////////////////////////////
+// RelativeDrag
+////////////////////////////////////////////////////////////////////////////////
+
+class RelativeDrag : public ActiveDrag {
+    PointerDevicePtr mDevice;
+public:
+    RelativeDrag(const PointerDevicePtr &dev) : mDevice(dev) {
+        if (dev) {
+            mDevice->pushRelativeMode();
+        }
+    }
+    ~RelativeDrag() {
+        if (mDevice) {
+            mDevice->popRelativeMode();
+        }
+    }
+};
+
+
+////////////////////////////////////////////////////////////////////////////////
+// NullDrag
+////////////////////////////////////////////////////////////////////////////////
+
+class NullDrag : public ActiveDrag {
+public:
+    NullDrag(const DragStartInfo &info) {}
+    void mouseMoved(MouseDragEventPtr ev) {}
+};
+
+DragAction nullDragAction (ActiveDrag::factory<NullDrag>);
+
+
+////////////////////////////////////////////////////////////////////////////////
+// DragActionRegistry
+////////////////////////////////////////////////////////////////////////////////
+
+DragActionRegistry &DragActionRegistry::getSingleton() {
+    static DragActionRegistry *sSingleton = NULL;
+    if (!sSingleton) {
+        sSingleton = new DragActionRegistry;
+    }
+    return *sSingleton;
+}
+
+void DragActionRegistry::set(const std::string &name, const DragAction &obj) {
+    getSingleton().mRegistry[name] = obj;
+}
+
+void DragActionRegistry::unset(const std::string &name) {
+    std::tr1::unordered_map<std::string, DragAction>::iterator iter =
+        getSingleton().mRegistry.find(name);
+    if (iter != getSingleton().mRegistry.end()) {
+        getSingleton().mRegistry.erase(iter);
+    }
+}
+
+const DragAction &DragActionRegistry::get(const std::string &name) {
+    std::tr1::unordered_map<std::string, DragAction>::iterator iter =
+        getSingleton().mRegistry.find(name);
+    if (iter == getSingleton().mRegistry.end()) {
+        return nullDragAction;
+    }
+    return iter->second;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// Utilities
+////////////////////////////////////////////////////////////////////////////////
+
+void pixelToRadians(CameraEntity *cam, float deltaXPct, float deltaYPct, float &xRadians, float &yRadians) {
+    // This function is useless and hopelessly broken, since radians have no meaning in perspective. Use pixelToDirection instead!!!
+    SILOG(input,info,"FOV Y Radians: "<<cam->getOgreCamera()->getFOVy().valueRadians()<<"; aspect = "<<cam->getOgreCamera()->getAspectRatio());
+    xRadians = cam->getOgreCamera()->getFOVy().valueRadians() * cam->getOgreCamera()->getAspectRatio() * deltaXPct;
+    yRadians = cam->getOgreCamera()->getFOVy().valueRadians() * deltaYPct;
+    SILOG(input,info,"X = "<<deltaXPct<<"; Y = "<<deltaYPct);
+    SILOG(input,info,"Xradian = "<<xRadians<<"; Yradian = "<<yRadians);
+}
+// Uses perspective
+Vector3f pixelToDirection(CameraEntity *cam, Quaternion orient, float xPixel, float yPixel) {
+    float xRadian, yRadian;
+    //pixelToRadians(cam, xPixel/2, yPixel/2, xRadian, yRadian);
+    xRadian = sin(cam->getOgreCamera()->getFOVy().valueRadians()*.5) * cam->getOgreCamera()->getAspectRatio() * xPixel;
+    yRadian = sin(cam->getOgreCamera()->getFOVy().valueRadians()*.5) * yPixel;
+
+    return Vector3f(-orient.zAxis()*cos(cam->getOgreCamera()->getFOVy().valueRadians()*.5) +
+                    orient.xAxis() * xRadian +
+                    orient.yAxis() * yRadian);
+}
+
+
+void rotateCamera(CameraEntity *camera, float radianX, float radianY) {
+    Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
+
+    Quaternion orient(camera->getProxy().globalLocation(now).getOrientation());
+    Quaternion dragStart (camera->getProxy().extrapolateLocation(now).getOrientation());
+    Quaternion dhorient = Quaternion(Vector3f(0,1,0),radianX);
+    Quaternion dvorient = Quaternion(dhorient * orient * Vector3f(1,0,0),-radianY);
+
+    Location location = camera->getProxy().extrapolateLocation(now);
+    location.setOrientation((dvorient * dhorient * dragStart).normal());
+    camera->getProxy().resetLocation(now, location);
+}
+
+void panCamera(CameraEntity *camera, const Vector3d &oldLocalPosition, const Vector3d &toPan) {
+    Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
+
+    Quaternion orient(camera->getProxy().globalLocation(now).getOrientation());
+
+    Location location (camera->getProxy().extrapolateLocation(now));
+    location.setPosition(orient * toPan + oldLocalPosition);
+    camera->getProxy().resetLocation(now, location);
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// MoveObjectDrag
+////////////////////////////////////////////////////////////////////////////////
+
+class MoveObjectDrag : public ActiveDrag {
+    std::vector<ProxyObjectWPtr> mSelectedObjects;
+    std::vector<Vector3d> mPositions;
+    CameraEntity *camera;
+    OgreSystem *mParent;
+    Vector3d mMoveVector;
+public:
+    // Constructor
+    MoveObjectDrag(const DragStartInfo &info)
+        : mSelectedObjects(info.objects.begin(), info.objects.end()) {
+        camera = info.camera;
+        mParent = info.sys;
+        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
+        float moveDistance = 0.f; // Will be reset on first foundObject
+        bool foundObject = false;
+        Location cameraLoc = camera->getProxy().globalLocation(now);
+        Vector3f cameraAxis = -cameraLoc.getOrientation().zAxis();
+        mMoveVector = Vector3d(0,0,0);
+
+        // Get initial positions for all of the objects.
+        // Find the closest one, and compute the vector to it from the camera (mMoveVector).
+        for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
+            ProxyObjectPtr obj (mSelectedObjects[i].lock());
+            if (!obj) {
+                mPositions.push_back(Vector3d(0,0,0));
+                continue;
+            }
+            mPositions.push_back(obj->extrapolateLocation(now).getPosition());
+            Vector3d deltaPosition (obj->globalLocation(now).getPosition() - cameraLoc.getPosition());
+            double dist = deltaPosition.dot(Vector3d(cameraAxis));
+            if (!foundObject || dist < moveDistance) {
+                foundObject = true;
+                moveDistance = dist;
+                mMoveVector = deltaPosition;
+            }
+        }
+        SILOG(input,insane,"moveSelection: Moving selected objects at distance " << mMoveVector);
+    }
+
+    void mouseMoved(MouseDragEventPtr ev) {
+        SILOG(input, insane,    "MOVE: mX = " << ev->mX
+                            <<      "; mY = " << ev->mY
+                            << ". mXStart = " << ev->mXStart
+                            << "; mYStart = " << ev->mYStart
+        );
+        if (mSelectedObjects.empty()) {
+            SILOG(input,insane,"moveSelection: Found no selected objects");
+            return;
+        }
+        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
+
+        Vector3d toMove(0,0,0);
+        double sensitivity = 20.0;
+        Location cameraLoc = camera->getProxy().globalLocation(now);
+        Vector3f cameraAxis = -cameraLoc.getOrientation().zAxis();
+
+        // Constrained motion, only along coordinate axes.
+        /// dbm new way: ignore camera, just move along global axes
+        if (mParent->getInputManager()->isModifierDown(Input::MOD_ALT)) sensitivity = 5.0;  // Alt cranks up the constrained speed
+        if (mParent->getInputManager()->isModifierDown(Input::MOD_SHIFT &&
+                mParent->getInputManager()->isModifierDown(Input::MOD_CTRL))) {             // Control-shift constrains to Y
+            toMove.y = ev->deltaY()*sensitivity;
+        }
+        else if (mParent->getInputManager()->isModifierDown(Input::MOD_SHIFT)) {            // Shift constrains to X
+            if (cameraAxis.z > 0) sensitivity *=-1;
+            toMove.x = ev->deltaX()*sensitivity;
+        }
+        else if (mParent->getInputManager()->isModifierDown(Input::MOD_CTRL)) {             // Control constrains to Z
+            if (cameraAxis.x < 0) sensitivity *=-1;
+            toMove.z = ev->deltaX()*sensitivity;
+        }
+
+        // Unconstrained motion.
+        else {                                                                              // Move in a plane parallel to the viewport
+            Vector3d startAxis (pixelToDirection(camera, cameraLoc.getOrientation(), ev->mXStart, ev->mYStart));    // Start direction
+            Vector3d endAxis (pixelToDirection(camera, cameraLoc.getOrientation(), ev->mX, ev->mY));                // End direction
+            Vector3d start, end;
+            float moveDistance = mMoveVector.dot(Vector3d(cameraAxis));                     // Distnce to the object in the view direction.
+            start = startAxis * moveDistance; // / cameraAxis.dot(startAxis);
+            end = endAxis * moveDistance; // / cameraAxis.dot(endAxis);
+            toMove = (end - start);                                                         // Motion vector
+            // Prevent moving outside of a small radius so you don't shoot an object into the horizon.
+            if (toMove.length() > 10*mParent->getInputManager()->mWorldScale->as<float>()) {
+                // moving too much.
+                toMove *= (10*mParent->getInputManager()->mWorldScale->as<float>()/toMove.length());
+            }
+        }
+
+        // Add the "toMove" offset to each object
+        for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
+            ProxyObjectPtr obj (mSelectedObjects[i].lock());
+            if (obj) {
+                Location toSet (obj->extrapolateLocation(now));
+                SILOG(input,debug,"moveSelection: OLD " << toSet.getPosition());
+                toSet.setPosition(mPositions[i] + toMove);
+                SILOG(input,debug,"moveSelection: NEW " << toSet.getPosition());
+                obj->setLocation(now, toSet);
+            }
+        }
+    }
+};
+DragActionRegistry::RegisterClass<MoveObjectDrag> moveobj("moveObject");
+
+
+////////////////////////////////////////////////////////////////////////////////
+// RotateObjectDrag
+////////////////////////////////////////////////////////////////////////////////
+
+class RotateObjectDrag : public ActiveDrag {
+    OgreSystem *mParent;
+    std::vector<ProxyObjectWPtr> mSelectedObjects;
+    std::vector<Quaternion > mOriginalRotation;
+    std::vector<Vector3d> mOriginalPosition;
+    CameraEntity *camera;
+public:
+    RotateObjectDrag(const DragStartInfo &info)
+            : mParent (info.sys),
+            mSelectedObjects (info.objects.begin(), info.objects.end()) {
+        camera = info.camera;
+        mOriginalRotation.reserve(mSelectedObjects.size());
+        mOriginalPosition.reserve(mSelectedObjects.size());
+        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
+        for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
+            ProxyObjectPtr obj (mSelectedObjects[i].lock());
+            if (obj) {
+                Location currentLoc = obj->extrapolateLocation(now);
+                mOriginalRotation.push_back(currentLoc.getOrientation());
+                mOriginalPosition.push_back(currentLoc.getPosition());
+            } else {
+                mOriginalRotation.push_back(Quaternion::identity());
+                mOriginalPosition.push_back(Vector3d::nil());
+            }
+        }
+    }
+    void mouseMoved(MouseDragEventPtr ev) {
+        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
+        
+        Location cameraLoc = camera->getProxy().globalLocation(now);
+        Vector3f cameraAxis = -cameraLoc.getOrientation().zAxis();
+        float radianX = 0;
+        float radianY = 0;
+        float radianZ = 0;
+        float sensitivity = 0.25;
+        Vector3d avgPos(0,0,0);
+        for (size_t i = 0; i< mSelectedObjects.size(); ++i) {
+            ProxyObjectPtr ent (mSelectedObjects[i].lock());
+            Location loc (ent->extrapolateLocation(now));
+            avgPos += loc.getPosition();
+        }
+        avgPos /= mSelectedObjects.size();
+
+        int ctlX, ctlZ;
+        if ((cameraAxis.x > 0 && cameraAxis.z > 0)
+                || (cameraAxis.x <= 0 && cameraAxis.z <= 0) ) {
+            ctlX = Input::MOD_SHIFT;
+            ctlZ = Input::MOD_CTRL;
+        }
+        else {
+            ctlX = Input::MOD_CTRL;
+            ctlZ = Input::MOD_SHIFT;
+        }
+        if (mParent->getInputManager()->isModifierDown(Input::MOD_ALT)) {
+            sensitivity = 0.1;
+        }
+        if (mParent->getInputManager()->isModifierDown(ctlX)) {
+            if (mParent->getInputManager()->isModifierDown(ctlZ)) {
+                radianZ = 3.14159 * 2 * -ev->deltaX() * sensitivity;
+            }
+            else {
+                if (cameraAxis.z > 0) sensitivity *=-1;
+            }
+            radianX = 3.14159 * 2 * -ev->deltaY() * sensitivity;
+        }
+        else if (mParent->getInputManager()->isModifierDown(ctlZ)) {
+            if (cameraAxis.x <= 0) sensitivity *=-1;
+            radianZ = 3.14159 * 2 * -ev->deltaY() * sensitivity;
+        }
+        else {
+            radianY = 3.14159 * 2 * ev->deltaX() * sensitivity;
+        }
+        Quaternion dragRotation (   Quaternion(Vector3f(1,0,0),radianX)*
+                                    Quaternion(Vector3f(0,1,0),radianY)*
+                                    Quaternion(Vector3f(0,0,1),radianZ));
+
+        for (size_t i = 0; i< mSelectedObjects.size(); ++i) {
+            ProxyObjectPtr ent (mSelectedObjects[i].lock());
+            if (!ent) continue;
+            Location loc (ent->extrapolateLocation(now));
+            Vector3d localTrans = mOriginalPosition[i] - avgPos;
+            loc.setPosition(avgPos + dragRotation*localTrans);
+            loc.setOrientation(dragRotation*mOriginalRotation[i]);
+            ent->resetLocation(now, loc);
+        }
+    }
+};
+DragActionRegistry::RegisterClass<RotateObjectDrag> rotateobj("rotateObject");
+
+
+////////////////////////////////////////////////////////////////////////////////
+// ScaleObjectDrag
+////////////////////////////////////////////////////////////////////////////////
+
+class ScaleObjectDrag : public RelativeDrag {
+    OgreSystem *mParent;
+    std::vector<ProxyObjectWPtr> mSelectedObjects;
+    float dragMultiplier;
+    std::vector<Vector3d> mOriginalPosition;
+    float mTotalScale;
+    CameraEntity *camera;
+public:
+    ScaleObjectDrag(const DragStartInfo &info)
+            : RelativeDrag(info.ev->getDevice()),
+            mParent (info.sys),
+            mSelectedObjects (info.objects.begin(), info.objects.end()),
+            mTotalScale(1.0) {
+        camera = info.camera;
+        mOriginalPosition.reserve(mSelectedObjects.size());
+        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
+        for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
+            ProxyObjectPtr obj(mSelectedObjects[i].lock());
+            Location currentLoc = obj->extrapolateLocation(now);
+            mOriginalPosition.push_back(currentLoc.getPosition());
+        }
+        dragMultiplier = mParent->getInputManager()->mDragMultiplier->as<float>();
+    }
+    void mouseMoved(MouseDragEventPtr ev) {
+        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
+        Vector3d avgPos(0,0,0);
+        if (ev->deltaLastY() != 0) {
+            float scaleamt = exp(dragMultiplier*ev->deltaLastY());
+            mTotalScale *= scaleamt;
+            int count = 0;
+            for (size_t i = 0; i< mSelectedObjects.size(); ++i) {
+                ProxyObjectPtr ent (mSelectedObjects[i].lock());
+                if (!ent) {
+                    continue;
+                }
+                Location loc (ent->extrapolateLocation(now));
+                avgPos += loc.getPosition();
+                ++count;
+            }
+            if (!count) return;
+            avgPos /= count;
+            for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
+                ProxyObjectPtr ent (mSelectedObjects[i].lock());
+                if (!ent) {
+                    continue;
+                }
+                Location loc (ent->extrapolateLocation(now));
+                Vector3d localTrans = mOriginalPosition[i] - avgPos;
+                loc.setPosition(avgPos + localTrans*mTotalScale);
+                SILOG(input, insane,   "debug avgPos: " << avgPos
+                                    << ", localTrans: " << localTrans
+                                    <<      ", scale: " << mTotalScale
+                );
+                ent->resetLocation(now, loc);
+                std::tr1::shared_ptr<ProxyMeshObject> meshptr (
+                    std::tr1::dynamic_pointer_cast<ProxyMeshObject>(ent));
+                if (meshptr) {
+                    meshptr->setScale(meshptr->getScale() * scaleamt);
+                }
+            }
+        }
+        if (ev->deltaLastX() != 0) {
+            //rotateXZ(AxisValue::fromCentered(ev->deltaLastX()));
+            //rotateCamera(mParent->mPrimaryCamera, ev->deltaLastX() * AXIS_TO_RADIANS, 0);
+        }
+    }
+};
+DragActionRegistry::RegisterClass<ScaleObjectDrag> scaleobj("scaleObject");
+
+
+////////////////////////////////////////////////////////////////////////////////
+// RotateCameraDrag
+////////////////////////////////////////////////////////////////////////////////
+
+class RotateCameraDrag : public RelativeDrag {
+    CameraEntity *camera;
+public:
+    RotateCameraDrag(const DragStartInfo &info): RelativeDrag(info.ev->getDevice()) {
+        camera = info.camera;
+    }
+    void mouseMoved(MouseDragEventPtr mouseev) {
+        float radianX, radianY;
+        pixelToRadians(camera, 2*mouseev->deltaLastX(), 2*mouseev->deltaLastY(), radianX, radianY);
+        rotateCamera(camera, radianX, radianY);
+    }
+};
+DragActionRegistry::RegisterClass<RotateCameraDrag> rotatecam("rotateCamera");
+
+
+////////////////////////////////////////////////////////////////////////////////
+// PanCameraDrag
+////////////////////////////////////////////////////////////////////////////////
+
+class PanCameraDrag : public ActiveDrag {
+    Vector3d mStartPan;
+    CameraEntity *camera;
+    bool mRelativePan;
+    double mPanDistance;
+    OgreSystem *mParent;
+    Vector3f toMove;
+public:
+    PanCameraDrag(const DragStartInfo &info) {
+        int hitCount=0;
+        camera = info.camera;
+        mParent = info.sys;
+        double distance;
+        Vector3f normal;
+        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
+        Location cameraLoc = camera->getProxy().globalLocation(now);
+        toMove = Vector3f(
+            pixelToDirection(camera, cameraLoc.getOrientation(), info.ev->mXStart, info.ev->mYStart));
+        mRelativePan = false;
+        mStartPan = camera->getProxy().extrapolateLocation(now).getPosition();
+		if (mParent->getInputManager()->isModifierDown(Input::MOD_CTRL)) {
+			float WORLD_SCALE = mParent->getInputManager()->mWorldScale->as<float>();
+            mPanDistance = WORLD_SCALE;
+		} else if (!mParent->getInputManager()->isModifierDown(Input::MOD_SHIFT) &&
+				   info.sys->rayTrace(cameraLoc.getPosition(), toMove, hitCount, distance, normal)) {
+            mPanDistance = distance;
+        } else if (!info.objects.empty()) {
+            Vector3d totalPosition(averageSelectedPosition(now, info.objects.begin(), info.objects.end()));
+
+            mPanDistance = (totalPosition - cameraLoc.getPosition()).length();
+        } else {
+            float WORLD_SCALE = mParent->getInputManager()->mWorldScale->as<float>();
+            mPanDistance = WORLD_SCALE;
+        }
+    }
+    void mouseMoved(MouseDragEventPtr ev) {
+        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
+        Location cameraLoc = camera->getProxy().globalLocation(now);
+        if (mPanDistance) {
+            float radianX, radianY;
+            pixelToRadians(camera, ev->deltaX(), ev->deltaY(), radianX, radianY);
+            panCamera(camera, mStartPan, Vector3d(-radianX*mPanDistance, -radianY*mPanDistance, 0));
+        }
+    }
+};
+DragActionRegistry::RegisterClass<PanCameraDrag> pancamera("panCamera");
+
+
+////////////////////////////////////////////////////////////////////////////////
+// ZoomCameraDrag
+////////////////////////////////////////////////////////////////////////////////
+
+void zoomInOut(Input::AxisValue value, const Input::InputDevicePtr &dev, CameraEntity *camera, const std::set<ProxyObjectWPtr>& objects, OgreSystem *parent) {
+    if (!dev) return;
+    float floatval = value.getCentered();
+    Vector2f axes(
+        dev->getAxis(Input::AXIS_CURSORX).getCentered(),
+        dev->getAxis(Input::AXIS_CURSORY).getCentered()
+    );
+    zoomInOut(floatval, axes, camera, objects, parent);
+}
+
+void zoomInOut(float value, const Vector2f& axes, CameraEntity *camera, const std::set<ProxyObjectWPtr>& objects, OgreSystem *parent) {
+    SILOG(input,debug,"zoom "<<value);
+
+    Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
+    Location cameraLoc = camera->getProxy().globalLocation(now);
+    Vector3d toMove;
+
+    toMove = Vector3d(pixelToDirection(camera, cameraLoc.getOrientation(), axes.x, axes.y));
+
+    double distance;
+    Vector3f normal;
+    float WORLD_SCALE = parent->getInputManager()->mWorldScale->as<float>();
+    int hitCount=0;
+    if (!parent->getInputManager()->isModifierDown(Input::MOD_CTRL) &&
+        !parent->getInputManager()->isModifierDown(Input::MOD_SHIFT)) {
+        toMove *= WORLD_SCALE;
+    } else if (parent->rayTrace(cameraLoc.getPosition(), direction(cameraLoc.getOrientation()), hitCount, distance, normal) &&
+               (distance*.75 < WORLD_SCALE || parent->getInputManager()->isModifierDown(Input::MOD_SHIFT))) {
+        toMove *= distance*.75;
+    } else if (!objects.empty()) {
+        Vector3d totalPosition (averageSelectedPosition(now, objects.begin(), objects.end()));
+        toMove *= (totalPosition - cameraLoc.getPosition()).length() * .75;
+    } else {
+        toMove *= WORLD_SCALE;
+    }
+    toMove *= value; // up == zoom in
+    cameraLoc.setPosition(cameraLoc.getPosition() + toMove);
+    camera->getProxy().resetLocation(now, cameraLoc);
+}
+
+class ZoomCameraDrag : public RelativeDrag {
+    OgreSystem *mParent;
+    CameraEntity *mCamera;
+    std::set<ProxyObjectWPtr> mSelection;
+public:
+    ZoomCameraDrag(const DragStartInfo &info)
+        : RelativeDrag(info.ev->getDevice()) {
+        mParent = info.sys;
+        mCamera = info.camera;
+        mSelection = info.objects;
+    }
+    void mouseMoved(MouseDragEventPtr ev) {
+        if (ev->deltaLastY() != 0) {
+            float dragMultiplier = mParent->getInputManager()->mDragMultiplier->as<float>();
+            zoomInOut(AxisValue::fromCentered(dragMultiplier*ev->deltaLastY()), ev->getDevice(), mCamera, mSelection, mParent);
+        }
+    }
+};
+DragActionRegistry::RegisterClass<ZoomCameraDrag> zoomCamera("zoomCamera");
+
+
+////////////////////////////////////////////////////////////////////////////////
+// OrbitObjectDrag
+////////////////////////////////////////////////////////////////////////////////
+
+/*
+    void orbitObject_BROKEN(AxisValue value) {
+        SILOG(input,debug,"rotate "<<value);
+
+        if (mSelectedObjects.empty()) {
+            SILOG(input,debug,"rotateXZ: Found no selected objects");
+            return;
+        }
+        CameraEntity *camera = mParent->mPrimaryCamera;
+        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
+
+        Location cameraLoc = camera->getProxy().globalLocation(now);
+        Vector3d totalPosition (averageSelectedPosition(now));
+        Vector3d distance (cameraLoc.getPosition() - totalPosition);
+
+        float radianX = value.getCentered() * 1.0;
+        Quaternion dhorient = Quaternion(Vector3f(0,1,0), radianX);
+        distance = dhorient * distance;
+        Quaternion dhorient2 = Quaternion(Vector3f(0,1,0), -radianX);
+        cameraLoc.setPosition(totalPosition + dhorient * distance);
+        cameraLoc.setOrientation(dhorient2 * cameraLoc.getOrientation());
+        camera->getProxy().resetLocation(now, cameraLoc);
+    }
+
+ */
+
+class OrbitObjectDrag : public RelativeDrag {
+    OgreSystem *mParent;
+    CameraEntity *camera;
+    std::vector<ProxyObjectWPtr> mSelectedObjects;
+//    Vector3d mOrbitCenter;
+//    Vector3d mOriginalPosition;
+public:
+    OrbitObjectDrag(const DragStartInfo &info)
+        : RelativeDrag(info.ev->getDevice()),
+         mSelectedObjects(info.objects.begin(), info.objects.end()) {
+        mParent = info.sys;
+        camera = info.camera;
+    }
+    void mouseMoved(MouseDragEventPtr ev) {
+        Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
+        Location cameraLoc = camera->getProxy().globalLocation(now);
+        Vector3d amount (ev->deltaX(), ev->deltaY(), 0);
+/*
+        Vector3f toMove (
+            pixelToDirection(camera, cameraLoc.getOrientation(),
+                             dev->getAxis(PointerDevice::CURSORX).getCentered(),
+                             dev->getAxis(PointerDevice::CURSORY).getCentered()));
+        if (mParent->rayTrace(cameraLoc.getPosition(), toMove, normal distance)) {
+            rotateCamera(camera, amount.x, amount.y);
+            panCamera(camera, amount * distance);
+        } else */
+        if (!mSelectedObjects.empty()) {
+            Vector3d totalPosition (averageSelectedPosition(now, mSelectedObjects.begin(), mSelectedObjects.end()));
+            double multiplier = (totalPosition - cameraLoc.getPosition()).length();
+            rotateCamera(camera, amount.x, amount.y);
+            panCamera(camera, camera->getProxy().extrapolateLocation(now).getPosition(), amount * multiplier);
+        }
+    }
+};
+
+DragActionRegistry::RegisterClass<OrbitObjectDrag> orbit("orbitObject");
+
+
+////////////////////////////////////////////////////////////////////////////////
+// Plane
+////////////////////////////////////////////////////////////////////////////////
+
+class Plane : public Vector4d {
+public:
+    // Set a plane from a vector and a point on the plane.
+    // FIXME: There should be different classes for vectors and points.
+    void set(const Vector3d &nrml, const Vector3d &point) {
+        normal() = nrml;
+        normal().normalizeThis();
+        w = -normal().dot(point);
+    }
+
+    // This interface uses a single precision normal and a double precision point.
+    void set(const Vector3f &nrml, const Vector3d &point) {
+        set(Vector3d(nrml.x, nrml.y, nrml.z), point);
+    }
+    
+    // This gets a single precision normal.
+    void getNormal(Vector3f *nrml) const {
+        nrml->x = x;
+        nrml->y = y;
+        nrml->z = z;
+    }
+
+    // Return the normal to the plane.
+    const Vector3d& normal() const {
+        return reinterpret_cast<const Vector3d&>(x);
+    }
+
+    // Move a plane in the direction of its normal.
+    void parallelTransport(double distance) {
+        w -= distance;
+    }
+    
+    // Return the distance of the point to the plane.
+    double distance(const Vector3d &point) const {
+        return x * point.x + y * point.y + z * point.z + w;
+    }
+
+    // Intersect the ray (origin, direction) with the plane and return the intersection point.
+    // We assume that the ray direction has been normalized.
+    // False is returned if the ray is parallel to the plane.
+    bool intersectRay(const Vector3d &origin, const Vector3d &direction, Vector3d *point) const {
+        double f = normal().dot(direction);
+        if (f == 0)
+            return false;   // Ray is parallel to plane, and either has no intersection or an infinity of intersections.
+        *point = origin - (direction * distance(origin) / f);
+        return true;
+    }
+
+private:    
+    // Return a mutable reference to the normal of the plane.
+    Vector3d& normal() { return reinterpret_cast<Vector3d&>(x); }
+};
+
+
+////////////////////////////////////////////////////////////////////////////////
+// MoveObjectOnWallDrag
+////////////////////////////////////////////////////////////////////////////////
+
+class MoveObjectOnWallDrag : public ActiveDrag {
+public:
+    // Constructor
+    MoveObjectOnWallDrag(const DragStartInfo &info);
+
+    // Dragger
+    void mouseMoved(MouseDragEventPtr ev);
+
+private:
+    // Return the plane of the wall, in the direction of the camera.
+    // If no wall is found, return false.
+    bool getPlaneOfWall(const Vector3d &viewDirection, Plane *plane) const;
+    
+    // Check to see if this object is in the list of those to be moved.
+    bool isObjectToBeMoved(const Entity *obj) const;
+    
+    std::vector<ProxyObjectWPtr> mSelectedObjects;
+    std::vector<Vector3d> mPositions;
+    std::vector<Quaternion> mOrientations;
+    CameraEntity *camera;
+    OgreSystem *mParent;
+    Vector3d mVectorToObject;   // Vector from the camera to the object
+    Location mCameraLocation;
+    float mDistanceFrontOfWall;  // The distance of the object from the wall.
+    Vector3d mStartPosition;
+    Quaternion mStartOrientation;
+};
+
+
+MoveObjectOnWallDrag::MoveObjectOnWallDrag(const DragStartInfo &info)
+    : mSelectedObjects(info.objects.begin(), info.objects.end())
+{
+    camera = info.camera;
+    mParent = info.sys;
+    Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
+    float distanceToObject = 0.f; // Will be reset on first foundObject
+    bool foundObject = false;
+    const float kDistanceFromWall = 10.e-2f;   // 10 cm
+    mDistanceFrontOfWall = kDistanceFromWall;
+    
+    mCameraLocation = camera->getProxy().globalLocation(now);
+    Vector3f cameraAxis = -mCameraLocation.getOrientation().zAxis();
+    mVectorToObject = Vector3d(0,0,0);
+
+    // Get initial positions for all of the objects.
+    // Find the closest one, and compute the vector to it from the camera (mVectorToObject).
+    for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
+        ProxyObjectPtr obj (mSelectedObjects[i].lock());    // This is unlocked when obj goes out of scope.
+        if (!obj) {
+            mPositions.push_back(Vector3d(0,0,0));  // FIXME: What purpose does this serve? A placeholder, maybe?
+            continue;
+        }
+        mPositions.push_back(obj->extrapolateLocation(now).getPosition());
+        mOrientations.push_back(obj->extrapolateLocation(now).getOrientation());
+        Vector3d objPosition = obj->globalLocation(now).getPosition();
+        Vector3d deltaPosition (objPosition - mCameraLocation.getPosition());
+        double dist = deltaPosition.dot(Vector3d(cameraAxis));
+        if (!foundObject || dist < distanceToObject) {
+            foundObject = true;
+            distanceToObject = dist;
+            mVectorToObject = deltaPosition;
+            mStartPosition = objPosition;
+            mStartOrientation = obj->globalLocation(now).getOrientation();
+        }
+    }
+    SILOG(input, insane, "moveSelection: Moving selected objects at distance " << mVectorToObject);
+}
+
+
+void MoveObjectOnWallDrag::mouseMoved(MouseDragEventPtr ev) {
+    if (mSelectedObjects.empty()) {
+        SILOG(input,insane,"moveSelection: Found no selected objects");
+        return;
+    }
+    Time now = SpaceTimeOffsetManager::getSingleton().now(camera->getProxy().getObjectReference().space());
+    mCameraLocation = camera->getProxy().globalLocation(now); // Camera doesn't move
+    Vector3f cameraAxis = -mCameraLocation.getOrientation().zAxis();
+    Vector3d startVec(pixelToDirection(camera, mCameraLocation.getOrientation(), ev->mXStart, ev->mYStart));
+    Vector3d   endVec(pixelToDirection(camera, mCameraLocation.getOrientation(), ev->mX,      ev->mY));
+    Plane startPlane, endPlane;
+    if (!getPlaneOfWall(startVec, &startPlane)) {
+        SILOG(input, error, "MoveObjectOnWall: no start wall");
+        return;
+    }
+
+    // Compute end location
+    if (!getPlaneOfWall(endVec, &endPlane)) {
+        SILOG(input, insane, "MoveObjectOnWall: no end wall");
+        return;
+    }
+    endPlane.parallelTransport(mDistanceFrontOfWall);       // Plane where picture should lie, offset a given distance from the wall
+    Vector3d endPosition;
+    if (!endPlane.intersectRay(mCameraLocation.getPosition(), endVec, &endPosition))
+        return; // Ray is parallel to plane
+
+    // Compute translation
+    Vector3d translation = endPosition - mStartPosition;
+    
+    // Compute rotation
+    Vector3f xAxis, yAxis, zAxis;
+    endPlane.getNormal(&zAxis);
+    xAxis = Vector3f::unitY().cross(zAxis);
+    yAxis = zAxis.cross(xAxis);
+    Quaternion rotation(xAxis, yAxis, zAxis);
+    rotation = mStartOrientation.inverse() * rotation;
+
+    SILOG(input, insane,    "MOVE: mX = " << ev->mX
+                        <<      ", mY = " << ev->mY
+                        << "; mXStart = " << ev->mXStart
+                        << ", mYStart = " << ev->mYStart
+                        <<   "; trans = " << translation
+                        <<     ", rot = " << rotation
+    );
+
+    // Apply the translation and rotation to each object
+    for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
+        ProxyObjectPtr obj (mSelectedObjects[i].lock());
+        if (obj) {
+            Location toSet (obj->extrapolateLocation(now));
+            toSet.setPosition(mPositions[i] + translation);
+            toSet.setOrientation(mOrientations[i] * rotation);
+            obj->setLocation(now, toSet);
+        }
+    }
+}
+
+
+bool MoveObjectOnWallDrag::getPlaneOfWall(const Vector3d &viewDirection, Plane *plane) const {
+    Vector3d dViewPosition  =  mCameraLocation.getPosition();
+    Vector3f fViewDirection(viewDirection.x, viewDirection.y, viewDirection.z);
+    int numHits = 1, i;
+
+    for (i = 0; i < numHits; i++) {
+        double distance;        // Distance along the ray
+        Vector3f normal;
+        const Entity *obj = mParent->rayTrace(dViewPosition, fViewDirection, numHits, distance, normal, i);
+        if (obj == NULL) {      // No object found
+            if (i < numHits)    // Why not?
+                continue;       // Still more objects: keep looking
+            break;              // No more objects: return failure
+        }
+        if (!isObjectToBeMoved(obj)) {
+            Vector3d surfacePoint = dViewPosition + distance * viewDirection;
+            if (fViewDirection.dot(normal) > 0) // Normal is pointing away from the camera
+                normal = -normal;               // Get normal pointing toward the camera
+            plane->set(normal, surfacePoint);
+            return true;
+        }
+    }
+    
+    return false;
+}
+
+
+bool MoveObjectOnWallDrag::isObjectToBeMoved(const Entity *testEntity) const {
+    ProxyObjectPtr testObject(testEntity->getProxyPtr());
+    for (size_t i = 0; i < mSelectedObjects.size(); ++i) {
+        ProxyObjectPtr obj(mSelectedObjects[i].lock());
+        if (obj && testObject.get() == obj.get())
+            return true;
+    }
+    return false;
+}
+
+
+DragActionRegistry::RegisterClass<MoveObjectOnWallDrag> moveobjectonwall("moveObjectOnWall");
+
+
+} // namespace Graphics
+} // namespace Sirikata
diff --git a/liboh/plugins/ogre/Entity.cpp b/liboh/plugins/ogre/Entity.cpp
index 0ccd5fb..58db462 100644
--- a/liboh/plugins/ogre/Entity.cpp
+++ b/liboh/plugins/ogre/Entity.cpp
@@ -1,190 +1,190 @@
-/*  Sirikata Graphical Object Host
- *  Entity.cpp
- *
- *  Copyright (c) 2009, Patrick Reiter Horn
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are
- *  met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name of Sirikata nor the names of its contributors may
- *    be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <oh/Platform.hpp>
-#include "Entity.hpp"
-#include <options/Options.hpp>
-
-namespace Sirikata {
-namespace Graphics {
-
-Entity::Entity(OgreSystem *scene,
-               const ProxyObjectPtr &ppo,
-               const std::string &ogreId,
-               Ogre::MovableObject *obj)
-  : mScene(scene),
-    mProxy(ppo),
-    mOgreObject(NULL),
-    mSceneNode(scene->getSceneManager()->createSceneNode(ogreId)),
-    mMovingIter(scene->mMovingEntities.end())
-{
-    mSceneNode->setInheritScale(false);
-    addToScene(NULL);
-    if (obj) {
-        init(obj);
-    }
-    bool successful = scene->mSceneEntities.insert(
-        OgreSystem::SceneEntitiesMap::value_type(mProxy->getObjectReference(), this)).second;
-
-    assert (successful == true);
-
-    ppo->ProxyObjectProvider::addListener(this);
-    ppo->PositionProvider::addListener(this);
-}
-
-Entity::~Entity() {
-    OgreSystem::SceneEntitiesMap::iterator iter =
-        mScene->mSceneEntities.find(mProxy->getObjectReference());
-    if (iter != mScene->mSceneEntities.end()) {
-        // will fail while in the OgreSystem destructor.
-        mScene->mSceneEntities.erase(iter);
-    }
-    if (mMovingIter != mScene->mMovingEntities.end()) {
-        mScene->mMovingEntities.erase(mMovingIter);
-        mMovingIter = mScene->mMovingEntities.end();
-    }
-    getProxy().ProxyObjectProvider::removeListener(this);
-    getProxy().PositionProvider::removeListener(this);
-    removeFromScene();
-    init(NULL);
-    mSceneNode->detachAllObjects();
-    /* detaches all children from the scene.
-       There should be none, as the server should have adjusted their parents.
-     */
-    mSceneNode->removeAllChildren();
-    mScene->getSceneManager()->destroySceneNode(mSceneNode);
-}
-
-Entity *Entity::fromMovableObject(Ogre::MovableObject *movable) {
-    return Ogre::any_cast<Entity*>(movable->getUserAny());
-}
-
-void Entity::init(Ogre::MovableObject *obj) {
-    if (mOgreObject) {
-        mSceneNode->detachObject(mOgreObject);
-    }
-    mOgreObject = obj;
-    if (obj) {
-        mOgreObject->setUserAny(Ogre::Any(this));
-        mSceneNode->attachObject(obj);
-    }
-}
-
-void Entity::setStatic(bool isStatic) {
-    const std::list<Entity*>::iterator end = mScene->mMovingEntities.end();
-    if (isStatic) {
-        if (mMovingIter != end) {
-            SILOG(ogre,debug,"Removed "<<this<<" from moving entities queue.");
-            mScene->mMovingEntities.erase(mMovingIter);
-            mMovingIter = end;
-        }
-    } else {
-        if (mMovingIter == end) {
-            SILOG(ogre,debug,"Added "<<this<<" to moving entities queue.");
-            mMovingIter = mScene->mMovingEntities.insert(end, this);
-        }
-    }
-}
-
-void Entity::removeFromScene() {
-    Ogre::SceneNode *oldParent = mSceneNode->getParentSceneNode();
-    if (oldParent) {
-        oldParent->removeChild(mSceneNode);
-    }
-    setStatic(true);
-}
-void Entity::addToScene(Ogre::SceneNode *newParent) {
-    if (newParent == NULL) {
-        newParent = mScene->getSceneManager()->getRootSceneNode();
-    }
-    removeFromScene();
-    newParent->addChild(mSceneNode);
-    setStatic(false); // May get set to true after the next frame has drawn.
-}
-
-void Entity::setOgrePosition(const Vector3d &pos) {
-    Ogre::Vector3 ogrepos = toOgre(pos, getScene()->getOffset());
-    const Ogre::Vector3 &scale = mSceneNode->getScale();
-    mSceneNode->setPosition(ogrepos);
-}
-void Entity::setOgreOrientation(const Quaternion &orient) {
-    mSceneNode->setOrientation(toOgre(orient));
-}
-
-
-void Entity::updateLocation(Time ti, const Location &newLocation) {
-    //SILOG(ogre,debug,"UpdateLocation "<<this<<" to "<<newLocation.getPosition()<<"; "<<newLocation.getOrientation());
-    if (!getProxy().isStatic(ti)) {
-        setStatic(false);
-    } else {
-        setOgrePosition(newLocation.getPosition());
-        setOgreOrientation(newLocation.getOrientation());
-    }
-}
-
-void Entity::resetLocation(Time ti, const Location &newLocation) {
-    SILOG(ogre,debug,"ResetLocation "<<this<<" to "<<newLocation.getPosition()<<"; "<<newLocation.getOrientation());
-    if (!getProxy().isStatic(ti)) {
-        setStatic(false);
-    } else {
-        setOgrePosition(newLocation.getPosition());
-        setOgreOrientation(newLocation.getOrientation());
-    }
-}
-
-void Entity::setParent(const ProxyObjectPtr &parent, Time ti, const Location &absLocation, const Location &relLocation)
-{
-    Entity *parentEntity = mScene->getEntity(parent);
-    if (!parentEntity) {
-        SILOG(ogre,fatal,"No Entity has been created for proxy " << parent->getObjectReference() <<
-              " which is to become parent of "<<getProxy().getObjectReference());
-        return;
-    }
-    addToScene(parentEntity->mSceneNode);
-}
-
-void Entity::unsetParent(Time ti, const Location &newLocation) {
-    addToScene(NULL);
-}
-
-void Entity::destroyed() {
-    delete this;
-}
-void Entity::extrapolateLocation(TemporalValue<Location>::Time current) {
-    Location loc (getProxy().extrapolateLocation(current));
-    setOgrePosition(loc.getPosition());
-    setOgreOrientation(loc.getOrientation());
-    setStatic(getProxy().isStatic(current));
-}
-
-}
-}
+/*  Sirikata Graphical Object Host
+ *  Entity.cpp
+ *
+ *  Copyright (c) 2009, Patrick Reiter Horn
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are
+ *  met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name of Sirikata nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <oh/Platform.hpp>
+#include "Entity.hpp"
+#include <options/Options.hpp>
+
+namespace Sirikata {
+namespace Graphics {
+
+Entity::Entity(OgreSystem *scene,
+               const ProxyObjectPtr &ppo,
+               const std::string &ogreId,
+               Ogre::MovableObject *obj)
+  : mScene(scene),
+    mProxy(ppo),
+    mOgreObject(NULL),
+    mSceneNode(scene->getSceneManager()->createSceneNode(ogreId)),
+    mMovingIter(scene->mMovingEntities.end())
+{
+    mSceneNode->setInheritScale(false);
+    addToScene(NULL);
+    if (obj) {
+        init(obj);
+    }
+    bool successful = scene->mSceneEntities.insert(
+        OgreSystem::SceneEntitiesMap::value_type(mProxy->getObjectReference(), this)).second;
+
+    assert (successful == true);
+
+    ppo->ProxyObjectProvider::addListener(this);
+    ppo->PositionProvider::addListener(this);
+}
+
+Entity::~Entity() {
+    OgreSystem::SceneEntitiesMap::iterator iter =
+        mScene->mSceneEntities.find(mProxy->getObjectReference());
+    if (iter != mScene->mSceneEntities.end()) {
+        // will fail while in the OgreSystem destructor.
+        mScene->mSceneEntities.erase(iter);
+    }
+    if (mMovingIter != mScene->mMovingEntities.end()) {
+        mScene->mMovingEntities.erase(mMovingIter);
+        mMovingIter = mScene->mMovingEntities.end();
+    }
+    getProxy().ProxyObjectProvider::removeListener(this);
+    getProxy().PositionProvider::removeListener(this);
+    removeFromScene();
+    init(NULL);
+    mSceneNode->detachAllObjects();
+    /* detaches all children from the scene.
+       There should be none, as the server should have adjusted their parents.
+     */
+    mSceneNode->removeAllChildren();
+    mScene->getSceneManager()->destroySceneNode(mSceneNode);
+}
+
+Entity *Entity::fromMovableObject(Ogre::MovableObject *movable) {
+    return Ogre::any_cast<Entity*>(movable->getUserAny());
+}
+
+void Entity::init(Ogre::MovableObject *obj) {
+    if (mOgreObject) {
+        mSceneNode->detachObject(mOgreObject);
+    }
+    mOgreObject = obj;
+    if (obj) {
+        mOgreObject->setUserAny(Ogre::Any(this));
+        mSceneNode->attachObject(obj);
+    }
+}
+
+void Entity::setStatic(bool isStatic) {
+    const std::list<Entity*>::iterator end = mScene->mMovingEntities.end();
+    if (isStatic) {
+        if (mMovingIter != end) {
+            SILOG(ogre,debug,"Removed "<<this<<" from moving entities queue.");
+            mScene->mMovingEntities.erase(mMovingIter);
+            mMovingIter = end;
+        }
+    } else {
+        if (mMovingIter == end) {
+            SILOG(ogre,debug,"Added "<<this<<" to moving entities queue.");
+            mMovingIter = mScene->mMovingEntities.insert(end, this);
+        }
+    }
+}
+
+void Entity::removeFromScene() {
+    Ogre::SceneNode *oldParent = mSceneNode->getParentSceneNode();
+    if (oldParent) {
+        oldParent->removeChild(mSceneNode);
+    }
+    setStatic(true);
+}
+void Entity::addToScene(Ogre::SceneNode *newParent) {
+    if (newParent == NULL) {
+        newParent = mScene->getSceneManager()->getRootSceneNode();
+    }
+    removeFromScene();
+    newParent->addChild(mSceneNode);
+    setStatic(false); // May get set to true after the next frame has drawn.
+}
+
+void Entity::setOgrePosition(const Vector3d &pos) {
+    Ogre::Vector3 ogrepos = toOgre(pos, getScene()->getOffset());
+    const Ogre::Vector3 &scale = mSceneNode->getScale();
+    mSceneNode->setPosition(ogrepos);
+}
+void Entity::setOgreOrientation(const Quaternion &orient) {
+    mSceneNode->setOrientation(toOgre(orient));
+}
+
+
+void Entity::updateLocation(Time ti, const Location &newLocation) {
+    //SILOG(ogre,debug,"UpdateLocation "<<this<<" to "<<newLocation.getPosition()<<"; "<<newLocation.getOrientation());
+    if (!getProxy().isStatic(ti)) {
+        setStatic(false);
+    } else {
+        setOgrePosition(newLocation.getPosition());
+        setOgreOrientation(newLocation.getOrientation());
+    }
+}
+
+void Entity::resetLocation(Time ti, const Location &newLocation) {
+    SILOG(ogre,debug,"ResetLocation "<<this<<" to "<<newLocation.getPosition()<<"; "<<newLocation.getOrientation());
+    if (!getProxy().isStatic(ti)) {
+        setStatic(false);
+    } else {
+        setOgrePosition(newLocation.getPosition());
+        setOgreOrientation(newLocation.getOrientation());
+    }
+}
+
+void Entity::setParent(const ProxyObjectPtr &parent, Time ti, const Location &absLocation, const Location &relLocation)
+{
+    Entity *parentEntity = mScene->getEntity(parent);
+    if (!parentEntity) {
+        SILOG(ogre,fatal,"No Entity has been created for proxy " << parent->getObjectReference() <<
+              " which is to become parent of "<<getProxy().getObjectReference());
+        return;
+    }
+    addToScene(parentEntity->mSceneNode);
+}
+
+void Entity::unsetParent(Time ti, const Location &newLocation) {
+    addToScene(NULL);
+}
+
+void Entity::destroyed() {
+    delete this;
+}
+void Entity::extrapolateLocation(TemporalValue<Location>::Time current) {
+    Location loc (getProxy().extrapolateLocation(current));
+    setOgrePosition(loc.getPosition());
+    setOgreOrientation(loc.getOrientation());
+    setStatic(getProxy().isStatic(current));
+}
+
+}
+}
diff --git a/liboh/plugins/ogre/Entity.hpp b/liboh/plugins/ogre/Entity.hpp
index f850cb3..626cf7b 100644
--- a/liboh/plugins/ogre/Entity.hpp
+++ b/liboh/plugins/ogre/Entity.hpp
@@ -1,122 +1,122 @@
-/*  Sirikata Graphical Object Host
- *  Entity.hpp
- *
- *  Copyright (c) 2009, Patrick Reiter Horn
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are
- *  met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name of Sirikata nor the names of its contributors may
- *    be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef SIRIKATA_GRAPHICS_ENTITY_HPP__
-#define SIRIKATA_GRAPHICS_ENTITY_HPP__
-
-#include "OgreSystem.hpp"
-#include <util/UUID.hpp>
-#include <oh/ProxyObject.hpp>
-#include <oh/ProxyObjectListener.hpp>
-#include <OgreMovableObject.h>
-#include <OgreRenderable.h>
-#include <OgreSceneManager.h>
-#include "OgreConversions.hpp"
-namespace Sirikata {
-namespace Graphics {
-class OgreSystem;
-
-/** Base class for any ProxyObject that has a representation in Ogre. */
-class Entity 
-  : public PositionListener,
-    public ProxyObjectListener
-{
-protected:
-    OgreSystem *const mScene;
-    const ProxyObjectPtr mProxy;
-
-    Ogre::MovableObject *mOgreObject;
-    Ogre::SceneNode *mSceneNode;
-
-    std::list<Entity*>::iterator mMovingIter;
-
-    void init(Ogre::MovableObject *obj);
-
-    void setStatic(bool isStatic);
-
-protected:
-    void setOgrePosition(const Vector3d &pos);
-
-    void setOgreOrientation(const Quaternion &orient);
-public:
-    ProxyObject &getProxy() const {
-        return *mProxy;
-    }
-    const ProxyObjectPtr &getProxyPtr() const {
-        return mProxy;
-    }
-    Entity(OgreSystem *scene,
-           const ProxyObjectPtr &ppo,
-           const std::string &ogreId,
-           Ogre::MovableObject *obj=NULL);
-
-    virtual ~Entity();
-
-    static Entity *fromMovableObject(Ogre::MovableObject *obj);
-
-    void removeFromScene();
-    void addToScene(Ogre::SceneNode *newParent=NULL);
-
-    OgreSystem *getScene() {
-        return mScene;
-    }
-
-    virtual void updateLocation(Time ti, const Location &newLocation);
-    virtual void resetLocation(Time ti, const Location &newLocation);
-    virtual void setParent(const ProxyObjectPtr &parent, Time ti, const Location &absLocation, const Location &relLocation);
-    virtual void unsetParent(Time ti, const Location &newLocation);
-
-    virtual void destroyed();
-
-    Vector3d getOgrePosition() {
-        return fromOgre(mSceneNode->getPosition(), getScene()->getOffset());
-    }
-    Quaternion getOgreOrientation() {
-        return fromOgre(mSceneNode->getOrientation());
-    }
-    void extrapolateLocation(TemporalValue<Location>::Time current);
-
-    virtual void setSelected(bool selected) {
-      mSceneNode->showBoundingBox(selected);
-    }
-    virtual std::string ogreMovableName() const{
-        return id().toString();
-    }
-    const SpaceObjectReference&id()const{
-        return mProxy->getObjectReference();
-    }
-};
-typedef std::tr1::shared_ptr<Entity> EntityPtr;
-
-}
-}
-
-#endif
+/*  Sirikata Graphical Object Host
+ *  Entity.hpp
+ *
+ *  Copyright (c) 2009, Patrick Reiter Horn
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are
+ *  met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name of Sirikata nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SIRIKATA_GRAPHICS_ENTITY_HPP__
+#define SIRIKATA_GRAPHICS_ENTITY_HPP__
+
+#include "OgreSystem.hpp"
+#include <util/UUID.hpp>
+#include <oh/ProxyObject.hpp>
+#include <oh/ProxyObjectListener.hpp>
+#include <OgreMovableObject.h>
+#include <OgreRenderable.h>
+#include <OgreSceneManager.h>
+#include "OgreConversions.hpp"
+namespace Sirikata {
+namespace Graphics {
+class OgreSystem;
+
+/** Base class for any ProxyObject that has a representation in Ogre. */
+class Entity 
+  : public PositionListener,
+    public ProxyObjectListener
+{
+protected:
+    OgreSystem *const mScene;
+    const ProxyObjectPtr mProxy;
+
+    Ogre::MovableObject *mOgreObject;
+    Ogre::SceneNode *mSceneNode;
+
+    std::list<Entity*>::iterator mMovingIter;
+
+    void init(Ogre::MovableObject *obj);
+
+    void setStatic(bool isStatic);
+
+protected:
+    void setOgrePosition(const Vector3d &pos);
+
+    void setOgreOrientation(const Quaternion &orient);
+public:
+    ProxyObject &getProxy() const {
+        return *mProxy;
+    }
+    const ProxyObjectPtr &getProxyPtr() const {
+        return mProxy;
+    }
+    Entity(OgreSystem *scene,
+           const ProxyObjectPtr &ppo,
+           const std::string &ogreId,
+           Ogre::MovableObject *obj=NULL);
+
+    virtual ~Entity();
+
+    static Entity *fromMovableObject(Ogre::MovableObject *obj);
+
+    void removeFromScene();
+    void addToScene(Ogre::SceneNode *newParent=NULL);
+
+    OgreSystem *getScene() {
+        return mScene;
+    }
+
+    virtual void updateLocation(Time ti, const Location &newLocation);
+    virtual void resetLocation(Time ti, const Location &newLocation);
+    virtual void setParent(const ProxyObjectPtr &parent, Time ti, const Location &absLocation, const Location &relLocation);
+    virtual void unsetParent(Time ti, const Location &newLocation);
+
+    virtual void destroyed();
+
+    Vector3d getOgrePosition() {
+        return fromOgre(mSceneNode->getPosition(), getScene()->getOffset());
+    }
+    Quaternion getOgreOrientation() {
+        return fromOgre(mSceneNode->getOrientation());
+    }
+    void extrapolateLocation(TemporalValue<Location>::Time current);
+
+    virtual void setSelected(bool selected) {
+      mSceneNode->showBoundingBox(selected);
+    }
+    virtual std::string ogreMovableName() const{
+        return id().toString();
+    }
+    const SpaceObjectReference&id()const{
+        return mProxy->getObjectReference();
+    }
+};
+typedef std::tr1::shared_ptr<Entity> EntityPtr;
+
+}
+}
+
+#endif
diff --git a/liboh/plugins/ogre/OgreConversions.hpp b/liboh/plugins/ogre/OgreConversions.hpp
index 684fc48..e9556f3 100644
--- a/liboh/plugins/ogre/OgreConversions.hpp
+++ b/liboh/plugins/ogre/OgreConversions.hpp
@@ -1,98 +1,98 @@
-/*  Sirikata Graphical Object Host
- *  OgreConversions.hpp
- *
- *  Copyright (c) 2009, Daniel Reiter Horn
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are
- *  met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name of Sirikata nor the names of its contributors may
- *    be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef OGRE_CONVERSIONS_HPP
-#define OGRE_CONVERSIONS_HPP
-namespace Sirikata {
-typedef Vector4f ColorAlpha;
-typedef Vector3f Color;
-namespace Graphics {
-inline Ogre::Quaternion toOgre(const Sirikata::Quaternion &quat) {
-    Ogre::Quaternion ret;
-    ret.w = quat.w;
-    ret.x = quat.x;
-    ret.y = quat.y;
-    ret.z = quat.z;
-    return ret;
-}
-
-inline Ogre::Vector3 toOgre(const Sirikata::Vector3f &pos) {
-    return pos.convert<Ogre::Vector3>();
-}
-
-// Ogre uses floating points internally. Base should be equal to the translation of the scene.
-inline Ogre::Vector3 toOgre(const Sirikata::Vector3d &pos, const Sirikata::Vector3d &base) {
-    return (pos - base).downCast<Ogre::Real>().convert<Ogre::Vector3>();
-}
-
-inline Ogre::Vector4 toOgre(const Sirikata::Vector4f &pos) {
-    return pos.convert<Ogre::Vector4>();
-}
-
-inline Ogre::ColourValue toOgreRGBA(const Sirikata::ColorAlpha &rgba) {
-    return rgba.convert<Ogre::ColourValue>();
-}
-
-inline Ogre::ColourValue toOgreRGB(const Sirikata::Color &rgb) {
-    return rgb.convert<Ogre::ColourValue>();
-}
-
-inline Ogre::ColourValue toOgreRGBA(const Sirikata::Color &rgb, float32 alpha) {
-    return rgb.convert<Ogre::ColourValue>();
-}
-
-inline Sirikata::Quaternion fromOgre(const Ogre::Quaternion &quat) {
-    return Sirikata::Quaternion(quat.x,quat.y,quat.z,quat.w,Quaternion::XYZW());
-}
-
-inline Sirikata::Vector3f fromOgre(const Ogre::Vector3 &pos) {
-    return Sirikata::Vector3f(pos);
-}
-
-inline Sirikata::Vector3d fromOgre(const Ogre::Vector3 &pos, const Vector3d &base) {
-    return Sirikata::Vector3d(pos) + base;
-}
-
-inline Sirikata::Vector4f fromOgre(const Ogre::Vector4 &pos) {
-    return Sirikata::Vector4f(pos.x,pos.y,pos.z,pos.w);
-}
-
-inline Sirikata::ColorAlpha fromOgreRGBA(const Ogre::ColourValue &rgba) {
-    return Sirikata::ColorAlpha(rgba.r,rgba.b,rgba.g,rgba.a);
-}
-
-inline Sirikata::Color fromOgreRGB(const Ogre::ColourValue &rgba) {
-    return Sirikata::Color(rgba.r,rgba.g,rgba.b);
-}
-}
-}
-#endif
+/*  Sirikata Graphical Object Host
+ *  OgreConversions.hpp
+ *
+ *  Copyright (c) 2009, Daniel Reiter Horn
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are
+ *  met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name of Sirikata nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef OGRE_CONVERSIONS_HPP
+#define OGRE_CONVERSIONS_HPP
+namespace Sirikata {
+typedef Vector4f ColorAlpha;
+typedef Vector3f Color;
+namespace Graphics {
+inline Ogre::Quaternion toOgre(const Sirikata::Quaternion &quat) {
+    Ogre::Quaternion ret;
+    ret.w = quat.w;
+    ret.x = quat.x;
+    ret.y = quat.y;
+    ret.z = quat.z;
+    return ret;
+}
+
+inline Ogre::Vector3 toOgre(const Sirikata::Vector3f &pos) {
+    return pos.convert<Ogre::Vector3>();
+}
+
+// Ogre uses floating points internally. Base should be equal to the translation of the scene.
+inline Ogre::Vector3 toOgre(const Sirikata::Vector3d &pos, const Sirikata::Vector3d &base) {
+    return (pos - base).downCast<Ogre::Real>().convert<Ogre::Vector3>();
+}
+
+inline Ogre::Vector4 toOgre(const Sirikata::Vector4f &pos) {
+    return pos.convert<Ogre::Vector4>();
+}
+
+inline Ogre::ColourValue toOgreRGBA(const Sirikata::ColorAlpha &rgba) {
+    return rgba.convert<Ogre::ColourValue>();
+}
+
+inline Ogre::ColourValue toOgreRGB(const Sirikata::Color &rgb) {
+    return rgb.convert<Ogre::ColourValue>();
+}
+
+inline Ogre::ColourValue toOgreRGBA(const Sirikata::Color &rgb, float32 alpha) {
+    return rgb.convert<Ogre::ColourValue>();
+}
+
+inline Sirikata::Quaternion fromOgre(const Ogre::Quaternion &quat) {
+    return Sirikata::Quaternion(quat.x,quat.y,quat.z,quat.w,Quaternion::XYZW());
+}
+
+inline Sirikata::Vector3f fromOgre(const Ogre::Vector3 &pos) {
+    return Sirikata::Vector3f(pos);
+}
+
+inline Sirikata::Vector3d fromOgre(const Ogre::Vector3 &pos, const Vector3d &base) {
+    return Sirikata::Vector3d(pos) + base;
+}
+
+inline Sirikata::Vector4f fromOgre(const Ogre::Vector4 &pos) {
+    return Sirikata::Vector4f(pos.x,pos.y,pos.z,pos.w);
+}
+
+inline Sirikata::ColorAlpha fromOgreRGBA(const Ogre::ColourValue &rgba) {
+    return Sirikata::ColorAlpha(rgba.r,rgba.b,rgba.g,rgba.a);
+}
+
+inline Sirikata::Color fromOgreRGB(const Ogre::ColourValue &rgba) {
+    return Sirikata::Color(rgba.r,rgba.g,rgba.b);
+}
+}
+}
+#endif
diff --git a/liboh/plugins/ogre/data/chrome/application/sirikata.html b/liboh/plugins/ogre/data/chrome/application/sirikata.html
index 53c1ca1..971d445 100644
--- a/liboh/plugins/ogre/data/chrome/application/sirikata.html
+++ b/liboh/plugins/ogre/data/chrome/application/sirikata.html
@@ -1,276 +1,276 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml">
-<head>
-<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
-
-<title>Untitled Document</title>
-
-
-<!--[if IE]>
-<style type="text/css"> 
-/* place css fixes for all versions of IE in this conditional comment */
-.twoColLiqRtHdr #sidebar1 { padding-top: 30px; }
-.twoColLiqRtHdr #mainContent { zoom: 1; padding-top: 15px; }
-/* the above proprietary zoom property gives IE the hasLayout it needs to avoid several bugs */
-</style>
-<![endif]-->
-<!--<link href="css/humanity/jquery-ui-1.7.2.custom.css" rel="stylesheet" type="text/css" /> -->
-<link href="css/style.css" rel="stylesheet" type="text/css" />
-<link href="css/critique-style.css" rel="stylesheet" type="text/css" />
-<link href="css/jquery.superbox.css" rel="stylesheet" type="text/css" />
-
-<script type="text/javascript" src="js/old/jquery-1.2.6.min.js"></script>
-<script type="text/javascript" src="js/old/jquery-ui-1.6.custom.min.js"></script>
-
-
-
-<script type="text/javascript" src="js/wizzard.js"></script>
-<script type="text/javascript" src="js/window-controll.js"></script>
-<script type="text/javascript" src="js/window-ui.js"></script>
-
-
-<script type="text/javascript" src="js/ui.coverflow.custom.js"></script> 
-
-
-<script type="text/javascript" src="js/sylvester.js"></script> 
-<script type="text/javascript" src="js/pb.transformie.js"></script> 
-
-
-<script type="text/javascript">  
-
-
-
-setTimeout('enterWelcomeScreen()', 1000);
-//setTimeout('artTest()', 1000);
-
-function enterWelcomeScreen() {
-	loadLargeModal("welcome.html");
-}
-function enterLoadGallery() {
-	leaveModal();
-	$("#header").fadeIn("slow");
-	loadSmallModal("load-gallery.html");
-}
-
-function enterPlaceArtwork2() {
-	leaveModal();
-	loadInfoScreen("select-art.html", false);
-}
-
-
-function cf() {
-	leaveModal();
-	loadInfoScreen("coverflow.html", false);
-}
-
-function developmentMode() {
-	//$("#header").fadeIn("slow");
-	$('#development-screen').fadeIn('slow');
-	leaveModal();
-	//loadSideBar("place-art.html");
-	//$('#wizzard-screen').fadeOut('slow');
-}
-
-function enterPlaceArtwork() {
-	loadSideBar("place-art.html");
-	
-	
-	
-	wizzard_queMessage("You can now drag art work from the side panel into the museum. When you are done selecting your pictures click on me and I will show you what's next. <a href='javascript: wizzard_hideMessage();'>Ok</a>", "");
-	wizzard_nextMessage();
-	wizzard_queMessage("Are you done selecting your artwork? <ul> <li> <a href='javascript:wizzard_reset();enterSelectFrames()'>Yes, take me to the next step. </a></li><li><a href='javascript:wizzard_repeatMessage(); wizzard_hideMessage();'>No, give me some more time.</a></li> ", "Click Me when you're done") ;
-}
-function enterSelectFrames() {
-	$("#sidebar1").fadeOut("slow");
-	wizzard_reset();
-	
-	setTimeout('enterSelectFrames2()', 1000);
-	
-}
-function enterSelectFrames2() {
-	loadSideBar("frames.html");
-	wizzard_queMessage("Great! Now that you decided which paintings you want to display, it's time to select frames for the artwork. <a href='javascript: wizzard_nextMessage();'>Ok</a>", "Click Me When You're done!"); wizzard_nextMessage();
-	wizzard_queMessage("Let's start on the first picture (pretend i moved the camera facing to the first picture). You can now select a frame for this piece of artwork. Once you have chosen your frame click on me. <a href='javascript: wizzard_hideMessage();'>Ok</a>", "Select your frame and click on me.");
-	
-	//wizzard_queMessage("I was only programmed up to this step, does this bother you? <a href='javascript:wizzard_repeatMessage(); wizzard_hideMessage()'>No, of course not!</a> ", "") ;
-	
-	
-}
-
-function mousedemo() {
-		
-	
-		$("#mouse-cursor").animate( { right: "50px", bottom:"150px"}, 1000);
-		
-		setTimeout('globalcoverflow.moveTo(5)', 1500);
-		
-		setTimeout('$("#mouse-cursor").animate( { right: "150px", bottom:"100px"}, 600);', 1800);
-		
-		setTimeout('$("#mouse-cursor-demo").fadeIn("fast");', 2300);
-		
-		setTimeout('$("#mouse-cursor").animate( { right: "600px", bottom:"300px"}, 2000);', 2700);
-		
-		setTimeout('$("#mouse-cursor-demo").hide();',4300);
-	}
-
-</script>  
-
-
-<link href="css/style-common.css" rel="stylesheet" type="text/css" />
-</head>
-
-<body class="twoColLiqRtHdr">
-
-
-<div id="container">
-
-  <div id="header" class="ui" >
-   
-    <ul>
-        <li class="topbarbutton" style="background-position-x: -118px;" onclick="enterLoadGallery();" />&nbsp;</li>
-        <li class="topbarbutton" style="background-position-x: -235px;" onclick="enterSelectFrames();" />&nbsp;</li>
-        <li class="topbarbutton" style="background-position-x: -352px;" onclick="$('#sidebar1').load('walls.html');" />&nbsp;</li>
-        <li class="topbarbutton" style="background-position-x: -469px;" onclick="$('#sidebar1').load('lighting.html')" />&nbsp;</li>
-        <li class="topbarbutton" style="background-position-x: -586px;" onclick="$('#sidebar1').load('save-share.html')" />&nbsp;</li>
-    </ul>
-  </div>
-  
-  
-  <div id="sidebar1" class="ui" >
-    <h3>loading ...</h3>
-  </div>  
-</div>
-
-<div id="mainContent">
-  	<!--<img src="images/screenshot.jpg" width="100%" height="100%" /-->
-</div>
-
-<div id="mode-large-modal" >
- &nbsp;
-</div>
-<div id="mode-small-modal" >
- &nbsp;
-</div>
-<div id="mode-screen" >
- &nbsp;
-</div>
-
-<div id="wizzard-screen" class="ui">
-  	<div id="wizzard-text" class="ui" onclick="">
-    	blabalabalabl
-    </div>
-    <div style="float:left;">
-        <img class="ui" src="images/wizzard.png" width="84" height="93" onclick="wizzard_click();" />
-        <div id="wizzard-mode" class="ui" style="width: 84px; color: #FFF; font-size: 10px; font-weight:bold;">
-         	   
-        </div>
-        
-    </div>
-</div>
-
-
-<div id="info-screen" >
- &nbsp;
-</div>
-
-<div id="picture-navigation-screen">
-	<ul class="menu ui">
-    	<li id="picture-navigation-previous"></li>
-        <li id="picture-navigation-next"></li>
-        <li id="picture-navigation-map"></li>
-    </ul>
-</div>
-
-
-
-<div id="picture-display-screen" class="ui" style="display: none; padding: auto; position: absolute; z-index: 7005; width: 60%; height: 60%; right: 20%; bottom: 30%;">
-	<img width="100%" height="100%" src="http://www.dennisschaaf.com/bornholm/wp-content/uploads/2009/08/5595_small.jpg"  />
-
-</div>
-<div id="picture-info-screen" class="ui">
-	<!--<ul id="info-screen-tabs" class="menu ui">
-    	<li onclick="$('#info-screen-frame').attr('src','http://www.dennisschaaf.com/bornholm/?p=4#content');">Description</li>
-      <li onclick="$('#info-screen-frame').attr('src','http://www.dennisschaaf.com/bornholm/?p=4#comments');">Comments</li>
-        <li onclick="$('#info-screen-frame').attr('src','http://www.dennisschaaf.com/bornholm/?p=4#respond');">Leave Comment</li>
-    </ul>-->
-    <div id="info-screen-content">
-      <iframe id="info-screen-frame" 
-      		src="http://www.dennisschaaf.com/bornholm/?p=4&embedded=true" 
-            style="position:absolute; left: 11px; top: 37px; width: 643px; height: 193px; border: none;" border="no"></iframe>          
-    </div>
-
-</div>
-
-
-<!-- Commont Stuff -->
-
-<div id="black-mode-screen" >
- &nbsp;
-</div>
-
-<div id="navigation-screen" class="ui">
-	<img id="navigation-picture" src="images/navigation/navigation_default.png" border="0" usemap="#map"/>
-    <map name="map" id="map">
-      <area id="navi_up" shape="poly" coords="76,57,136,7,10,6"  />
-      <area id="navi_down" shape="poly" coords="73,93,8,144,138,141"  />
-      <area id="navi_left" shape="poly" coords="55,74,5,133,7,5"  />
-      <area id="navi_right" shape="poly" coords="93,76,144,4,142,137" />
-    </map>
-</div>
-
-<div id="development-screen" class="ui">
-	<a href="javascript:location.reload();">Reload</a>
-  	<a href="javascript:$('#development-console-screen').toggle();">Console</a>
-	<a href="javascript:$('#navigation-screen').toggle();">Navi</a>
-    Curator:
-	<a href="javascript:$('#header').toggle();">Tb</a>
-	<a href="javascript:$('#wizzard-screen').toggle();">Wiz</a>
-    <a href="javascript:$('#sidebar1').toggle();">Sb</a>
-  	<a href="javascript:$('#info-screen').toggle();">Sb2</a>
-	Critique:
-	<a href="javascript:$('#picture-navigation-screen').toggle();">Pic Navi</a>
-    <a href="javascript:$('#picture-info-screen').toggle();">Info</a>
-    <a href="javascript:$('#black-mode-screen').toggle();$('#picture-display-screen').toggle();">pic</a>
-	<select id="debugfns" ></select>
-    
-</div>
-<script type="text/javascript" src="js/jquery.selectboxes.min.js"></script>
-<script type="text/javascript"> 
-	debugoptions = {
-		"debug('Ahh!')":"send debug message",
-		"cf()":"Coverflow",
-		"mousedemo()":"Mouse Demo"
-		
-	}
-	
-	$("#debugfns").ready ( function () {
-		$("#debugfns").addOption(debugoptions,false)
-		$("#debugfns").change(function (event,ui) {
-										
-			var dropdown = document.getElementById("debugfns");  
-        	var index = dropdown.selectedIndex;  
-			
-        	eval(dropdown.options[index].value); 
-		});
-	});
-
-</script>
-<div id="development-console-screen" class="ui" >
-	Console
-	<p id="development-console">&nbsp; 
-	</p>
-	<p>
-		<input id="console-input" type="text" size="30" >
-		<input type="button" onclick="debug(eval($('#console-input').val()));" value="run">
-	</p>
-
-</div>
-
-<div id="mouse-cursor" style="position:absolute; right: 517px; bottom: 500px; z-index: 10000; margin:0px; padding:0px;">
-	<img src="images/mouse_cursor.png" />
-    <img src="images/art/art1.png" id="mouse-cursor-demo" style="display:none;"/>
-</div>
-
-
-</body>
-</html>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+
+<title>Untitled Document</title>
+
+
+<!--[if IE]>
+<style type="text/css"> 
+/* place css fixes for all versions of IE in this conditional comment */
+.twoColLiqRtHdr #sidebar1 { padding-top: 30px; }
+.twoColLiqRtHdr #mainContent { zoom: 1; padding-top: 15px; }
+/* the above proprietary zoom property gives IE the hasLayout it needs to avoid several bugs */
+</style>
+<![endif]-->
+<!--<link href="css/humanity/jquery-ui-1.7.2.custom.css" rel="stylesheet" type="text/css" /> -->
+<link href="css/style.css" rel="stylesheet" type="text/css" />
+<link href="css/critique-style.css" rel="stylesheet" type="text/css" />
+<link href="css/jquery.superbox.css" rel="stylesheet" type="text/css" />
+
+<script type="text/javascript" src="js/old/jquery-1.2.6.min.js"></script>
+<script type="text/javascript" src="js/old/jquery-ui-1.6.custom.min.js"></script>
+
+
+
+<script type="text/javascript" src="js/wizzard.js"></script>
+<script type="text/javascript" src="js/window-controll.js"></script>
+<script type="text/javascript" src="js/window-ui.js"></script>
+
+
+<script type="text/javascript" src="js/ui.coverflow.custom.js"></script> 
+
+
+<script type="text/javascript" src="js/sylvester.js"></script> 
+<script type="text/javascript" src="js/pb.transformie.js"></script> 
+
+
+<script type="text/javascript">  
+
+
+
+setTimeout('enterWelcomeScreen()', 1000);
+//setTimeout('artTest()', 1000);
+
+function enterWelcomeScreen() {
+	loadLargeModal("welcome.html");
+}
+function enterLoadGallery() {
+	leaveModal();
+	$("#header").fadeIn("slow");
+	loadSmallModal("load-gallery.html");
+}
+
+function enterPlaceArtwork2() {
+	leaveModal();
+	loadInfoScreen("select-art.html", false);
+}
+
+
+function cf() {
+	leaveModal();
+	loadInfoScreen("coverflow.html", false);
+}
+
+function developmentMode() {
+	//$("#header").fadeIn("slow");
+	$('#development-screen').fadeIn('slow');
+	leaveModal();
+	//loadSideBar("place-art.html");
+	//$('#wizzard-screen').fadeOut('slow');
+}
+
+function enterPlaceArtwork() {
+	loadSideBar("place-art.html");
+	
+	
+	
+	wizzard_queMessage("You can now drag art work from the side panel into the museum. When you are done selecting your pictures click on me and I will show you what's next. <a href='javascript: wizzard_hideMessage();'>Ok</a>", "");
+	wizzard_nextMessage();
+	wizzard_queMessage("Are you done selecting your artwork? <ul> <li> <a href='javascript:wizzard_reset();enterSelectFrames()'>Yes, take me to the next step. </a></li><li><a href='javascript:wizzard_repeatMessage(); wizzard_hideMessage();'>No, give me some more time.</a></li> ", "Click Me when you're done") ;
+}
+function enterSelectFrames() {
+	$("#sidebar1").fadeOut("slow");
+	wizzard_reset();
+	
+	setTimeout('enterSelectFrames2()', 1000);
+	
+}
+function enterSelectFrames2() {
+	loadSideBar("frames.html");
+	wizzard_queMessage("Great! Now that you decided which paintings you want to display, it's time to select frames for the artwork. <a href='javascript: wizzard_nextMessage();'>Ok</a>", "Click Me When You're done!"); wizzard_nextMessage();
+	wizzard_queMessage("Let's start on the first picture (pretend i moved the camera facing to the first picture). You can now select a frame for this piece of artwork. Once you have chosen your frame click on me. <a href='javascript: wizzard_hideMessage();'>Ok</a>", "Select your frame and click on me.");
+	
+	//wizzard_queMessage("I was only programmed up to this step, does this bother you? <a href='javascript:wizzard_repeatMessage(); wizzard_hideMessage()'>No, of course not!</a> ", "") ;
+	
+	
+}
+
+function mousedemo() {
+		
+	
+		$("#mouse-cursor").animate( { right: "50px", bottom:"150px"}, 1000);
+		
+		setTimeout('globalcoverflow.moveTo(5)', 1500);
+		
+		setTimeout('$("#mouse-cursor").animate( { right: "150px", bottom:"100px"}, 600);', 1800);
+		
+		setTimeout('$("#mouse-cursor-demo").fadeIn("fast");', 2300);
+		
+		setTimeout('$("#mouse-cursor").animate( { right: "600px", bottom:"300px"}, 2000);', 2700);
+		
+		setTimeout('$("#mouse-cursor-demo").hide();',4300);
+	}
+
+</script>  
+
+
+<link href="css/style-common.css" rel="stylesheet" type="text/css" />
+</head>
+
+<body class="twoColLiqRtHdr">
+
+
+<div id="container">
+
+  <div id="header" class="ui" >
+   
+    <ul>
+        <li class="topbarbutton" style="background-position-x: -118px;" onclick="enterLoadGallery();" />&nbsp;</li>
+        <li class="topbarbutton" style="background-position-x: -235px;" onclick="enterSelectFrames();" />&nbsp;</li>
+        <li class="topbarbutton" style="background-position-x: -352px;" onclick="$('#sidebar1').load('walls.html');" />&nbsp;</li>
+        <li class="topbarbutton" style="background-position-x: -469px;" onclick="$('#sidebar1').load('lighting.html')" />&nbsp;</li>
+        <li class="topbarbutton" style="background-position-x: -586px;" onclick="$('#sidebar1').load('save-share.html')" />&nbsp;</li>
+    </ul>
+  </div>
+  
+  
+  <div id="sidebar1" class="ui" >
+    <h3>loading ...</h3>
+  </div>  
+</div>
+
+<div id="mainContent">
+  	<!--<img src="images/screenshot.jpg" width="100%" height="100%" /-->
+</div>
+
+<div id="mode-large-modal" >
+ &nbsp;
+</div>
+<div id="mode-small-modal" >
+ &nbsp;
+</div>
+<div id="mode-screen" >
+ &nbsp;
+</div>
+
+<div id="wizzard-screen" class="ui">
+  	<div id="wizzard-text" class="ui" onclick="">
+    	blabalabalabl
+    </div>
+    <div style="float:left;">
+        <img class="ui" src="images/wizzard.png" width="84" height="93" onclick="wizzard_click();" />
+        <div id="wizzard-mode" class="ui" style="width: 84px; color: #FFF; font-size: 10px; font-weight:bold;">
+         	   
+        </div>
+        
+    </div>
+</div>
+
+
+<div id="info-screen" >
+ &nbsp;
+</div>
+
+<div id="picture-navigation-screen">
+	<ul class="menu ui">
+    	<li id="picture-navigation-previous"></li>
+        <li id="picture-navigation-next"></li>
+        <li id="picture-navigation-map"></li>
+    </ul>
+</div>
+
+
+
+<div id="picture-display-screen" class="ui" style="display: none; padding: auto; position: absolute; z-index: 7005; width: 60%; height: 60%; right: 20%; bottom: 30%;">
+	<img width="100%" height="100%" src="http://www.dennisschaaf.com/bornholm/wp-content/uploads/2009/08/5595_small.jpg"  />
+
+</div>
+<div id="picture-info-screen" class="ui">
+	<!--<ul id="info-screen-tabs" class="menu ui">
+    	<li onclick="$('#info-screen-frame').attr('src','http://www.dennisschaaf.com/bornholm/?p=4#content');">Description</li>
+      <li onclick="$('#info-screen-frame').attr('src','http://www.dennisschaaf.com/bornholm/?p=4#comments');">Comments</li>
+        <li onclick="$('#info-screen-frame').attr('src','http://www.dennisschaaf.com/bornholm/?p=4#respond');">Leave Comment</li>
+    </ul>-->
+    <div id="info-screen-content">
+      <iframe id="info-screen-frame" 
+      		src="http://www.dennisschaaf.com/bornholm/?p=4&embedded=true" 
+            style="position:absolute; left: 11px; top: 37px; width: 643px; height: 193px; border: none;" border="no"></iframe>          
+    </div>
+
+</div>
+
+
+<!-- Commont Stuff -->
+
+<div id="black-mode-screen" >
+ &nbsp;
+</div>
+
+<div id="navigation-screen" class="ui">
+	<img id="navigation-picture" src="images/navigation/navigation_default.png" border="0" usemap="#map"/>
+    <map name="map" id="map">
+      <area id="navi_up" shape="poly" coords="76,57,136,7,10,6"  />
+      <area id="navi_down" shape="poly" coords="73,93,8,144,138,141"  />
+      <area id="navi_left" shape="poly" coords="55,74,5,133,7,5"  />
+      <area id="navi_right" shape="poly" coords="93,76,144,4,142,137" />
+    </map>
+</div>
+
+<div id="development-screen" class="ui">
+	<a href="javascript:location.reload();">Reload</a>
+  	<a href="javascript:$('#development-console-screen').toggle();">Console</a>
+	<a href="javascript:$('#navigation-screen').toggle();">Navi</a>
+    Curator:
+	<a href="javascript:$('#header').toggle();">Tb</a>
+	<a href="javascript:$('#wizzard-screen').toggle();">Wiz</a>
+    <a href="javascript:$('#sidebar1').toggle();">Sb</a>
+  	<a href="javascript:$('#info-screen').toggle();">Sb2</a>
+	Critique:
+	<a href="javascript:$('#picture-navigation-screen').toggle();">Pic Navi</a>
+    <a href="javascript:$('#picture-info-screen').toggle();">Info</a>
+    <a href="javascript:$('#black-mode-screen').toggle();$('#picture-display-screen').toggle();">pic</a>
+	<select id="debugfns" ></select>
+    
+</div>
+<script type="text/javascript" src="js/jquery.selectboxes.min.js"></script>
+<script type="text/javascript"> 
+	debugoptions = {
+		"debug('Ahh!')":"send debug message",
+		"cf()":"Coverflow",
+		"mousedemo()":"Mouse Demo"
+		
+	}
+	
+	$("#debugfns").ready ( function () {
+		$("#debugfns").addOption(debugoptions,false)
+		$("#debugfns").change(function (event,ui) {
+										
+			var dropdown = document.getElementById("debugfns");  
+        	var index = dropdown.selectedIndex;  
+			
+        	eval(dropdown.options[index].value); 
+		});
+	});
+
+</script>
+<div id="development-console-screen" class="ui" >
+	Console
+	<p id="development-console">&nbsp; 
+	</p>
+	<p>
+		<input id="console-input" type="text" size="30" >
+		<input type="button" onclick="debug(eval($('#console-input').val()));" value="run">
+	</p>
+
+</div>
+
+<div id="mouse-cursor" style="position:absolute; right: 517px; bottom: 500px; z-index: 10000; margin:0px; padding:0px;">
+	<img src="images/mouse_cursor.png" />
+    <img src="images/art/art1.png" id="mouse-cursor-demo" style="display:none;"/>
+</div>
+
+
+</body>
+</html>
diff --git a/liboh/plugins/ogre/data/chrome/application/sirikata_flythru.html b/liboh/plugins/ogre/data/chrome/application/sirikata_flythru.html
index 0c97293..f4ee1eb 100644
--- a/liboh/plugins/ogre/data/chrome/application/sirikata_flythru.html
+++ b/liboh/plugins/ogre/data/chrome/application/sirikata_flythru.html
@@ -1,220 +1,220 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml">
-<head>
-<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
-
-<title>Untitled Document</title>
-
-
-<!--[if IE]>
-<style type="text/css"> 
-/* place css fixes for all versions of IE in this conditional comment */
-.twoColLiqRtHdr #sidebar1 { padding-top: 30px; }
-.twoColLiqRtHdr #mainContent { zoom: 1; padding-top: 15px; }
-/* the above proprietary zoom property gives IE the hasLayout it needs to avoid several bugs */
-</style>
-<![endif]-->
-<!--<link href="css/humanity/jquery-ui-1.7.2.custom.css" rel="stylesheet" type="text/css" /> -->
-<link href="css/style.css" rel="stylesheet" type="text/css" />
-<link href="css/critique-style.css" rel="stylesheet" type="text/css" />
-<link href="css/jquery.superbox.css" rel="stylesheet" type="text/css" />
-
-<script type="text/javascript" src="js/jquery-1.2.6.min.js"></script>
-<script type="text/javascript" src="js/jquery-ui-1.6.custom.min.js"></script>
-<script type="text/javascript" src="js/wizzard.js"></script>
-<script type="text/javascript" src="js/window-controll.js"></script>
-<script type="text/javascript" src="js/window-ui.js"></script>
-
-
-<script type="text/javascript">  
-
-
-
-setTimeout('enterWelcomeScreen()', 1000);
-//setTimeout('artTest()', 1000);
-
-function enterWelcomeScreen() {
-	loadLargeModal("welcome.html");
-}
-function enterLoadGallery() {
-	leaveModal();
-	$("#header").fadeIn("slow");
-	loadSmallModal("load-gallery.html");
-}
-
-function enterPlaceArtwork2() {
-	leaveModal();
-	loadInfoScreen("select-art.html", false);
-}
-
-function developmentMode() {
-	//$("#header").fadeIn("slow");
-	$('#development-screen').fadeIn('slow');
-	leaveModal();
-	//loadSideBar("place-art.html");
-	//$('#wizzard-screen').fadeOut('slow');
-}
-
-function enterPlaceArtwork() {
-	loadSideBar("place-art.html");
-	
-	
-	
-	wizzard_queMessage("You can now drag art work from the side panel into the museum. When you are done selecting your pictures click on me and I will show you what's next. <a href='javascript: wizzard_hideMessage();'>Ok</a>", "");
-	wizzard_nextMessage();
-	wizzard_queMessage("Are you done selecting your artwork? <ul> <li> <a href='javascript:wizzard_reset();enterSelectFrames()'>Yes, take me to the next step. </a></li><li><a href='javascript:wizzard_repeatMessage(); wizzard_hideMessage();'>No, give me some more time.</a></li> ", "Click Me when you're done") ;
-}
-function enterSelectFrames() {
-	$("#sidebar1").fadeOut("slow");
-	wizzard_reset();
-	
-	setTimeout('enterSelectFrames2()', 1000);
-	
-}
-function enterSelectFrames2() {
-	loadSideBar("frames.html");
-	wizzard_queMessage("Great! Now that you decided which paintings you want to display, it's time to select frames for the artwork. <a href='javascript: wizzard_nextMessage();'>Ok</a>", "Click Me When You're done!"); wizzard_nextMessage();
-	wizzard_queMessage("Let's start on the first picture (pretend i moved the camera facing to the first picture). You can now select a frame for this piece of artwork. Once you have chosen your frame click on me. <a href='javascript: wizzard_hideMessage();'>Ok</a>", "Select your frame and click on me.");
-	
-	//wizzard_queMessage("I was only programmed up to this step, does this bother you? <a href='javascript:wizzard_repeatMessage(); wizzard_hideMessage()'>No, of course not!</a> ", "") ;
-	
-	
-}
-
-
-
-</script>  
-
-
-<link href="css/style-common.css" rel="stylesheet" type="text/css" />
-</head>
-
-<body class="twoColLiqRtHdr">
-
-
-<div id="container">
-
-  <div id="header" class="ui" >
-   
-    <ul>
-        <li class="topbarbutton" style="background-position-x: -118px;" onclick="enterLoadGallery();" />&nbsp;</li>
-        <li class="topbarbutton" style="background-position-x: -235px;" onclick="enterSelectFrames();" />&nbsp;</li>
-        <li class="topbarbutton" style="background-position-x: -352px;" onclick="$('#sidebar1').load('walls.html');" />&nbsp;</li>
-        <li class="topbarbutton" style="background-position-x: -469px;" onclick="$('#sidebar1').load('lighting.html')" />&nbsp;</li>
-        <li class="topbarbutton" style="background-position-x: -586px;" onclick="$('#sidebar1').load('save-share.html')" />&nbsp;</li>
-    </ul>
-  </div>
-  
-  
-  <div id="sidebar1" class="ui" >
-    <h3>loading ...</h3>
-  </div>  
-</div>
-
-<div id="mainContent">
-  	<!--<img src="images/screenshot.jpg" width="100%" height="100%" /-->
-</div>
-
-<div id="mode-large-modal" >
- &nbsp;
-</div>
-<div id="mode-small-modal" >
- &nbsp;
-</div>
-<div id="mode-screen" >
- &nbsp;
-</div>
-
-<div id="wizzard-screen" class="ui">
-  	<div id="wizzard-text" class="ui" onclick="">
-    	blabalabalabl
-    </div>
-    <div style="float:left;">
-        <img class="ui" src="images/wizzard.png" width="84" height="93" onclick="wizzard_click();" />
-        <div id="wizzard-mode" class="ui" style="width: 84px; color: #FFF; font-size: 10px; font-weight:bold;">
-         	   
-        </div>
-        
-    </div>
-</div>
-
-
-<div id="info-screen" >
- &nbsp;
-</div>
-
-<div id="picture-navigation-screen">
-	<ul class="menu ui">
-    	<li id="picture-navigation-previous"></li>
-        <li id="picture-navigation-next"></li>
-        <li id="picture-navigation-map"></li>
-    </ul>
-</div>
-
-
-
-<div id="picture-display-screen" class="ui" style="display: none; padding: auto; position: absolute; z-index: 7005; width: 60%; height: 60%; right: 20%; bottom: 30%;">
-	<img width="100%" height="100%" src="http://www.dennisschaaf.com/bornholm/wp-content/uploads/2009/08/5595_small.jpg"  />
-
-</div>
-<!--
-<div id="picture-info-screen" class="ui">
-	<ul id="info-screen-tabs" class="menu ui">
-    	<li onclick="$('#info-screen-frame').attr('src','http://www.dennisschaaf.com/bornholm/?p=4#content');">Description</li>
-      <li onclick="$('#info-screen-frame').attr('src','http://www.dennisschaaf.com/bornholm/?p=4#comments');">Comments</li>
-        <li onclick="$('#info-screen-frame').attr('src','http://www.dennisschaaf.com/bornholm/?p=4#respond');">Leave Comment</li>
-    </ul>
-    <div id="info-screen-content">
-      <iframe id="info-screen-frame" 
-      		src="http://www.dennisschaaf.com/bornholm/?p=4&embedded=true" 
-            style="position:absolute; left: 11px; top: 37px; width: 643px; height: 193px; border: none;" border="no"></iframe>          
-    </div>
-
-</div>
--->
-
-<!-- Commont Stuff -->
-
-<div id="black-mode-screen" >
- &nbsp;
-</div>
-
-<div id="navigation-screen" class="ui">
-	<img id="navigation-picture" src="images/navigation/navigation_default.png" border="0" usemap="#map"/>
-    <map name="map" id="map">
-      <area id="navi_up" shape="poly" coords="76,57,136,7,10,6"  />
-      <area id="navi_down" shape="poly" coords="73,93,8,144,138,141"  />
-      <area id="navi_left" shape="poly" coords="55,74,5,133,7,5"  />
-      <area id="navi_right" shape="poly" coords="93,76,144,4,142,137" />
-    </map>
-</div>
-
-<div id="development-screen" class="ui">
-	<a href="javascript:location.reload();">Reload</a>
-  	<a href="javascript:$('#development-console-screen').toggle();">Console</a>
-	<a href="javascript:$('#navigation-screen').toggle();">Navi</a>
-    Curator:
-	<a href="javascript:$('#header').toggle();">Tb</a>
-	<a href="javascript:$('#wizzard-screen').toggle();">Wiz</a>
-    <a href="javascript:$('#sidebar1').toggle();">Sb</a>
-  	<a href="javascript:$('#info-screen').toggle();">Sb2</a>
-	Critique:
-	<a href="javascript:$('#picture-navigation-screen').toggle();">Pic Navi</a>
-    <a href="javascript:$('#picture-info-screen').toggle();">Info</a>
-    <a href="javascript:$('#black-mode-screen').toggle();$('#picture-display-screen').toggle();">pic</a>
-
-</div>
-
-<div id="development-console-screen" class="ui" >
-	Console
-	<p id="development-console">&nbsp; 
-	</p>
-	<p>
-		<input id="console-input" type="text" size="30" >
-		<input type="button" onclick="debug(eval($('#console-input').val()));" value="run">
-	</p>
-
-</div>
-
-</body>
-</html>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+
+<title>Untitled Document</title>
+
+
+<!--[if IE]>
+<style type="text/css"> 
+/* place css fixes for all versions of IE in this conditional comment */
+.twoColLiqRtHdr #sidebar1 { padding-top: 30px; }
+.twoColLiqRtHdr #mainContent { zoom: 1; padding-top: 15px; }
+/* the above proprietary zoom property gives IE the hasLayout it needs to avoid several bugs */
+</style>
+<![endif]-->
+<!--<link href="css/humanity/jquery-ui-1.7.2.custom.css" rel="stylesheet" type="text/css" /> -->
+<link href="css/style.css" rel="stylesheet" type="text/css" />
+<link href="css/critique-style.css" rel="stylesheet" type="text/css" />
+<link href="css/jquery.superbox.css" rel="stylesheet" type="text/css" />
+
+<script type="text/javascript" src="js/jquery-1.2.6.min.js"></script>
+<script type="text/javascript" src="js/jquery-ui-1.6.custom.min.js"></script>
+<script type="text/javascript" src="js/wizzard.js"></script>
+<script type="text/javascript" src="js/window-controll.js"></script>
+<script type="text/javascript" src="js/window-ui.js"></script>
+
+
+<script type="text/javascript">  
+
+
+
+setTimeout('enterWelcomeScreen()', 1000);
+//setTimeout('artTest()', 1000);
+
+function enterWelcomeScreen() {
+	loadLargeModal("welcome.html");
+}
+function enterLoadGallery() {
+	leaveModal();
+	$("#header").fadeIn("slow");
+	loadSmallModal("load-gallery.html");
+}
+
+function enterPlaceArtwork2() {
+	leaveModal();
+	loadInfoScreen("select-art.html", false);
+}
+
+function developmentMode() {
+	//$("#header").fadeIn("slow");
+	$('#development-screen').fadeIn('slow');
+	leaveModal();
+	//loadSideBar("place-art.html");
+	//$('#wizzard-screen').fadeOut('slow');
+}
+
+function enterPlaceArtwork() {
+	loadSideBar("place-art.html");
+	
+	
+	
+	wizzard_queMessage("You can now drag art work from the side panel into the museum. When you are done selecting your pictures click on me and I will show you what's next. <a href='javascript: wizzard_hideMessage();'>Ok</a>", "");
+	wizzard_nextMessage();
+	wizzard_queMessage("Are you done selecting your artwork? <ul> <li> <a href='javascript:wizzard_reset();enterSelectFrames()'>Yes, take me to the next step. </a></li><li><a href='javascript:wizzard_repeatMessage(); wizzard_hideMessage();'>No, give me some more time.</a></li> ", "Click Me when you're done") ;
+}
+function enterSelectFrames() {
+	$("#sidebar1").fadeOut("slow");
+	wizzard_reset();
+	
+	setTimeout('enterSelectFrames2()', 1000);
+	
+}
+function enterSelectFrames2() {
+	loadSideBar("frames.html");
+	wizzard_queMessage("Great! Now that you decided which paintings you want to display, it's time to select frames for the artwork. <a href='javascript: wizzard_nextMessage();'>Ok</a>", "Click Me When You're done!"); wizzard_nextMessage();
+	wizzard_queMessage("Let's start on the first picture (pretend i moved the camera facing to the first picture). You can now select a frame for this piece of artwork. Once you have chosen your frame click on me. <a href='javascript: wizzard_hideMessage();'>Ok</a>", "Select your frame and click on me.");
+	
+	//wizzard_queMessage("I was only programmed up to this step, does this bother you? <a href='javascript:wizzard_repeatMessage(); wizzard_hideMessage()'>No, of course not!</a> ", "") ;
+	
+	
+}
+
+
+
+</script>  
+
+
+<link href="css/style-common.css" rel="stylesheet" type="text/css" />
+</head>
+
+<body class="twoColLiqRtHdr">
+
+
+<div id="container">
+
+  <div id="header" class="ui" >
+   
+    <ul>
+        <li class="topbarbutton" style="background-position-x: -118px;" onclick="enterLoadGallery();" />&nbsp;</li>
+        <li class="topbarbutton" style="background-position-x: -235px;" onclick="enterSelectFrames();" />&nbsp;</li>
+        <li class="topbarbutton" style="background-position-x: -352px;" onclick="$('#sidebar1').load('walls.html');" />&nbsp;</li>
+        <li class="topbarbutton" style="background-position-x: -469px;" onclick="$('#sidebar1').load('lighting.html')" />&nbsp;</li>
+        <li class="topbarbutton" style="background-position-x: -586px;" onclick="$('#sidebar1').load('save-share.html')" />&nbsp;</li>
+    </ul>
+  </div>
+  
+  
+  <div id="sidebar1" class="ui" >
+    <h3>loading ...</h3>
+  </div>  
+</div>
+
+<div id="mainContent">
+  	<!--<img src="images/screenshot.jpg" width="100%" height="100%" /-->
+</div>
+
+<div id="mode-large-modal" >
+ &nbsp;
+</div>
+<div id="mode-small-modal" >
+ &nbsp;
+</div>
+<div id="mode-screen" >
+ &nbsp;
+</div>
+
+<div id="wizzard-screen" class="ui">
+  	<div id="wizzard-text" class="ui" onclick="">
+    	blabalabalabl
+    </div>
+    <div style="float:left;">
+        <img class="ui" src="images/wizzard.png" width="84" height="93" onclick="wizzard_click();" />
+        <div id="wizzard-mode" class="ui" style="width: 84px; color: #FFF; font-size: 10px; font-weight:bold;">
+         	   
+        </div>
+        
+    </div>
+</div>
+
+
+<div id="info-screen" >
+ &nbsp;
+</div>
+
+<div id="picture-navigation-screen">
+	<ul class="menu ui">
+    	<li id="picture-navigation-previous"></li>
+        <li id="picture-navigation-next"></li>
+        <li id="picture-navigation-map"></li>
+    </ul>
+</div>
+
+
+
+<div id="picture-display-screen" class="ui" style="display: none; padding: auto; position: absolute; z-index: 7005; width: 60%; height: 60%; right: 20%; bottom: 30%;">
+	<img width="100%" height="100%" src="http://www.dennisschaaf.com/bornholm/wp-content/uploads/2009/08/5595_small.jpg"  />
+
+</div>
+<!--
+<div id="picture-info-screen" class="ui">
+	<ul id="info-screen-tabs" class="menu ui">
+    	<li onclick="$('#info-screen-frame').attr('src','http://www.dennisschaaf.com/bornholm/?p=4#content');">Description</li>
+      <li onclick="$('#info-screen-frame').attr('src','http://www.dennisschaaf.com/bornholm/?p=4#comments');">Comments</li>
+        <li onclick="$('#info-screen-frame').attr('src','http://www.dennisschaaf.com/bornholm/?p=4#respond');">Leave Comment</li>
+    </ul>
+    <div id="info-screen-content">
+      <iframe id="info-screen-frame" 
+      		src="http://www.dennisschaaf.com/bornholm/?p=4&embedded=true" 
+            style="position:absolute; left: 11px; top: 37px; width: 643px; height: 193px; border: none;" border="no"></iframe>          
+    </div>
+
+</div>
+-->
+
+<!-- Commont Stuff -->
+
+<div id="black-mode-screen" >
+ &nbsp;
+</div>
+
+<div id="navigation-screen" class="ui">
+	<img id="navigation-picture" src="images/navigation/navigation_default.png" border="0" usemap="#map"/>
+    <map name="map" id="map">
+      <area id="navi_up" shape="poly" coords="76,57,136,7,10,6"  />
+      <area id="navi_down" shape="poly" coords="73,93,8,144,138,141"  />
+      <area id="navi_left" shape="poly" coords="55,74,5,133,7,5"  />
+      <area id="navi_right" shape="poly" coords="93,76,144,4,142,137" />
+    </map>
+</div>
+
+<div id="development-screen" class="ui">
+	<a href="javascript:location.reload();">Reload</a>
+  	<a href="javascript:$('#development-console-screen').toggle();">Console</a>
+	<a href="javascript:$('#navigation-screen').toggle();">Navi</a>
+    Curator:
+	<a href="javascript:$('#header').toggle();">Tb</a>
+	<a href="javascript:$('#wizzard-screen').toggle();">Wiz</a>
+    <a href="javascript:$('#sidebar1').toggle();">Sb</a>
+  	<a href="javascript:$('#info-screen').toggle();">Sb2</a>
+	Critique:
+	<a href="javascript:$('#picture-navigation-screen').toggle();">Pic Navi</a>
+    <a href="javascript:$('#picture-info-screen').toggle();">Info</a>
+    <a href="javascript:$('#black-mode-screen').toggle();$('#picture-display-screen').toggle();">pic</a>
+
+</div>
+
+<div id="development-console-screen" class="ui" >
+	Console
+	<p id="development-console">&nbsp; 
+	</p>
+	<p>
+		<input id="console-input" type="text" size="30" >
+		<input type="button" onclick="debug(eval($('#console-input').val()));" value="run">
+	</p>
+
+</div>
+
+</body>
+</html>
diff --git a/liboh/src/HostedObject.cpp b/liboh/src/HostedObject.cpp
index bedd097..cbc84b6 100644
--- a/liboh/src/HostedObject.cpp
+++ b/liboh/src/HostedObject.cpp
@@ -1,1272 +1,1272 @@
-/*  Sirikata liboh -- Object Host
- *  HostedObject.cpp
- *
- *  Copyright (c) 2009, Patrick Reiter Horn
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are
- *  met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name of Sirikata nor the names of its contributors may
- *    be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <util/Platform.hpp>
-#include <oh/Platform.hpp>
-#include <ObjectHost_Sirikata.pbj.hpp>
-#include <ObjectHost_Persistence.pbj.hpp>
-#include <task/WorkQueue.hpp>
-#include "util/RoutableMessage.hpp"
-#include "util/KnownServices.hpp"
-#include "persistence/PersistenceSentMessage.hpp"
-#include "network/Stream.hpp"
-#include "util/SpaceObjectReference.hpp"
-#include "oh/SpaceConnection.hpp"
-#include "oh/TopLevelSpaceConnection.hpp"
-#include "oh/HostedObject.hpp"
-#include "util/SentMessage.hpp"
-#include "oh/ObjectHost.hpp"
-#include "oh/ProxyMeshObject.hpp"
-#include "oh/ProxyLightObject.hpp"
-#include "oh/ProxyCameraObject.hpp"
-#include "oh/LightInfo.hpp"
-#include "oh/ObjectScriptManager.hpp"
-#include "oh/ObjectScript.hpp"
-#include "oh/ObjectScriptManagerFactory.hpp"
-#include <util/KnownServices.hpp>
-
-namespace Sirikata {
-
-typedef SentMessageBody<RoutableMessageBody> RPCMessage;
-
-class HostedObject::PerSpaceData {
-public:
-    SpaceConnection mSpaceConnection;
-    ProxyObjectPtr mProxyObject;
-    ProxyObject::Extrapolator mUpdatedLocation;
-
-    void locationWasReset(Time timestamp, Location loc) {
-        loc.setVelocity(Vector3f::nil());
-        loc.setAngularSpeed(0);
-        mUpdatedLocation.resetValue(timestamp, loc);
-    }
-    void locationWasSet(const Protocol::ObjLoc &msg) {
-        Time timestamp = msg.timestamp();
-        Location loc = mUpdatedLocation.extrapolate(timestamp);
-        ProxyObject::updateLocationWithObjLoc(loc, msg);
-        loc.setVelocity(Vector3f::nil());
-        loc.setAngularSpeed(0);
-        mUpdatedLocation.updateValue(timestamp, loc);
-    }
-
-    void updateLocation(HostedObject *ho) {
-        if (!mProxyObject) {
-            return;
-        }
-        SpaceID space = mProxyObject->getObjectReference().space();
-        Time now = Time::now(ho->getSpaceTimeOffset(space));
-        Location realLocation = mProxyObject->globalLocation(now);
-        if (mUpdatedLocation.needsUpdate(now, realLocation)) {
-            Protocol::ObjLoc toSet;
-            toSet.set_position(realLocation.getPosition());
-            toSet.set_velocity(realLocation.getVelocity());
-            RoutableMessageBody body;
-            toSet.SerializeToString(body.add_message("ObjLoc"));
-            RoutableMessageHeader header;
-            header.set_destination_port(Services::LOC);
-            header.set_destination_object(ObjectReference::spaceServiceID());
-            header.set_destination_space(space);
-            std::string bodyStr;
-            body.SerializeToString(&bodyStr);
-            // Avoids waiting a loop.
-            ho->sendViaSpace(header, MemoryReference(bodyStr));
-
-            locationWasSet(toSet);
-        }
-    }
-
-    typedef std::map<uint32, std::set<ObjectReference> > ProxQueryMap;
-    ProxQueryMap mProxQueryMap; ///< indexed by ProxCall::query_id()
-
-    PerSpaceData(const std::tr1::shared_ptr<TopLevelSpaceConnection>&topLevel,Network::Stream*stream)
-        :mSpaceConnection(topLevel,stream),
-        mUpdatedLocation(
-            Duration::seconds(.1),
-            TemporalValue<Location>::Time::null(),
-            Location(Vector3d(0,0,0),Quaternion(Quaternion::identity()),
-                     Vector3f(0,0,0),Vector3f(0,1,0),0),
-            ProxyObject::UpdateNeeded()) {
-    }
-};
-
-
- 
-HostedObject::HostedObject(ObjectHost*parent, const UUID &objectName)
-    : mTracker(parent->getSpaceIO()),
-      mInternalObjectReference(objectName) {
-    mSpaceData = new SpaceDataMap;
-    mObjectHost=parent;
-    mObjectScript=NULL;
-    mSendService.ho = this;
-    mReceiveService.ho = this;
-    mTracker.forwardMessagesTo(&mSendService);
-}
-
-HostedObject::~HostedObject() {
-    if (mObjectScript) {
-        delete mObjectScript;
-    }
-    for (SpaceDataMap::const_iterator iter = mSpaceData->begin();
-         iter != mSpaceData->end();
-         ++iter) {
-        for (PerSpaceData::ProxQueryMap::const_iterator qiter = iter->second.mProxQueryMap.begin();
-             qiter != iter->second.mProxQueryMap.end();
-             ++qiter) {
-            for (std::set<ObjectReference>::const_iterator oriter = qiter->second.begin();
-                 oriter != qiter->second.end();
-                 ++oriter)
-            {
-                iter->second.mSpaceConnection.getTopLevelStream()->
-                    destroyViewedObject(SpaceObjectReference(iter->first, *oriter), getTracker());
-            }
-        }
-    }
-    mObjectHost->unregisterHostedObject(mInternalObjectReference);
-    mTracker.endForwardingMessagesTo(&mSendService);
-    delete mSpaceData;
-}
-
-struct HostedObject::PrivateCallbacks {
-
-    static void initializeDatabaseCallback(
-        HostedObject *realThis,
-        const SpaceID &spaceID,
-        Persistence::SentReadWriteSet *msg,
-        const RoutableMessageHeader &lastHeader,
-        Persistence::Protocol::Response::ReturnStatus errorCode)
-    {
-        if (lastHeader.has_return_status() || errorCode) {
-            SILOG(cppoh,error,"Database error recieving Loc and scripting info: "<<(int)lastHeader.return_status()<<": "<<(int)errorCode);
-            delete msg;
-            return; // unable to get starting position.
-        }
-        String scriptName;
-        std::map<String,String> scriptParams;
-        Location location(Vector3d::nil(),Quaternion::identity(),Vector3f::nil(),Vector3f(1,0,0),0);
-        for (int i = 0; i < msg->body().reads_size(); i++) {
-            String name = msg->body().reads(i).field_name();
-            if (msg->body().reads(i).has_return_status() || !msg->body().reads(i).has_data()) {
-                continue;
-            }
-            if (!name.empty() && name[0] != '_') {
-                realThis->setProperty(name, msg->body().reads(i).data());
-            }
-            if (name == "Loc") {
-                ObjLoc loc;
-                loc.ParseFromString(msg->body().reads(i).data());
-                SILOG(cppoh,debug,"Creating object "<<ObjectReference(realThis->getUUID())
-                      <<" at position "<<loc.position());
-                if (loc.has_position()) {
-                    location.setPosition(loc.position());
-                }
-                if (loc.has_orientation()) {
-                    location.setOrientation(loc.orientation());
-                }
-                if (loc.has_velocity()) {
-                    location.setVelocity(loc.velocity());
-                }
-                if (loc.has_rotational_axis()) {
-                    location.setAxisOfRotation(loc.rotational_axis());
-                }
-                if (loc.has_angular_speed()) {
-                    location.setAngularSpeed(loc.angular_speed());
-                }
-            }
-            if (name == "_Script") {
-                Protocol::StringProperty scrProp;
-                scrProp.ParseFromString(msg->body().reads(i).data());
-                scriptName = scrProp.value();
-            }
-            if (name == "_ScriptParams") {
-                Protocol::StringMapProperty scrProp;
-                scrProp.ParseFromString(msg->body().reads(i).data());
-                int numkeys = scrProp.keys_size();
-                {
-                    int numvalues = scrProp.values_size();
-                    if (numvalues < numkeys) {
-                        numkeys = numvalues;
-                    }
-                }
-                for (int i = 0; i < numkeys; i++) {
-                    scriptParams[scrProp.keys(i)] = scrProp.values(i);
-                }
-            }
-        }
-        // Temporary Hack because we do not have access to the CDN here.
-        BoundingSphere3f sphere(Vector3f::nil(),1);
-        realThis->sendNewObj(location, sphere, spaceID);
-        delete msg;
-        if (!scriptName.empty()) {
-            realThis->initializeScript(scriptName, scriptParams);
-        }
-        realThis->mObjectHost->getWorkQueue()->dequeueAll();
-    }
-
-    static void receivedRoutableMessage(const HostedObjectWPtr&thus,const SpaceID&sid, const Network::Chunk&msgChunk) {
-        HostedObjectPtr realThis (thus.lock());
-
-        RoutableMessageHeader header;
-        MemoryReference bodyData = header.ParseFromArray(&(msgChunk[0]),msgChunk.size());
-        header.set_source_space(sid);
-        header.set_destination_space(sid);
-        {
-            ProxyObjectPtr destinationObject = realThis->getProxy(header.source_space());
-            if (destinationObject) {
-                header.set_destination_object(destinationObject->getObjectReference().object());
-            }
-            if (!header.has_source_object()) {
-                header.set_source_object(ObjectReference::spaceServiceID());
-            }
-        }
-
-        if (!realThis) {
-            SILOG(objecthost,error,"Received message for dead HostedObject. SpaceID = "<<sid<<"; DestObject = "<<header.destination_object());
-            return;
-        }
-
-        realThis->processRoutableMessage(header, bodyData);
-    }
-
-    static void handlePersistenceResponse(
-        HostedObject *realThis,
-        const RoutableMessageHeader &origHeader,
-        SentMessage *sent,
-        const RoutableMessageHeader &header,
-        MemoryReference bodyData)
-    {
-        std::auto_ptr<SentMessageBody<Persistence::Protocol::ReadWriteSet> > sentDestruct(static_cast<SentMessageBody<Persistence::Protocol::ReadWriteSet> *>(sent));
-        SILOG(cppoh,debug,"Got some persistence back: stat = "<<(int)header.return_status());
-        if (header.has_return_status()) {
-            Persistence::Protocol::Response resp;
-            for (int i = 0, respIndex=0; i < sentDestruct->body().reads_size(); i++, respIndex++) {
-                Persistence::Protocol::IStorageElement field = resp.add_reads();
-                if (sentDestruct->body().reads(i).has_index()) {
-                    field.set_index(sentDestruct->body().reads(i).index());
-                }
-                if (sentDestruct->body().options() & Persistence::Protocol::ReadWriteSet::RETURN_READ_NAMES) {
-                    field.set_field_name(sentDestruct->body().reads(i).field_name());
-                }
-                field.set_return_status(Persistence::Protocol::StorageElement::KEY_MISSING);
-            }
-            std::string errorData;
-            resp.SerializeToString(&errorData);
-            realThis->sendReply(origHeader, MemoryReference(errorData));
-        } else {
-            realThis->sendReply(origHeader, bodyData);
-        }
-        realThis->mObjectHost->getWorkQueue()->dequeueAll();
-    }
-    static void handlePersistenceMessage(HostedObject *realThis, const RoutableMessageHeader &header, MemoryReference bodyData) {
-        using namespace Persistence::Protocol;
-
-        ReadWriteSet rws;
-        rws.ParseFromArray(bodyData.data(), bodyData.length());
-
-        Response immedResponse;
-        int immedIndex = 0;
-
-        SentMessageBody<ReadWriteSet> *persistenceMsg = new SentMessageBody<ReadWriteSet>(&realThis->mTracker,std::tr1::bind(&handlePersistenceResponse, realThis, header, _1, _2, _3));
-        int outIndex = 0;
-        ReadWriteSet &outMessage = persistenceMsg->body();
-        if (rws.has_options()) {
-            outMessage.set_options(rws.options());
-        }
-        SILOG(cppoh,debug,"Got a Persistence message: reads size = "<<rws.reads_size()<<
-              " writes size = "<<rws.writes_size());
-
-        for (int i = 0, rwsIndex=0 ; i < rws.reads_size(); i++, rwsIndex++) {
-            if (rws.reads(i).has_index()) {
-                rwsIndex = rws.reads(i).index();
-            }
-            std::string name;
-            if (rws.reads(i).has_field_name()) {
-                name = rws.reads(i).field_name();
-            }
-            bool fail = false;
-            if (name.empty() || name[0] == '_') {
-                SILOG(cppoh,debug,"Invalid GetProp: "<<name);
-                fail = true;
-            } else {
-                if (realThis->hasProperty(name)) {
-                    // Cached property--respond immediately.
-                    SILOG(cppoh,debug,"Cached GetProp: "<<name<<" = "<<realThis->getProperty(name));
-                    IStorageElement el = immedResponse.add_reads();
-                    if (immedIndex != rwsIndex) {
-                        el.set_index(rwsIndex);
-                    }
-                    immedIndex = rwsIndex+1;
-                    if (rws.options() & ReadWriteSet::RETURN_READ_NAMES) {
-                        el.set_field_name(rws.reads(i).field_name());
-                    }
-                    el.set_data(realThis->getProperty(name));
-                } else {
-                    SILOG(cppoh,debug,"Forward GetProp: "<<name<<" to Persistence");
-                    IStorageElement el = outMessage.add_reads();
-                    if (outIndex != rwsIndex) {
-                        el.set_index(rwsIndex);
-                    }
-                    outIndex = rwsIndex+1;
-                    el.set_field_name(rws.reads(i).field_name());
-                    el.set_object_uuid(realThis->getUUID());
-                }
-            }
-            if (fail) {
-                IStorageElement el = immedResponse.add_reads();
-                if (immedIndex != rwsIndex) {
-                    el.set_index(rwsIndex);
-                }
-                immedIndex = rwsIndex+1;
-                if (rws.options() & ReadWriteSet::RETURN_READ_NAMES) {
-                    el.set_field_name(rws.reads(i).field_name());
-                }
-                el.set_return_status(StorageElement::KEY_MISSING);
-            }
-        }
-        outIndex = 0;
-        for (int i = 0, rwsIndex=0 ; i < rws.writes_size(); i++, rwsIndex++) {
-            if (rws.writes(i).has_index()) {
-                rwsIndex = rws.writes(i).index();
-            }
-            std::string name;
-            if (rws.writes(i).has_field_name()) {
-                name = rws.writes(i).field_name();
-            }
-            bool fail = false;
-            if (name.empty() || name[0] == '_') {
-                SILOG(cppoh,debug,"Invalid SetProp: "<<name);
-                fail = true;
-            } else {
-                if (rws.writes(i).has_data()) {
-                    realThis->setProperty(name, rws.writes(i).data());
-                    SpaceDataMap::iterator iter;
-                    for (iter = realThis->mSpaceData->begin();
-                         iter != realThis->mSpaceData->end();
-                         ++iter) {
-                        realThis->receivedPropertyUpdate(iter->second.mProxyObject, name, rws.writes(i).data());
-                    }
-                } else {
-                    if (name != "LightInfo" && name != "MeshURI" && name != "IsCamera") {
-                        // changing the type of this object has to wait until we reload from database.
-                        realThis->unsetProperty(name);
-                    }
-                }
-                SILOG(cppoh,debug,"Forward SetProp: "<<name<<" to Persistence");
-                IStorageElement el = outMessage.add_writes();
-                if (outIndex != rwsIndex) {
-                    el.set_index(rwsIndex);
-                }
-                outIndex = rwsIndex+1;
-                el.set_field_name(rws.writes(i).field_name());
-                if (rws.writes(i).has_data()) {
-                    el.set_data(rws.writes(i).data());
-                }
-                el.set_object_uuid(realThis->getUUID());
-            }
-            // what to do if a write fails?
-        }
-
-        if (immedResponse.reads_size()) {
-            SILOG(cppoh,debug,"ImmedResponse: "<<immedResponse.reads_size());
-            std::string respStr;
-            immedResponse.SerializeToString(&respStr);
-            RoutableMessageHeader respHeader (header);
-            realThis->sendReply(respHeader, MemoryReference(respStr));
-        }
-        if (outMessage.reads_size() || outMessage.writes_size()) {
-            SILOG(cppoh,debug,"ForwardToPersistence: "<<outMessage.reads_size()<<
-                  " reads and "<<outMessage.writes_size()<<"writes");
-            persistenceMsg->header().set_destination_space(SpaceID::null());
-            persistenceMsg->header().set_destination_object(ObjectReference::spaceServiceID());
-            persistenceMsg->header().set_destination_port(Services::PERSISTENCE);
-
-            persistenceMsg->serializeSend();
-        } else {
-            delete persistenceMsg;
-        }
-        realThis->mObjectHost->getWorkQueue()->dequeueAll();
-    }
-    static void handleRPCMessage(HostedObject *realThis, const RoutableMessageHeader &header, MemoryReference bodyData) {
-        /// Parse message_names and message_arguments.
-
-        RoutableMessageBody msg;
-        msg.ParseFromArray(bodyData.data(), bodyData.length());
-        int numNames = msg.message_size();
-        if (numNames <= 0) {
-            // Invalid message!
-            realThis->sendErrorReply(header, RoutableMessageHeader::PROTOCOL_ERROR);
-            return;
-        }
-
-        RoutableMessageBody responseMessage;
-        for (int i = 0; i < numNames; ++i) {
-            std::string name = msg.message_names(i);
-            MemoryReference body(msg.message_arguments(i));
-
-            if (header.has_id()) {
-                std::string response;
-                /// Pass response parameter if we expect a response.
-                realThis->processRPC(header, name, body, &response);
-                responseMessage.add_message_reply(response);
-            } else {
-                /// Return value not needed.
-                realThis->processRPC(header, name, body, NULL);
-            }
-        }
-
-        if (header.has_id()) {
-            std::string serializedResponse;
-            responseMessage.SerializeToString(&serializedResponse);
-            realThis->sendReply(header, MemoryReference(serializedResponse));
-        }
-    }
-
-    static void receivedProxObjectLocation(
-        const HostedObjectWPtr &weakThis,
-        SentMessage* sentMessage,
-        const RoutableMessageHeader &hdr,
-        MemoryReference bodyData,
-        int32 queryId)
-    {
-        std::auto_ptr<RPCMessage> destructor(static_cast<RPCMessage*>(sentMessage));
-        HostedObjectPtr realThis(weakThis.lock());
-        if (!realThis) {
-            return;
-        }
-
-        RoutableMessage responseMessage(hdr, bodyData.data(), bodyData.length());
-        if (responseMessage.header().return_status() != RoutableMessageHeader::SUCCESS) {
-            SILOG(cppoh,info,"FAILURE receiving prox object properties "<<sentMessage->getRecipient());
-            return;
-        }
-        ObjLoc objLoc;
-        objLoc.ParseFromString(responseMessage.body().message_arguments(0));
-
-        Persistence::SentReadWriteSet *request = new Persistence::SentReadWriteSet(&realThis->mTracker);
-
-        request->header().set_destination_space(sentMessage->getSpace());
-        request->header().set_destination_object(sentMessage->getRecipient());
-        request->header().set_destination_port(Services::PERSISTENCE);
-
-        request->body().add_reads().set_field_name("MeshURI");
-        request->body().add_reads().set_field_name("MeshScale");
-        request->body().add_reads().set_field_name("Name");
-        request->body().add_reads().set_field_name("PhysicalParameters");
-        request->body().add_reads().set_field_name("LightInfo");
-        request->body().add_reads().set_field_name("_Passwd");
-        request->body().add_reads().set_field_name("IsCamera");
-        request->body().add_reads().set_field_name("Parent");
-        request->setPersistenceCallback(std::tr1::bind(&PrivateCallbacks::receivedProxObjectProperties,
-                                            weakThis, _1, _2, _3,
-                                            queryId, objLoc));
-        request->setTimeout(Duration::seconds(5.0));
-        request->serializeSend();
-    }
-    static void receivedProxObjectProperties(
-        const HostedObjectWPtr &weakThis,
-        SentMessage* sentMessageBase,
-        const RoutableMessageHeader &hdr,
-        Persistence::Protocol::Response::ReturnStatus returnStatus,
-        int32 queryId,
-        const ObjLoc &objLoc)
-    {
-        using namespace Persistence::Protocol;
-        std::auto_ptr<Persistence::SentReadWriteSet> sentMessage(Persistence::SentReadWriteSet::cast_sent_message(sentMessageBase));
-        HostedObjectPtr realThis(weakThis.lock());
-        if (!realThis) {
-            return;
-        }
-        SpaceDataMap::iterator iter = realThis->mSpaceData->find(sentMessage->getSpace());
-        if (iter == realThis->mSpaceData->end()) {
-            return;
-        }
-        ObjectHostProxyManager *proxyMgr = iter->second.mSpaceConnection.getTopLevelStream().get();
-        PerSpaceData::ProxQueryMap::iterator qmiter = iter->second.mProxQueryMap.find(queryId);
-        if (qmiter == iter->second.mProxQueryMap.end()) {
-            return;
-        }
-        std::set<ObjectReference>::iterator proxyiter = qmiter->second.find(sentMessage->getRecipient());
-        if (proxyiter == qmiter->second.end()) {
-            return;
-        }
-        SpaceObjectReference proximateObjectId(sentMessage->getSpace(), sentMessage->getRecipient());
-        bool persistence_error = false;
-        if (hdr.return_status() != RoutableMessageHeader::SUCCESS ||returnStatus) {
-            SILOG(cppoh,info,"FAILURE receiving prox object properties "<<
-                  proximateObjectId.object()<<": Error = "<<(int)hdr.return_status());
-            persistence_error = true;
-        }
-        SILOG(cppoh,debug,"Received prox object properties "<<proximateObjectId.object()<<": reads size = ?");
-        int index = 0;
-        bool haveAll = true;
-        for (int i = 0; i < sentMessage->body().reads_size(); i++) {
-            if (!sentMessage->body().reads(i).has_data() && !sentMessage->body().reads(i).has_return_status()) {
-                haveAll = false;
-            }
-        }
-        if (persistence_error || haveAll) {
-
-        } else {
-            assert(false&&"Received incomplete persistence callback for the same read/write set: should only ever get one");
-            return; // More messages would have come before the new design.
-        }
-        bool hasMesh=false;
-        bool hasLight=false;
-        bool isCamera=false;
-        ProxyObjectPtr proxyObj;
-        for (int i = 0; i < sentMessage->body().reads_size(); ++i) {
-            if (sentMessage->body().reads(i).has_return_status()) {
-                continue;
-            }
-            const std::string &field = sentMessage->body().reads(i).field_name();
-            if (field == "MeshURI") {
-                hasMesh = true;
-            }
-            if (field == "LightInfo") {
-                hasLight = true;
-            }
-            if (field == "IsCamera") {
-                isCamera = true;
-            }
-        }
-        ObjectReference myObjectReference;
-        if (isCamera) {
-            SILOG(cppoh,info, "* I found a camera named " << proximateObjectId.object());
-            proxyObj = ProxyObjectPtr(new ProxyCameraObject(proxyMgr, proximateObjectId));
-        } else if (hasLight && !hasMesh) {
-            SILOG(cppoh,info, "* I found a light named " << proximateObjectId.object());
-            proxyObj = ProxyObjectPtr(new ProxyLightObject(proxyMgr, proximateObjectId));
-        } else {
-            SILOG(cppoh,info, "* I found a MESH named " << proximateObjectId.object());
-            proxyObj = ProxyObjectPtr(new ProxyMeshObject(proxyMgr, proximateObjectId));
-        }
-        proxyObj->setLocal(false);
-        realThis->receivedPositionUpdate(proxyObj, objLoc, true);
-        proxyMgr->createViewedObject(proxyObj, realThis->getTracker());
-        for (int i = 0; i < sentMessage->body().reads_size(); ++i) {
-            if (sentMessage->body().reads(i).has_return_status()) {
-                continue;
-            }
-            const std::string &field = sentMessage->body().reads(i).field_name();
-            realThis->receivedPropertyUpdate(proxyObj, sentMessage->body().reads(i).field_name(), sentMessage->body().reads(i).data());
-        }
-        {
-            RPCMessage *request = new RPCMessage(&realThis->mTracker,std::tr1::bind(&receivedPositionUpdateResponse, weakThis, _1, _2, _3));
-            request->header().set_destination_space(proximateObjectId.space());
-            request->header().set_destination_object(proximateObjectId.object());
-            Protocol::LocRequest loc;
-            loc.SerializeToString(request->body().add_message("LocRequest"));
-            request->serializeSend();
-        }
-        return;
-    }
-
-    static void receivedPositionUpdateResponse(
-        const HostedObjectWPtr &weakThus,
-        SentMessage* sentMessage,
-        const RoutableMessageHeader &hdr,
-        MemoryReference bodyData)
-    {
-        RoutableMessage responseMessage(hdr, bodyData.data(), bodyData.length());
-        HostedObjectPtr thus(weakThus.lock());
-        if (!thus) {
-            delete static_cast<RPCMessage*>(sentMessage);
-        }
-        if (responseMessage.header().return_status()) {
-            return;
-        }
-        Protocol::ObjLoc loc;
-        loc.ParseFromString(responseMessage.body().message_arguments(0));
-
-        const SpaceID &space = sentMessage->getSpace();
-        ProxyManager *pm = thus->getObjectHost()->getProxyManager(space);
-        if (pm) {
-            ProxyObjectPtr obj(pm->getProxyObject(
-                SpaceObjectReference(space, sentMessage->getRecipient())));
-            if (obj) {
-                thus->receivedPositionUpdate(obj,loc,false);
-            }
-        }
-
-        static_cast<RPCMessage*>(sentMessage)->serializeSend(); // Resend position update each time we get one.
-    }
-
-    static void disconnectionEvent(const HostedObjectWPtr&weak_thus,const SpaceID&sid, const String&reason) {
-        std::tr1::shared_ptr<HostedObject>thus=weak_thus.lock();
-        if (thus) {
-            SpaceDataMap::iterator where=thus->mSpaceData->find(sid);
-            if (where!=thus->mSpaceData->end()) {
-                thus->mSpaceData->erase(where);//FIXME do we want to back this up to the database first?
-            }
-        }
-    }
-
-    static void connectionEvent(const HostedObjectWPtr&thus,
-                                const SpaceID&sid,
-                                Network::Stream::ConnectionStatus ce,
-                                const String&reason) {
-        if (ce!=Network::Stream::Connected) {
-            disconnectionEvent(thus,sid,reason);
-        }
-    }
-};
-
-HostedObject::PerSpaceData& HostedObject::cloneTopLevelStream(const SpaceID&sid,const std::tr1::shared_ptr<TopLevelSpaceConnection>&tls) {
-    using std::tr1::placeholders::_1;
-    using std::tr1::placeholders::_2;
-    SpaceDataMap::iterator iter = mSpaceData->insert(
-        SpaceDataMap::value_type(
-            sid,
-            PerSpaceData(tls,
-                         tls->topLevelStream()->clone(
-                             std::tr1::bind(&PrivateCallbacks::connectionEvent,
-                                            getWeakPtr(),
-                                            sid,
-                                            _1,
-                                            _2),
-                             std::tr1::bind(&PrivateCallbacks::receivedRoutableMessage,
-                                            getWeakPtr(),
-                                            sid,
-                                            _1))))).first;
-    return iter->second;
-}
-
-static String nullProperty;
-bool HostedObject::hasProperty(const String &propName) const {
-    PropertyMap::const_iterator iter = mProperties.find(propName);
-    return (iter != mProperties.end());
-}
-const String &HostedObject::getProperty(const String &propName) const {
-    PropertyMap::const_iterator iter = mProperties.find(propName);
-    if (iter != mProperties.end()) {
-        return (*iter).second;
-    }
-    return nullProperty;
-}
-String *HostedObject::propertyPtr(const String &propName) {
-    return &(mProperties[propName]);
-}
-void HostedObject::setProperty(const String &propName, const String &encodedValue) {
-    mProperties.insert(PropertyMap::value_type(propName, encodedValue));
-}
-void HostedObject::unsetProperty(const String &propName) {
-    PropertyMap::iterator iter = mProperties.find(propName);
-    if (iter != mProperties.end()) {
-        mProperties.erase(iter);
-    }
-}
-
-
-static ProxyObjectPtr nullPtr;
-const ProxyObjectPtr &HostedObject::getProxy(const SpaceID &space) const {
-    SpaceDataMap::const_iterator iter = mSpaceData->find(space);
-    if (iter == mSpaceData->end()) {
-        return nullPtr;
-    }
-    return iter->second.mProxyObject;
-}
-
-
-using Sirikata::Protocol::NewObj;
-using Sirikata::Protocol::IObjLoc;
-
-void HostedObject::sendNewObj(
-    const Location&startingLocation,
-    const BoundingSphere3f &meshBounds,
-    const SpaceID&spaceID)
-{
-
-    RoutableMessageHeader messageHeader;
-    messageHeader.set_destination_object(ObjectReference::spaceServiceID());
-    messageHeader.set_destination_space(spaceID);
-    messageHeader.set_destination_port(Services::REGISTRATION);
-    NewObj newObj;
-    newObj.set_object_uuid_evidence(getUUID());
-    newObj.set_bounding_sphere(meshBounds);
-    IObjLoc loc = newObj.mutable_requested_object_loc();
-    loc.set_timestamp(Time::now(getSpaceTimeOffset(spaceID)));
-    loc.set_position(startingLocation.getPosition());
-    loc.set_orientation(startingLocation.getOrientation());
-    loc.set_velocity(startingLocation.getVelocity());
-    loc.set_rotational_axis(startingLocation.getAxisOfRotation());
-    loc.set_angular_speed(startingLocation.getAngularSpeed());
-
-    RoutableMessageBody messageBody;
-    newObj.SerializeToString(messageBody.add_message("NewObj"));
-
-    std::string serializedBody;
-    messageBody.SerializeToString(&serializedBody);
-    sendViaSpace(messageHeader, MemoryReference(serializedBody));
-}
-
-void HostedObject::initializeConnect(
-    const Location&startingLocation,
-    const String&mesh, const BoundingSphere3f&meshBounds,
-    const LightInfo *lightInfo,
-    const SpaceID&spaceID, const HostedObjectPtr&spaceConnectionHint)
-{
-    mObjectHost->registerHostedObject(getSharedPtr());
-    connectToSpace(spaceID, spaceConnectionHint);
-    sendNewObj(startingLocation, meshBounds, spaceID);
-    mObjectHost->getWorkQueue()->dequeueAll(); // don't need to wait until next frame.
-
-    if (!mesh.empty()) {
-        Protocol::StringProperty meshprop;
-        meshprop.set_value(mesh);
-        meshprop.SerializeToString(propertyPtr("MeshURI"));
-        Protocol::Vector3fProperty scaleprop;
-        scaleprop.set_value(Vector3f(1,1,1)); // default value, set it manually if you want different.
-        scaleprop.SerializeToString(propertyPtr("MeshScale"));
-        Protocol::PhysicalParameters physicalprop;
-        physicalprop.set_mode(Protocol::PhysicalParameters::NONPHYSICAL);
-        physicalprop.SerializeToString(propertyPtr("PhysicalParameters"));
-    } else if (lightInfo) {
-        Protocol::LightInfoProperty lightProp;
-        lightInfo->toProtocol(lightProp);
-        lightProp.SerializeToString(propertyPtr("LightInfo"));
-    } else {
-        setProperty("IsCamera");
-    }
-}
-void HostedObject::initializePythonScript() {
-    ObjectScriptManager *mgr = ObjectScriptManagerFactory::getSingleton().getDefaultConstructor()("");
-    if (mgr) {
-        ObjectScriptManager::Arguments args;
-        args["Assembly"]="Sirikata.Runtime";
-        args["Class"]="PythonObject";
-        args["Namespace"]="Sirikata.Runtime";
-        args["PythonModule"]="test";
-        args["PythonClass"]="exampleclass";
-
-        mObjectScript=mgr->createObjectScript(this,args);
-        if (mObjectScript) {
-            mObjectScript->tick();
-        }
-    }
-}
-
-void HostedObject::initializeRestoreFromDatabase(const SpaceID&spaceID, const HostedObjectPtr&spaceConnectionHint) {
-    mObjectHost->registerHostedObject(getSharedPtr());
-    connectToSpace(spaceID, spaceConnectionHint);
-
-    Persistence::SentReadWriteSet *msg;
-    msg = new Persistence::SentReadWriteSet(&mTracker);
-    msg->setPersistenceCallback(std::tr1::bind(
-                         &PrivateCallbacks::initializeDatabaseCallback,
-                         this, spaceID,
-                         _1, _2, _3));
-    msg->body().add_reads().set_field_name("MeshURI");
-    msg->body().add_reads().set_field_name("MeshScale");
-    msg->body().add_reads().set_field_name("Name");
-    msg->body().add_reads().set_field_name("PhysicalParameters");
-    msg->body().add_reads().set_field_name("LightInfo");
-    msg->body().add_reads().set_field_name("IsCamera");
-    msg->body().add_reads().set_field_name("Parent");
-    msg->body().add_reads().set_field_name("Loc");
-    msg->body().add_reads().set_field_name("_Script");
-    msg->body().add_reads().set_field_name("_ScriptParams");
-    for (int i = 0; i < msg->body().reads_size(); i++) {
-        msg->body().reads(i).set_object_uuid(getUUID()); // database assumes uuid 0 if omitted
-    }
-    msg->header().set_destination_object(ObjectReference::spaceServiceID());
-    msg->header().set_destination_port(Services::PERSISTENCE);
-    msg->serializeSend();
-    mObjectHost->getWorkQueue()->dequeueAll(); // don't need to wait until next frame.
-}
-void HostedObject::initializeScript(const String& script, const ObjectScriptManager::Arguments &args) {
-    assert(!mObjectScript); // Don't want to kill a live script!
-    mObjectHost->registerHostedObject(getSharedPtr());
-    ObjectScriptManager *mgr = ObjectScriptManagerFactory::getSingleton().getConstructor(script)("");
-    if (mgr) {
-        mObjectScript = mgr->createObjectScript(this, args);
-    }
-}
-void HostedObject::connectToSpace(const SpaceID&id,const HostedObjectPtr&spaceConnectionHint) {
-    if (id!=SpaceID::null()) {
-        //bind script to object...script might be a remote ID, so need to bind download target, etc
-        std::tr1::shared_ptr<TopLevelSpaceConnection> topLevelConnection;
-        SpaceDataMap::iterator where;
-        if (spaceConnectionHint&&(where=spaceConnectionHint->mSpaceData->find(id))!=mSpaceData->end()) {
-            topLevelConnection=where->second.mSpaceConnection.getTopLevelStream();
-        }else {
-            topLevelConnection=mObjectHost->connectToSpace(id);
-        }
-
-        // sending initial packet is done by the script!
-        //conn->send(initializationPacket,Network::ReliableOrdered);
-        PerSpaceData &psd = cloneTopLevelStream(id,topLevelConnection);
-        // return &(psd.mSpaceConnection);
-    }
-}
-
-void HostedObject::processRoutableMessage(const RoutableMessageHeader &header, MemoryReference bodyData) {
-    std::string myself_name;
-    {
-        std::ostringstream os;
-        if (header.has_destination_object()) {
-            os << header.destination_object();
-        } else {
-            os << "[Temporary UUID " << mInternalObjectReference.toString() << "]";
-        }
-        myself_name = os.str();
-    }
-    {
-        std::ostringstream os;
-        os << "** Message from: " << header.source_object() << " port " << header.source_port() << " to "<<myself_name<<" port " << header.destination_port();
-        SILOG(cppoh,debug,os.str());
-    }
-    /// Handle Return values to queries we sent to someone:
-    if (header.has_reply_id()) {
-        mTracker.processMessage(header, bodyData);
-        return; // Not a message for us to process.
-    }
-
-    if (header.destination_port() == 0) {
-        PrivateCallbacks::handleRPCMessage(this, header, bodyData);
-    } else if (header.destination_port() == Services::PERSISTENCE) {
-        PrivateCallbacks::handlePersistenceMessage(this, header, bodyData);
-    } else {
-        if (mObjectScript) {
-            mObjectScript->processMessage(header, bodyData);
-        } else {
-            sendErrorReply(header, RoutableMessageHeader::PORT_FAILURE);
-        }
-    }
-}
-
-void HostedObject::sendViaSpace(const RoutableMessageHeader &hdrOrig, MemoryReference body) {
-    ///// MessageService::processMessage
-    assert(hdrOrig.has_destination_object());
-    assert(hdrOrig.has_destination_space());
-    SpaceDataMap::iterator where=mSpaceData->find(hdrOrig.destination_space());
-    if (where!=mSpaceData->end()) {
-        RoutableMessageHeader hdr (hdrOrig);
-        hdr.clear_destination_space();
-        hdr.clear_source_space();
-        hdr.clear_source_object();
-        String serialized_header;
-        hdr.SerializeToString(&serialized_header);
-        where->second.mSpaceConnection.getStream()->send(MemoryReference(serialized_header),body, Network::ReliableOrdered);
-    }
-    assert(where!=mSpaceData->end());
-}
-
-void HostedObject::send(const RoutableMessageHeader &hdrOrig, MemoryReference body) {
-    assert(hdrOrig.has_destination_object());
-    if (!hdrOrig.has_destination_space() || hdrOrig.destination_space() == SpaceID::null()) {
-        RoutableMessageHeader hdr (hdrOrig);
-        hdr.set_destination_space(SpaceID::null());
-        hdr.set_source_object(ObjectReference(mInternalObjectReference));
-        mObjectHost->processMessage(hdr, body);
-        return;
-    }
-    SpaceDataMap::iterator where=mSpaceData->find(hdrOrig.destination_space());
-    if (where!=mSpaceData->end()) {
-        const ProxyObjectPtr &obj = where->second.mProxyObject;
-        if (obj) {
-            RoutableMessageHeader hdr (hdrOrig);
-            hdr.set_source_object(obj->getObjectReference().object());
-            mObjectHost->processMessage(hdr, body);
-        } else {
-            sendViaSpace(hdrOrig, body);
-        }
-    }
-}
-
-void HostedObject::tick() {
-    for (SpaceDataMap::iterator iter = mSpaceData->begin(); iter != mSpaceData->end(); ++iter) {
-        // send update to LOC (2) service in the space, if necessary
-        iter->second.updateLocation(this);
-        // Is it useful to call every script's tick() function?
-    }
-}
-
-void HostedObject::receivedPositionUpdate(
-    const ProxyObjectPtr &proxy,
-    const ObjLoc &objLoc,
-    bool force_reset)
-{
-    if (!proxy) {
-        return;
-    }
-    force_reset = force_reset || (objLoc.update_flags() & ObjLoc::FORCE);
-    if (!objLoc.has_timestamp()) {
-        objLoc.set_timestamp(Time::now(getSpaceTimeOffset(proxy->getObjectReference().space())));
-    }
-    Location currentLoc = proxy->globalLocation(objLoc.timestamp());
-    if (force_reset || objLoc.has_position()) {
-        currentLoc.setPosition(objLoc.position());
-    }
-    if (force_reset || objLoc.has_orientation()) {
-        currentLoc.setOrientation(objLoc.orientation());
-    }
-    if (force_reset || objLoc.has_velocity()) {
-        currentLoc.setVelocity(objLoc.velocity());
-    }
-    if (force_reset || objLoc.has_rotational_axis()) {
-        currentLoc.setAxisOfRotation(objLoc.rotational_axis());
-    }
-    if (force_reset || objLoc.has_angular_speed()) {
-        currentLoc.setAngularSpeed(objLoc.angular_speed());
-    }
-    if (force_reset) {
-        proxy->resetLocation(objLoc.timestamp(), currentLoc);
-    } else {
-        std::ostringstream os;
-        os << "Received position update to "<<currentLoc;
-        SILOG(cppoh,debug,os.str());
-        proxy->setLocation(objLoc.timestamp(), currentLoc);
-    }
-}
-
-
-static int32 query_id = 0;
-using Protocol::LocRequest;
-void HostedObject::processRPC(const RoutableMessageHeader &msg, const std::string &name, MemoryReference args, String *response) {
-    std::ostringstream printstr;
-    printstr<<"\t";
-    ProxyObjectPtr thisObj = getProxy(msg.source_space());
-
-    if (name == "LocRequest") {
-        LocRequest query;
-        printstr<<"LocRequest: ";
-        query.ParseFromArray(args.data(), args.length());
-        ObjLoc loc;
-        Time now = Time::now(getSpaceTimeOffset(msg.source_space()));
-        if (thisObj) {
-            Location globalLoc = thisObj->globalLocation(now);
-            loc.set_timestamp(now);
-            uint32 fields = 0;
-            bool all_fields = true;
-            if (query.has_requested_fields()) {
-                fields = query.requested_fields();
-                all_fields = false;
-            }
-            if (all_fields || (fields & LocRequest::POSITION))
-                loc.set_position(globalLoc.getPosition());
-            if (all_fields || (fields & LocRequest::ORIENTATION))
-                loc.set_orientation(globalLoc.getOrientation());
-            if (all_fields || (fields & LocRequest::VELOCITY))
-                loc.set_velocity(globalLoc.getVelocity());
-            if (all_fields || (fields & LocRequest::ROTATIONAL_AXIS))
-                loc.set_rotational_axis(globalLoc.getAxisOfRotation());
-            if (all_fields || (fields & LocRequest::ANGULAR_SPEED))
-                loc.set_angular_speed(globalLoc.getAngularSpeed());
-            if (response)
-                loc.SerializeToString(response);
-        } else {
-            SILOG(objecthost, error, "LocRequest message not for any known object.");
-        }
-        // loc requests need to be fast, unlikely to land in infinite recursion.
-        mObjectHost->getWorkQueue()->dequeueAll();
-        return;             /// comment out if we want scripts to see these requests
-    }
-    else if (name == "SetLoc") {
-        ObjLoc setloc;
-        printstr<<"Someone wants to set my position: ";
-        setloc.ParseFromArray(args.data(), args.length());
-        if (thisObj) {
-            printstr<<setloc.position();
-            receivedPositionUpdate(thisObj, setloc, false);
-        }
-    }
-    else if (name == "DelObj") {
-        SpaceDataMap::iterator perSpaceIter = mSpaceData->find(msg.source_space());
-        if (perSpaceIter == mSpaceData->end()) {
-            SILOG(objecthost, error, "DelObj message not for any known space.");
-            return;
-        }
-        TopLevelSpaceConnection *proxyMgr =
-            perSpaceIter->second.mSpaceConnection.getTopLevelStream().get();
-        if (thisObj && proxyMgr) {
-            proxyMgr->unregisterHostedObject(thisObj->getObjectReference().object());
-        }
-    }
-    else if (name == "RetObj") {
-        SpaceDataMap::iterator perSpaceIter = mSpaceData->find(msg.source_space());
-        if (msg.source_object() != ObjectReference::spaceServiceID()) {
-            SILOG(objecthost, error, "RetObj message not coming from space: "<<msg.source_object());
-            return;
-        }
-        if (perSpaceIter == mSpaceData->end()) {
-            SILOG(objecthost, error, "RetObj message not for any known space.");
-            return;
-        }
-        // getProxyManager() does not work because we have not yet created our ProxyObject.
-        TopLevelSpaceConnection *proxyMgr =
-            perSpaceIter->second.mSpaceConnection.getTopLevelStream().get();
-
-        Protocol::RetObj retObj;
-        retObj.ParseFromArray(args.data(), args.length());
-        if (retObj.has_object_reference() && retObj.has_location()) {
-            SpaceObjectReference objectId(msg.source_space(), ObjectReference(retObj.object_reference()));
-            ProxyObjectPtr proxyObj;
-            if (hasProperty("IsCamera")) {
-                printstr<<"RetObj: I am now a Camera known as "<<objectId.object();
-                proxyObj = ProxyObjectPtr(new ProxyCameraObject(proxyMgr, objectId));
-            } else if (hasProperty("LightInfo") && !hasProperty("MeshURI")) {
-                printstr<<"RetObj. I am now a Light known as "<<objectId.object();
-                proxyObj = ProxyObjectPtr(new ProxyLightObject(proxyMgr, objectId));
-            } else {
-                printstr<<"RetObj: I am now a Mesh known as "<<objectId.object();
-                proxyObj = ProxyObjectPtr(new ProxyMeshObject(proxyMgr, objectId));
-            }
-            proxyObj->setLocal(true);
-            perSpaceIter->second.mProxyObject = proxyObj;
-            proxyMgr->registerHostedObject(objectId.object(), getSharedPtr());
-            receivedPositionUpdate(proxyObj, retObj.location(), true);
-            perSpaceIter->second.locationWasReset(retObj.location().timestamp(), proxyObj->getLastLocation());
-            if (proxyMgr) {
-                //proxyMgr->createObject(proxyObj);
-                proxyMgr->createViewedObject(proxyObj, getTracker());
-                ProxyCameraObject* cam = dynamic_cast<ProxyCameraObject*>(proxyObj.get());
-                if (cam) {
-                    /* HACK: Because we have no method of scripting yet, we force
-                       any local camera we create to attach for convenience. */
-                    cam->attach(String(), 0, 0);
-                    uint32 my_query_id = query_id;
-                    query_id++;
-                    Protocol::NewProxQuery proxQuery;
-                    proxQuery.set_query_id(my_query_id);
-                    proxQuery.set_max_radius(1.0e+30f);
-                    String proxQueryStr;
-                    proxQuery.SerializeToString(&proxQueryStr);
-                    RoutableMessageBody body;
-                    body.add_message("NewProxQuery", proxQueryStr);
-                    String bodyStr;
-                    body.SerializeToString(&bodyStr);
-                    RoutableMessageHeader proxHeader;
-                    proxHeader.set_destination_port(Services::GEOM);
-                    proxHeader.set_destination_object(ObjectReference::spaceServiceID());
-                    proxHeader.set_destination_space(objectId.space());
-                    send(proxHeader, MemoryReference(bodyStr));
-                }
-                for (PropertyMap::const_iterator iter = mProperties.begin();
-                        iter != mProperties.end();
-                        ++iter) {
-                    receivedPropertyUpdate(proxyObj, iter->first, iter->second);
-                }
-            }
-        }
-    }
-    else if (name == "ProxCall") {
-        ObjectHostProxyManager *proxyMgr;
-        if (false && msg.source_object() != ObjectReference::spaceServiceID()) {
-            SILOG(objecthost, error, "ProxCall message not coming from space: "<<msg.source_object());
-            return;
-        }
-        if (!thisObj) {
-            SILOG(objecthost, error, "ProxCall message with null ProxyManager.");
-            return;
-        }
-
-        SpaceDataMap::iterator sditer = mSpaceData->find(msg.source_space());
-        assert (sditer != mSpaceData->end());
-        proxyMgr = sditer->second.mSpaceConnection.getTopLevelStream().get();
-
-        Protocol::ProxCall proxCall;
-        proxCall.ParseFromArray(args.data(), args.length());
-        SpaceObjectReference proximateObjectId (msg.source_space(), ObjectReference(proxCall.proximate_object()));
-        ProxyObjectPtr proxyObj (proxyMgr->getProxyObject(proximateObjectId));
-        switch (proxCall.proximity_event()) {
-          case Protocol::ProxCall::EXITED_PROXIMITY:
-            printstr<<"ProxCall EXITED "<<proximateObjectId.object();
-            if (proxyObj) {
-                PerSpaceData::ProxQueryMap::iterator iter = sditer->second.mProxQueryMap.find(proxCall.query_id());
-                if (iter != sditer->second.mProxQueryMap.end()) {
-                    std::set<ObjectReference>::iterator proxyiter = iter->second.find(proximateObjectId.object());
-                    assert (proxyiter != iter->second.end());
-                    if (proxyiter != iter->second.end()) {
-                        iter->second.erase(proxyiter);
-                    }
-                }
-                proxyMgr->destroyViewedObject(proxyObj->getObjectReference(), this->getTracker());
-            } else {
-                printstr<<" (unknown obj)";
-            }
-            break;
-          case Protocol::ProxCall::ENTERED_PROXIMITY:
-            printstr<<"ProxCall ENTERED "<<proximateObjectId.object();
-            {
-                PerSpaceData::ProxQueryMap::iterator iter =
-                    sditer->second.mProxQueryMap.insert(
-                        PerSpaceData::ProxQueryMap::value_type(proxCall.query_id(), std::set<ObjectReference>())
-                        ).first;
-                iter->second.insert(proximateObjectId.object());
-            }
-            if (!proxyObj) { // FIXME: We may get one of these for each prox query. Keep track of in-progress queries in ProxyManager.
-                printstr<<" (Requesting information...)";
-
-                {
-                    RPCMessage *locRequest = new RPCMessage(&mTracker,std::tr1::bind(&PrivateCallbacks::receivedProxObjectLocation,
-                                                                                     getWeakPtr(), _1, _2, _3,
-                                                        proxCall.query_id()));
-                    locRequest->header().set_destination_space(proximateObjectId.space());
-                    locRequest->header().set_destination_object(proximateObjectId.object());
-                    LocRequest loc;
-                    loc.SerializeToString(locRequest->body().add_message("LocRequest"));
-
-                  
-                    locRequest->setTimeout(Duration::seconds(5.0));
-                    locRequest->serializeSend();
-                }
-            } else {
-                printstr<<" (Already known)";
-                proxyMgr->createViewedObject(proxyObj, this->getTracker());
-            }
-            break;
-          case Protocol::ProxCall::STATELESS_PROXIMITY:
-            printstr<<"ProxCall Stateless'ed "<<proximateObjectId.object();
-            // Do not create a proxy object in this case: This message is for one-time queries
-            break;
-        }
-    } else {
-        printstr<<"Message to be handled in script: "<<name;
-    }
-    SILOG(cppoh,debug,printstr.str());
-    if (mObjectScript) {
-        MemoryBuffer returnCopy;
-        mObjectScript->processRPC(msg, name, args, returnCopy);
-        if (response) {
-            response->reserve(returnCopy.size());
-            std::copy(returnCopy.begin(), returnCopy.end(),
-                      std::insert_iterator<std::string>(*response, response->begin()));
-        }
-    }
-}
-const Duration&HostedObject::getSpaceTimeOffset(const SpaceID&space) {
-    static Duration nil(Duration::seconds(0));
-    SpaceDataMap::iterator where=mSpaceData->find(space);
-    if (where!=mSpaceData->end()) 
-        return where->second.mSpaceConnection.getTopLevelStream()->getServerTimeOffset();
-    return nil;
-}
-
-void HostedObject::receivedPropertyUpdate(
-        const ProxyObjectPtr &proxy,
-        const std::string &propertyName,
-        const std::string &arguments)
-{
-    if (propertyName == "MeshURI") {
-        Protocol::StringProperty parsedProperty;
-        parsedProperty.ParseFromString(arguments);
-        if (parsedProperty.has_value()) {
-            ProxyMeshObject *proxymesh = dynamic_cast<ProxyMeshObject*>(proxy.get());
-            if (proxymesh) {
-                SILOG(cppoh,info, "* Received MESH property update for " << proxy->getObjectReference().object() <<" has mesh URI "<<URI(parsedProperty.value()));
-                proxymesh->setMesh(URI(parsedProperty.value()));
-            }
-        }
-    }
-    if (propertyName == "MeshScale") {
-        Protocol::Vector3fProperty parsedProperty;
-        parsedProperty.ParseFromString(arguments);
-        if (parsedProperty.has_value()) {
-            ProxyMeshObject *proxymesh = dynamic_cast<ProxyMeshObject*>(proxy.get());
-            if (proxymesh) {
-                proxymesh->setScale(parsedProperty.value());
-            }
-        }
-    }
-    if (propertyName == "LightInfo") {
-        Protocol::LightInfoProperty parsedLight;
-        parsedLight.ParseFromString(arguments);
-        ProxyLightObject *proxylight = dynamic_cast<ProxyLightObject*>(proxy.get());
-        if (proxylight) {
-            proxylight->update(LightInfo(parsedLight));
-        }
-    }
-    if (propertyName == "PhysicalParameters") {
-        Protocol::PhysicalParameters parsedProperty;
-        parsedProperty.ParseFromString(arguments);
-        ProxyMeshObject *proxymesh = dynamic_cast<ProxyMeshObject*>(proxy.get());
-        if (proxymesh) {
-            // FIXME: allow missing fields, and do not hardcode enum values.
-            PhysicalParameters params;
-            switch (parsedProperty.mode()) {
-            case Protocol::PhysicalParameters::NONPHYSICAL:
-                params.mode = PhysicalParameters::Disabled;
-                break;
-            case Protocol::PhysicalParameters::STATIC:
-                params.mode = PhysicalParameters::Static;
-                break;
-            case Protocol::PhysicalParameters::DYNAMICBOX:
-                params.mode = PhysicalParameters::DynamicBox;
-                break;
-            case Protocol::PhysicalParameters::DYNAMICSPHERE:
-                params.mode = PhysicalParameters::DynamicSphere;
-                break;
-            case Protocol::PhysicalParameters::DYNAMICCYLINDER:
-                params.mode = PhysicalParameters::DynamicCylinder;
-                break;
-            case Protocol::PhysicalParameters::CHARACTER:
-                params.mode = PhysicalParameters::Character;
-                break;
-            default:
-                params.mode = PhysicalParameters::Disabled;
-            }
-            params.density = parsedProperty.density();
-            params.friction = parsedProperty.friction();
-            params.bounce = parsedProperty.bounce();
-            params.colMsg = parsedProperty.collide_msg();
-            params.colMask = parsedProperty.collide_mask();
-            params.hull = parsedProperty.hull();
-            params.gravity = parsedProperty.gravity();
-            params.name = proxymesh->getPhysical().name;        /// otherwise setPhysical will wipe it
-            proxymesh->setPhysical(params);
-        }
-    }
-    if (propertyName == "Parent") {
-        Protocol::ParentProperty parsedProperty;
-        parsedProperty.ParseFromString(arguments);
-        if (parsedProperty.has_value()) {
-            ProxyObjectPtr obj =proxy->getProxyManager()->getProxyObject(
-                SpaceObjectReference(
-                    proxy->getObjectReference().space(),
-                    ObjectReference(parsedProperty.value())));
-            if (obj && obj != proxy) {
-                proxy->setParent(obj, Time::now(getSpaceTimeOffset(proxy->getObjectReference().space())));
-            }
-        }
-    }
-    if (propertyName == "Name") {
-        Protocol::StringProperty parsedProperty;
-        ProxyMeshObject *proxymesh = dynamic_cast<ProxyMeshObject*>(proxy.get());
-        parsedProperty.ParseFromString(arguments);
-        if (proxymesh && parsedProperty.has_value()) {
-            PhysicalParameters params = proxymesh->getPhysical();
-            params.name = parsedProperty.value();
-            proxymesh->setPhysical(params);
-        }
-    }
-}
-
-}
+/*  Sirikata liboh -- Object Host
+ *  HostedObject.cpp
+ *
+ *  Copyright (c) 2009, Patrick Reiter Horn
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are
+ *  met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name of Sirikata nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <util/Platform.hpp>
+#include <oh/Platform.hpp>
+#include <ObjectHost_Sirikata.pbj.hpp>
+#include <ObjectHost_Persistence.pbj.hpp>
+#include <task/WorkQueue.hpp>
+#include "util/RoutableMessage.hpp"
+#include "util/KnownServices.hpp"
+#include "persistence/PersistenceSentMessage.hpp"
+#include "network/Stream.hpp"
+#include "util/SpaceObjectReference.hpp"
+#include "oh/SpaceConnection.hpp"
+#include "oh/TopLevelSpaceConnection.hpp"
+#include "oh/HostedObject.hpp"
+#include "util/SentMessage.hpp"
+#include "oh/ObjectHost.hpp"
+#include "oh/ProxyMeshObject.hpp"
+#include "oh/ProxyLightObject.hpp"
+#include "oh/ProxyCameraObject.hpp"
+#include "oh/LightInfo.hpp"
+#include "oh/ObjectScriptManager.hpp"
+#include "oh/ObjectScript.hpp"
+#include "oh/ObjectScriptManagerFactory.hpp"
+#include <util/KnownServices.hpp>
+
+namespace Sirikata {
+
+typedef SentMessageBody<RoutableMessageBody> RPCMessage;
+
+class HostedObject::PerSpaceData {
+public:
+    SpaceConnection mSpaceConnection;
+    ProxyObjectPtr mProxyObject;
+    ProxyObject::Extrapolator mUpdatedLocation;
+
+    void locationWasReset(Time timestamp, Location loc) {
+        loc.setVelocity(Vector3f::nil());
+        loc.setAngularSpeed(0);
+        mUpdatedLocation.resetValue(timestamp, loc);
+    }
+    void locationWasSet(const Protocol::ObjLoc &msg) {
+        Time timestamp = msg.timestamp();
+        Location loc = mUpdatedLocation.extrapolate(timestamp);
+        ProxyObject::updateLocationWithObjLoc(loc, msg);
+        loc.setVelocity(Vector3f::nil());
+        loc.setAngularSpeed(0);
+        mUpdatedLocation.updateValue(timestamp, loc);
+    }
+
+    void updateLocation(HostedObject *ho) {
+        if (!mProxyObject) {
+            return;
+        }
+        SpaceID space = mProxyObject->getObjectReference().space();
+        Time now = Time::now(ho->getSpaceTimeOffset(space));
+        Location realLocation = mProxyObject->globalLocation(now);
+        if (mUpdatedLocation.needsUpdate(now, realLocation)) {
+            Protocol::ObjLoc toSet;
+            toSet.set_position(realLocation.getPosition());
+            toSet.set_velocity(realLocation.getVelocity());
+            RoutableMessageBody body;
+            toSet.SerializeToString(body.add_message("ObjLoc"));
+            RoutableMessageHeader header;
+            header.set_destination_port(Services::LOC);
+            header.set_destination_object(ObjectReference::spaceServiceID());
+            header.set_destination_space(space);
+            std::string bodyStr;
+            body.SerializeToString(&bodyStr);
+            // Avoids waiting a loop.
+            ho->sendViaSpace(header, MemoryReference(bodyStr));
+
+            locationWasSet(toSet);
+        }
+    }
+
+    typedef std::map<uint32, std::set<ObjectReference> > ProxQueryMap;
+    ProxQueryMap mProxQueryMap; ///< indexed by ProxCall::query_id()
+
+    PerSpaceData(const std::tr1::shared_ptr<TopLevelSpaceConnection>&topLevel,Network::Stream*stream)
+        :mSpaceConnection(topLevel,stream),
+        mUpdatedLocation(
+            Duration::seconds(.1),
+            TemporalValue<Location>::Time::null(),
+            Location(Vector3d(0,0,0),Quaternion(Quaternion::identity()),
+                     Vector3f(0,0,0),Vector3f(0,1,0),0),
+            ProxyObject::UpdateNeeded()) {
+    }
+};
+
+
+ 
+HostedObject::HostedObject(ObjectHost*parent, const UUID &objectName)
+    : mTracker(parent->getSpaceIO()),
+      mInternalObjectReference(objectName) {
+    mSpaceData = new SpaceDataMap;
+    mObjectHost=parent;
+    mObjectScript=NULL;
+    mSendService.ho = this;
+    mReceiveService.ho = this;
+    mTracker.forwardMessagesTo(&mSendService);
+}
+
+HostedObject::~HostedObject() {
+    if (mObjectScript) {
+        delete mObjectScript;
+    }
+    for (SpaceDataMap::const_iterator iter = mSpaceData->begin();
+         iter != mSpaceData->end();
+         ++iter) {
+        for (PerSpaceData::ProxQueryMap::const_iterator qiter = iter->second.mProxQueryMap.begin();
+             qiter != iter->second.mProxQueryMap.end();
+             ++qiter) {
+            for (std::set<ObjectReference>::const_iterator oriter = qiter->second.begin();
+                 oriter != qiter->second.end();
+                 ++oriter)
+            {
+                iter->second.mSpaceConnection.getTopLevelStream()->
+                    destroyViewedObject(SpaceObjectReference(iter->first, *oriter), getTracker());
+            }
+        }
+    }
+    mObjectHost->unregisterHostedObject(mInternalObjectReference);
+    mTracker.endForwardingMessagesTo(&mSendService);
+    delete mSpaceData;
+}
+
+struct HostedObject::PrivateCallbacks {
+
+    static void initializeDatabaseCallback(
+        HostedObject *realThis,
+        const SpaceID &spaceID,
+        Persistence::SentReadWriteSet *msg,
+        const RoutableMessageHeader &lastHeader,
+        Persistence::Protocol::Response::ReturnStatus errorCode)
+    {
+        if (lastHeader.has_return_status() || errorCode) {
+            SILOG(cppoh,error,"Database error recieving Loc and scripting info: "<<(int)lastHeader.return_status()<<": "<<(int)errorCode);
+            delete msg;
+            return; // unable to get starting position.
+        }
+        String scriptName;
+        std::map<String,String> scriptParams;
+        Location location(Vector3d::nil(),Quaternion::identity(),Vector3f::nil(),Vector3f(1,0,0),0);
+        for (int i = 0; i < msg->body().reads_size(); i++) {
+            String name = msg->body().reads(i).field_name();
+            if (msg->body().reads(i).has_return_status() || !msg->body().reads(i).has_data()) {
+                continue;
+            }
+            if (!name.empty() && name[0] != '_') {
+                realThis->setProperty(name, msg->body().reads(i).data());
+            }
+            if (name == "Loc") {
+                ObjLoc loc;
+                loc.ParseFromString(msg->body().reads(i).data());
+                SILOG(cppoh,debug,"Creating object "<<ObjectReference(realThis->getUUID())
+                      <<" at position "<<loc.position());
+                if (loc.has_position()) {
+                    location.setPosition(loc.position());
+                }
+                if (loc.has_orientation()) {
+                    location.setOrientation(loc.orientation());
+                }
+                if (loc.has_velocity()) {
+                    location.setVelocity(loc.velocity());
+                }
+                if (loc.has_rotational_axis()) {
+                    location.setAxisOfRotation(loc.rotational_axis());
+                }
+                if (loc.has_angular_speed()) {
+                    location.setAngularSpeed(loc.angular_speed());
+                }
+            }
+            if (name == "_Script") {
+                Protocol::StringProperty scrProp;
+                scrProp.ParseFromString(msg->body().reads(i).data());
+                scriptName = scrProp.value();
+            }
+            if (name == "_ScriptParams") {
+                Protocol::StringMapProperty scrProp;
+                scrProp.ParseFromString(msg->body().reads(i).data());
+                int numkeys = scrProp.keys_size();
+                {
+                    int numvalues = scrProp.values_size();
+                    if (numvalues < numkeys) {
+                        numkeys = numvalues;
+                    }
+                }
+                for (int i = 0; i < numkeys; i++) {
+                    scriptParams[scrProp.keys(i)] = scrProp.values(i);
+                }
+            }
+        }
+        // Temporary Hack because we do not have access to the CDN here.
+        BoundingSphere3f sphere(Vector3f::nil(),1);
+        realThis->sendNewObj(location, sphere, spaceID);
+        delete msg;
+        if (!scriptName.empty()) {
+            realThis->initializeScript(scriptName, scriptParams);
+        }
+        realThis->mObjectHost->getWorkQueue()->dequeueAll();
+    }
+
+    static void receivedRoutableMessage(const HostedObjectWPtr&thus,const SpaceID&sid, const Network::Chunk&msgChunk) {
+        HostedObjectPtr realThis (thus.lock());
+
+        RoutableMessageHeader header;
+        MemoryReference bodyData = header.ParseFromArray(&(msgChunk[0]),msgChunk.size());
+        header.set_source_space(sid);
+        header.set_destination_space(sid);
+        {
+            ProxyObjectPtr destinationObject = realThis->getProxy(header.source_space());
+            if (destinationObject) {
+                header.set_destination_object(destinationObject->getObjectReference().object());
+            }
+            if (!header.has_source_object()) {
+                header.set_source_object(ObjectReference::spaceServiceID());
+            }
+        }
+
+        if (!realThis) {
+            SILOG(objecthost,error,"Received message for dead HostedObject. SpaceID = "<<sid<<"; DestObject = "<<header.destination_object());
+            return;
+        }
+
+        realThis->processRoutableMessage(header, bodyData);
+    }
+
+    static void handlePersistenceResponse(
+        HostedObject *realThis,
+        const RoutableMessageHeader &origHeader,
+        SentMessage *sent,
+        const RoutableMessageHeader &header,
+        MemoryReference bodyData)
+    {
+        std::auto_ptr<SentMessageBody<Persistence::Protocol::ReadWriteSet> > sentDestruct(static_cast<SentMessageBody<Persistence::Protocol::ReadWriteSet> *>(sent));
+        SILOG(cppoh,debug,"Got some persistence back: stat = "<<(int)header.return_status());
+        if (header.has_return_status()) {
+            Persistence::Protocol::Response resp;
+            for (int i = 0, respIndex=0; i < sentDestruct->body().reads_size(); i++, respIndex++) {
+                Persistence::Protocol::IStorageElement field = resp.add_reads();
+                if (sentDestruct->body().reads(i).has_index()) {
+                    field.set_index(sentDestruct->body().reads(i).index());
+                }
+                if (sentDestruct->body().options() & Persistence::Protocol::ReadWriteSet::RETURN_READ_NAMES) {
+                    field.set_field_name(sentDestruct->body().reads(i).field_name());
+                }
+                field.set_return_status(Persistence::Protocol::StorageElement::KEY_MISSING);
+            }
+            std::string errorData;
+            resp.SerializeToString(&errorData);
+            realThis->sendReply(origHeader, MemoryReference(errorData));
+        } else {
+            realThis->sendReply(origHeader, bodyData);
+        }
+        realThis->mObjectHost->getWorkQueue()->dequeueAll();
+    }
+    static void handlePersistenceMessage(HostedObject *realThis, const RoutableMessageHeader &header, MemoryReference bodyData) {
+        using namespace Persistence::Protocol;
+
+        ReadWriteSet rws;
+        rws.ParseFromArray(bodyData.data(), bodyData.length());
+
+        Response immedResponse;
+        int immedIndex = 0;
+
+        SentMessageBody<ReadWriteSet> *persistenceMsg = new SentMessageBody<ReadWriteSet>(&realThis->mTracker,std::tr1::bind(&handlePersistenceResponse, realThis, header, _1, _2, _3));
+        int outIndex = 0;
+        ReadWriteSet &outMessage = persistenceMsg->body();
+        if (rws.has_options()) {
+            outMessage.set_options(rws.options());
+        }
+        SILOG(cppoh,debug,"Got a Persistence message: reads size = "<<rws.reads_size()<<
+              " writes size = "<<rws.writes_size());
+
+        for (int i = 0, rwsIndex=0 ; i < rws.reads_size(); i++, rwsIndex++) {
+            if (rws.reads(i).has_index()) {
+                rwsIndex = rws.reads(i).index();
+            }
+            std::string name;
+            if (rws.reads(i).has_field_name()) {
+                name = rws.reads(i).field_name();
+            }
+            bool fail = false;
+            if (name.empty() || name[0] == '_') {
+                SILOG(cppoh,debug,"Invalid GetProp: "<<name);
+                fail = true;
+            } else {
+                if (realThis->hasProperty(name)) {
+                    // Cached property--respond immediately.
+                    SILOG(cppoh,debug,"Cached GetProp: "<<name<<" = "<<realThis->getProperty(name));
+                    IStorageElement el = immedResponse.add_reads();
+                    if (immedIndex != rwsIndex) {
+                        el.set_index(rwsIndex);
+                    }
+                    immedIndex = rwsIndex+1;
+                    if (rws.options() & ReadWriteSet::RETURN_READ_NAMES) {
+                        el.set_field_name(rws.reads(i).field_name());
+                    }
+                    el.set_data(realThis->getProperty(name));
+                } else {
+                    SILOG(cppoh,debug,"Forward GetProp: "<<name<<" to Persistence");
+                    IStorageElement el = outMessage.add_reads();
+                    if (outIndex != rwsIndex) {
+                        el.set_index(rwsIndex);
+                    }
+                    outIndex = rwsIndex+1;
+                    el.set_field_name(rws.reads(i).field_name());
+                    el.set_object_uuid(realThis->getUUID());
+                }
+            }
+            if (fail) {
+                IStorageElement el = immedResponse.add_reads();
+                if (immedIndex != rwsIndex) {
+                    el.set_index(rwsIndex);
+                }
+                immedIndex = rwsIndex+1;
+                if (rws.options() & ReadWriteSet::RETURN_READ_NAMES) {
+                    el.set_field_name(rws.reads(i).field_name());
+                }
+                el.set_return_status(StorageElement::KEY_MISSING);
+            }
+        }
+        outIndex = 0;
+        for (int i = 0, rwsIndex=0 ; i < rws.writes_size(); i++, rwsIndex++) {
+            if (rws.writes(i).has_index()) {
+                rwsIndex = rws.writes(i).index();
+            }
+            std::string name;
+            if (rws.writes(i).has_field_name()) {
+                name = rws.writes(i).field_name();
+            }
+            bool fail = false;
+            if (name.empty() || name[0] == '_') {
+                SILOG(cppoh,debug,"Invalid SetProp: "<<name);
+                fail = true;
+            } else {
+                if (rws.writes(i).has_data()) {
+                    realThis->setProperty(name, rws.writes(i).data());
+                    SpaceDataMap::iterator iter;
+                    for (iter = realThis->mSpaceData->begin();
+                         iter != realThis->mSpaceData->end();
+                         ++iter) {
+                        realThis->receivedPropertyUpdate(iter->second.mProxyObject, name, rws.writes(i).data());
+                    }
+                } else {
+                    if (name != "LightInfo" && name != "MeshURI" && name != "IsCamera") {
+                        // changing the type of this object has to wait until we reload from database.
+                        realThis->unsetProperty(name);
+                    }
+                }
+                SILOG(cppoh,debug,"Forward SetProp: "<<name<<" to Persistence");
+                IStorageElement el = outMessage.add_writes();
+                if (outIndex != rwsIndex) {
+                    el.set_index(rwsIndex);
+                }
+                outIndex = rwsIndex+1;
+                el.set_field_name(rws.writes(i).field_name());
+                if (rws.writes(i).has_data()) {
+                    el.set_data(rws.writes(i).data());
+                }
+                el.set_object_uuid(realThis->getUUID());
+            }
+            // what to do if a write fails?
+        }
+
+        if (immedResponse.reads_size()) {
+            SILOG(cppoh,debug,"ImmedResponse: "<<immedResponse.reads_size());
+            std::string respStr;
+            immedResponse.SerializeToString(&respStr);
+            RoutableMessageHeader respHeader (header);
+            realThis->sendReply(respHeader, MemoryReference(respStr));
+        }
+        if (outMessage.reads_size() || outMessage.writes_size()) {
+            SILOG(cppoh,debug,"ForwardToPersistence: "<<outMessage.reads_size()<<
+                  " reads and "<<outMessage.writes_size()<<"writes");
+            persistenceMsg->header().set_destination_space(SpaceID::null());
+            persistenceMsg->header().set_destination_object(ObjectReference::spaceServiceID());
+            persistenceMsg->header().set_destination_port(Services::PERSISTENCE);
+
+            persistenceMsg->serializeSend();
+        } else {
+            delete persistenceMsg;
+        }
+        realThis->mObjectHost->getWorkQueue()->dequeueAll();
+    }
+    static void handleRPCMessage(HostedObject *realThis, const RoutableMessageHeader &header, MemoryReference bodyData) {
+        /// Parse message_names and message_arguments.
+
+        RoutableMessageBody msg;
+        msg.ParseFromArray(bodyData.data(), bodyData.length());
+        int numNames = msg.message_size();
+        if (numNames <= 0) {
+            // Invalid message!
+            realThis->sendErrorReply(header, RoutableMessageHeader::PROTOCOL_ERROR);
+            return;
+        }
+
+        RoutableMessageBody responseMessage;
+        for (int i = 0; i < numNames; ++i) {
+            std::string name = msg.message_names(i);
+            MemoryReference body(msg.message_arguments(i));
+
+            if (header.has_id()) {
+                std::string response;
+                /// Pass response parameter if we expect a response.
+                realThis->processRPC(header, name, body, &response);
+                responseMessage.add_message_reply(response);
+            } else {
+                /// Return value not needed.
+                realThis->processRPC(header, name, body, NULL);
+            }
+        }
+
+        if (header.has_id()) {
+            std::string serializedResponse;
+            responseMessage.SerializeToString(&serializedResponse);
+            realThis->sendReply(header, MemoryReference(serializedResponse));
+        }
+    }
+
+    static void receivedProxObjectLocation(
+        const HostedObjectWPtr &weakThis,
+        SentMessage* sentMessage,
+        const RoutableMessageHeader &hdr,
+        MemoryReference bodyData,
+        int32 queryId)
+    {
+        std::auto_ptr<RPCMessage> destructor(static_cast<RPCMessage*>(sentMessage));
+        HostedObjectPtr realThis(weakThis.lock());
+        if (!realThis) {
+            return;
+        }
+
+        RoutableMessage responseMessage(hdr, bodyData.data(), bodyData.length());
+        if (responseMessage.header().return_status() != RoutableMessageHeader::SUCCESS) {
+            SILOG(cppoh,info,"FAILURE receiving prox object properties "<<sentMessage->getRecipient());
+            return;
+        }
+        ObjLoc objLoc;
+        objLoc.ParseFromString(responseMessage.body().message_arguments(0));
+
+        Persistence::SentReadWriteSet *request = new Persistence::SentReadWriteSet(&realThis->mTracker);
+
+        request->header().set_destination_space(sentMessage->getSpace());
+        request->header().set_destination_object(sentMessage->getRecipient());
+        request->header().set_destination_port(Services::PERSISTENCE);
+
+        request->body().add_reads().set_field_name("MeshURI");
+        request->body().add_reads().set_field_name("MeshScale");
+        request->body().add_reads().set_field_name("Name");
+        request->body().add_reads().set_field_name("PhysicalParameters");
+        request->body().add_reads().set_field_name("LightInfo");
+        request->body().add_reads().set_field_name("_Passwd");
+        request->body().add_reads().set_field_name("IsCamera");
+        request->body().add_reads().set_field_name("Parent");
+        request->setPersistenceCallback(std::tr1::bind(&PrivateCallbacks::receivedProxObjectProperties,
+                                            weakThis, _1, _2, _3,
+                                            queryId, objLoc));
+        request->setTimeout(Duration::seconds(5.0));
+        request->serializeSend();
+    }
+    static void receivedProxObjectProperties(
+        const HostedObjectWPtr &weakThis,
+        SentMessage* sentMessageBase,
+        const RoutableMessageHeader &hdr,
+        Persistence::Protocol::Response::ReturnStatus returnStatus,
+        int32 queryId,
+        const ObjLoc &objLoc)
+    {
+        using namespace Persistence::Protocol;
+        std::auto_ptr<Persistence::SentReadWriteSet> sentMessage(Persistence::SentReadWriteSet::cast_sent_message(sentMessageBase));
+        HostedObjectPtr realThis(weakThis.lock());
+        if (!realThis) {
+            return;
+        }
+        SpaceDataMap::iterator iter = realThis->mSpaceData->find(sentMessage->getSpace());
+        if (iter == realThis->mSpaceData->end()) {
+            return;
+        }
+        ObjectHostProxyManager *proxyMgr = iter->second.mSpaceConnection.getTopLevelStream().get();
+        PerSpaceData::ProxQueryMap::iterator qmiter = iter->second.mProxQueryMap.find(queryId);
+        if (qmiter == iter->second.mProxQueryMap.end()) {
+            return;
+        }
+        std::set<ObjectReference>::iterator proxyiter = qmiter->second.find(sentMessage->getRecipient());
+        if (proxyiter == qmiter->second.end()) {
+            return;
+        }
+        SpaceObjectReference proximateObjectId(sentMessage->getSpace(), sentMessage->getRecipient());
+        bool persistence_error = false;
+        if (hdr.return_status() != RoutableMessageHeader::SUCCESS ||returnStatus) {
+            SILOG(cppoh,info,"FAILURE receiving prox object properties "<<
+                  proximateObjectId.object()<<": Error = "<<(int)hdr.return_status());
+            persistence_error = true;
+        }
+        SILOG(cppoh,debug,"Received prox object properties "<<proximateObjectId.object()<<": reads size = ?");
+        int index = 0;
+        bool haveAll = true;
+        for (int i = 0; i < sentMessage->body().reads_size(); i++) {
+            if (!sentMessage->body().reads(i).has_data() && !sentMessage->body().reads(i).has_return_status()) {
+                haveAll = false;
+            }
+        }
+        if (persistence_error || haveAll) {
+
+        } else {
+            assert(false&&"Received incomplete persistence callback for the same read/write set: should only ever get one");
+            return; // More messages would have come before the new design.
+        }
+        bool hasMesh=false;
+        bool hasLight=false;
+        bool isCamera=false;
+        ProxyObjectPtr proxyObj;
+        for (int i = 0; i < sentMessage->body().reads_size(); ++i) {
+            if (sentMessage->body().reads(i).has_return_status()) {
+                continue;
+            }
+            const std::string &field = sentMessage->body().reads(i).field_name();
+            if (field == "MeshURI") {
+                hasMesh = true;
+            }
+            if (field == "LightInfo") {
+                hasLight = true;
+            }
+            if (field == "IsCamera") {
+                isCamera = true;
+            }
+        }
+        ObjectReference myObjectReference;
+        if (isCamera) {
+            SILOG(cppoh,info, "* I found a camera named " << proximateObjectId.object());
+            proxyObj = ProxyObjectPtr(new ProxyCameraObject(proxyMgr, proximateObjectId));
+        } else if (hasLight && !hasMesh) {
+            SILOG(cppoh,info, "* I found a light named " << proximateObjectId.object());
+            proxyObj = ProxyObjectPtr(new ProxyLightObject(proxyMgr, proximateObjectId));
+        } else {
+            SILOG(cppoh,info, "* I found a MESH named " << proximateObjectId.object());
+            proxyObj = ProxyObjectPtr(new ProxyMeshObject(proxyMgr, proximateObjectId));
+        }
+        proxyObj->setLocal(false);
+        realThis->receivedPositionUpdate(proxyObj, objLoc, true);
+        proxyMgr->createViewedObject(proxyObj, realThis->getTracker());
+        for (int i = 0; i < sentMessage->body().reads_size(); ++i) {
+            if (sentMessage->body().reads(i).has_return_status()) {
+                continue;
+            }
+            const std::string &field = sentMessage->body().reads(i).field_name();
+            realThis->receivedPropertyUpdate(proxyObj, sentMessage->body().reads(i).field_name(), sentMessage->body().reads(i).data());
+        }
+        {
+            RPCMessage *request = new RPCMessage(&realThis->mTracker,std::tr1::bind(&receivedPositionUpdateResponse, weakThis, _1, _2, _3));
+            request->header().set_destination_space(proximateObjectId.space());
+            request->header().set_destination_object(proximateObjectId.object());
+            Protocol::LocRequest loc;
+            loc.SerializeToString(request->body().add_message("LocRequest"));
+            request->serializeSend();
+        }
+        return;
+    }
+
+    static void receivedPositionUpdateResponse(
+        const HostedObjectWPtr &weakThus,
+        SentMessage* sentMessage,
+        const RoutableMessageHeader &hdr,
+        MemoryReference bodyData)
+    {
+        RoutableMessage responseMessage(hdr, bodyData.data(), bodyData.length());
+        HostedObjectPtr thus(weakThus.lock());
+        if (!thus) {
+            delete static_cast<RPCMessage*>(sentMessage);
+        }
+        if (responseMessage.header().return_status()) {
+            return;
+        }
+        Protocol::ObjLoc loc;
+        loc.ParseFromString(responseMessage.body().message_arguments(0));
+
+        const SpaceID &space = sentMessage->getSpace();
+        ProxyManager *pm = thus->getObjectHost()->getProxyManager(space);
+        if (pm) {
+            ProxyObjectPtr obj(pm->getProxyObject(
+                SpaceObjectReference(space, sentMessage->getRecipient())));
+            if (obj) {
+                thus->receivedPositionUpdate(obj,loc,false);
+            }
+        }
+
+        static_cast<RPCMessage*>(sentMessage)->serializeSend(); // Resend position update each time we get one.
+    }
+
+    static void disconnectionEvent(const HostedObjectWPtr&weak_thus,const SpaceID&sid, const String&reason) {
+        std::tr1::shared_ptr<HostedObject>thus=weak_thus.lock();
+        if (thus) {
+            SpaceDataMap::iterator where=thus->mSpaceData->find(sid);
+            if (where!=thus->mSpaceData->end()) {
+                thus->mSpaceData->erase(where);//FIXME do we want to back this up to the database first?
+            }
+        }
+    }
+
+    static void connectionEvent(const HostedObjectWPtr&thus,
+                                const SpaceID&sid,
+                                Network::Stream::ConnectionStatus ce,
+                                const String&reason) {
+        if (ce!=Network::Stream::Connected) {
+            disconnectionEvent(thus,sid,reason);
+        }
+    }
+};
+
+HostedObject::PerSpaceData& HostedObject::cloneTopLevelStream(const SpaceID&sid,const std::tr1::shared_ptr<TopLevelSpaceConnection>&tls) {
+    using std::tr1::placeholders::_1;
+    using std::tr1::placeholders::_2;
+    SpaceDataMap::iterator iter = mSpaceData->insert(
+        SpaceDataMap::value_type(
+            sid,
+            PerSpaceData(tls,
+                         tls->topLevelStream()->clone(
+                             std::tr1::bind(&PrivateCallbacks::connectionEvent,
+                                            getWeakPtr(),
+                                            sid,
+                                            _1,
+                                            _2),
+                             std::tr1::bind(&PrivateCallbacks::receivedRoutableMessage,
+                                            getWeakPtr(),
+                                            sid,
+                                            _1))))).first;
+    return iter->second;
+}
+
+static String nullProperty;
+bool HostedObject::hasProperty(const String &propName) const {
+    PropertyMap::const_iterator iter = mProperties.find(propName);
+    return (iter != mProperties.end());
+}
+const String &HostedObject::getProperty(const String &propName) const {
+    PropertyMap::const_iterator iter = mProperties.find(propName);
+    if (iter != mProperties.end()) {
+        return (*iter).second;
+    }
+    return nullProperty;
+}
+String *HostedObject::propertyPtr(const String &propName) {
+    return &(mProperties[propName]);
+}
+void HostedObject::setProperty(const String &propName, const String &encodedValue) {
+    mProperties.insert(PropertyMap::value_type(propName, encodedValue));
+}
+void HostedObject::unsetProperty(const String &propName) {
+    PropertyMap::iterator iter = mProperties.find(propName);
+    if (iter != mProperties.end()) {
+        mProperties.erase(iter);
+    }
+}
+
+
+static ProxyObjectPtr nullPtr;
+const ProxyObjectPtr &HostedObject::getProxy(const SpaceID &space) const {
+    SpaceDataMap::const_iterator iter = mSpaceData->find(space);
+    if (iter == mSpaceData->end()) {
+        return nullPtr;
+    }
+    return iter->second.mProxyObject;
+}
+
+
+using Sirikata::Protocol::NewObj;
+using Sirikata::Protocol::IObjLoc;
+
+void HostedObject::sendNewObj(
+    const Location&startingLocation,
+    const BoundingSphere3f &meshBounds,
+    const SpaceID&spaceID)
+{
+
+    RoutableMessageHeader messageHeader;
+    messageHeader.set_destination_object(ObjectReference::spaceServiceID());
+    messageHeader.set_destination_space(spaceID);
+    messageHeader.set_destination_port(Services::REGISTRATION);
+    NewObj newObj;
+    newObj.set_object_uuid_evidence(getUUID());
+    newObj.set_bounding_sphere(meshBounds);
+    IObjLoc loc = newObj.mutable_requested_object_loc();
+    loc.set_timestamp(Time::now(getSpaceTimeOffset(spaceID)));
+    loc.set_position(startingLocation.getPosition());
+    loc.set_orientation(startingLocation.getOrientation());
+    loc.set_velocity(startingLocation.getVelocity());
+    loc.set_rotational_axis(startingLocation.getAxisOfRotation());
+    loc.set_angular_speed(startingLocation.getAngularSpeed());
+
+    RoutableMessageBody messageBody;
+    newObj.SerializeToString(messageBody.add_message("NewObj"));
+
+    std::string serializedBody;
+    messageBody.SerializeToString(&serializedBody);
+    sendViaSpace(messageHeader, MemoryReference(serializedBody));
+}
+
+void HostedObject::initializeConnect(
+    const Location&startingLocation,
+    const String&mesh, const BoundingSphere3f&meshBounds,
+    const LightInfo *lightInfo,
+    const SpaceID&spaceID, const HostedObjectPtr&spaceConnectionHint)
+{
+    mObjectHost->registerHostedObject(getSharedPtr());
+    connectToSpace(spaceID, spaceConnectionHint);
+    sendNewObj(startingLocation, meshBounds, spaceID);
+    mObjectHost->getWorkQueue()->dequeueAll(); // don't need to wait until next frame.
+
+    if (!mesh.empty()) {
+        Protocol::StringProperty meshprop;
+        meshprop.set_value(mesh);
+        meshprop.SerializeToString(propertyPtr("MeshURI"));
+        Protocol::Vector3fProperty scaleprop;
+        scaleprop.set_value(Vector3f(1,1,1)); // default value, set it manually if you want different.
+        scaleprop.SerializeToString(propertyPtr("MeshScale"));
+        Protocol::PhysicalParameters physicalprop;
+        physicalprop.set_mode(Protocol::PhysicalParameters::NONPHYSICAL);
+        physicalprop.SerializeToString(propertyPtr("PhysicalParameters"));
+    } else if (lightInfo) {
+        Protocol::LightInfoProperty lightProp;
+        lightInfo->toProtocol(lightProp);
+        lightProp.SerializeToString(propertyPtr("LightInfo"));
+    } else {
+        setProperty("IsCamera");
+    }
+}
+void HostedObject::initializePythonScript() {
+    ObjectScriptManager *mgr = ObjectScriptManagerFactory::getSingleton().getDefaultConstructor()("");
+    if (mgr) {
+        ObjectScriptManager::Arguments args;
+        args["Assembly"]="Sirikata.Runtime";
+        args["Class"]="PythonObject";
+        args["Namespace"]="Sirikata.Runtime";
+        args["PythonModule"]="test";
+        args["PythonClass"]="exampleclass";
+
+        mObjectScript=mgr->createObjectScript(this,args);
+        if (mObjectScript) {
+            mObjectScript->tick();
+        }
+    }
+}
+
+void HostedObject::initializeRestoreFromDatabase(const SpaceID&spaceID, const HostedObjectPtr&spaceConnectionHint) {
+    mObjectHost->registerHostedObject(getSharedPtr());
+    connectToSpace(spaceID, spaceConnectionHint);
+
+    Persistence::SentReadWriteSet *msg;
+    msg = new Persistence::SentReadWriteSet(&mTracker);
+    msg->setPersistenceCallback(std::tr1::bind(
+                         &PrivateCallbacks::initializeDatabaseCallback,
+                         this, spaceID,
+                         _1, _2, _3));
+    msg->body().add_reads().set_field_name("MeshURI");
+    msg->body().add_reads().set_field_name("MeshScale");
+    msg->body().add_reads().set_field_name("Name");
+    msg->body().add_reads().set_field_name("PhysicalParameters");
+    msg->body().add_reads().set_field_name("LightInfo");
+    msg->body().add_reads().set_field_name("IsCamera");
+    msg->body().add_reads().set_field_name("Parent");
+    msg->body().add_reads().set_field_name("Loc");
+    msg->body().add_reads().set_field_name("_Script");
+    msg->body().add_reads().set_field_name("_ScriptParams");
+    for (int i = 0; i < msg->body().reads_size(); i++) {
+        msg->body().reads(i).set_object_uuid(getUUID()); // database assumes uuid 0 if omitted
+    }
+    msg->header().set_destination_object(ObjectReference::spaceServiceID());
+    msg->header().set_destination_port(Services::PERSISTENCE);
+    msg->serializeSend();
+    mObjectHost->getWorkQueue()->dequeueAll(); // don't need to wait until next frame.
+}
+void HostedObject::initializeScript(const String& script, const ObjectScriptManager::Arguments &args) {
+    assert(!mObjectScript); // Don't want to kill a live script!
+    mObjectHost->registerHostedObject(getSharedPtr());
+    ObjectScriptManager *mgr = ObjectScriptManagerFactory::getSingleton().getConstructor(script)("");
+    if (mgr) {
+        mObjectScript = mgr->createObjectScript(this, args);
+    }
+}
+void HostedObject::connectToSpace(const SpaceID&id,const HostedObjectPtr&spaceConnectionHint) {
+    if (id!=SpaceID::null()) {
+        //bind script to object...script might be a remote ID, so need to bind download target, etc
+        std::tr1::shared_ptr<TopLevelSpaceConnection> topLevelConnection;
+        SpaceDataMap::iterator where;
+        if (spaceConnectionHint&&(where=spaceConnectionHint->mSpaceData->find(id))!=mSpaceData->end()) {
+            topLevelConnection=where->second.mSpaceConnection.getTopLevelStream();
+        }else {
+            topLevelConnection=mObjectHost->connectToSpace(id);
+        }
+
+        // sending initial packet is done by the script!
+        //conn->send(initializationPacket,Network::ReliableOrdered);
+        PerSpaceData &psd = cloneTopLevelStream(id,topLevelConnection);
+        // return &(psd.mSpaceConnection);
+    }
+}
+
+void HostedObject::processRoutableMessage(const RoutableMessageHeader &header, MemoryReference bodyData) {
+    std::string myself_name;
+    {
+        std::ostringstream os;
+        if (header.has_destination_object()) {
+            os << header.destination_object();
+        } else {
+            os << "[Temporary UUID " << mInternalObjectReference.toString() << "]";
+        }
+        myself_name = os.str();
+    }
+    {
+        std::ostringstream os;
+        os << "** Message from: " << header.source_object() << " port " << header.source_port() << " to "<<myself_name<<" port " << header.destination_port();
+        SILOG(cppoh,debug,os.str());
+    }
+    /// Handle Return values to queries we sent to someone:
+    if (header.has_reply_id()) {
+        mTracker.processMessage(header, bodyData);
+        return; // Not a message for us to process.
+    }
+
+    if (header.destination_port() == 0) {
+        PrivateCallbacks::handleRPCMessage(this, header, bodyData);
+    } else if (header.destination_port() == Services::PERSISTENCE) {
+        PrivateCallbacks::handlePersistenceMessage(this, header, bodyData);
+    } else {
+        if (mObjectScript) {
+            mObjectScript->processMessage(header, bodyData);
+        } else {
+            sendErrorReply(header, RoutableMessageHeader::PORT_FAILURE);
+        }
+    }
+}
+
+void HostedObject::sendViaSpace(const RoutableMessageHeader &hdrOrig, MemoryReference body) {
+    ///// MessageService::processMessage
+    assert(hdrOrig.has_destination_object());
+    assert(hdrOrig.has_destination_space());
+    SpaceDataMap::iterator where=mSpaceData->find(hdrOrig.destination_space());
+    if (where!=mSpaceData->end()) {
+        RoutableMessageHeader hdr (hdrOrig);
+        hdr.clear_destination_space();
+        hdr.clear_source_space();
+        hdr.clear_source_object();
+        String serialized_header;
+        hdr.SerializeToString(&serialized_header);
+        where->second.mSpaceConnection.getStream()->send(MemoryReference(serialized_header),body, Network::ReliableOrdered);
+    }
+    assert(where!=mSpaceData->end());
+}
+
+void HostedObject::send(const RoutableMessageHeader &hdrOrig, MemoryReference body) {
+    assert(hdrOrig.has_destination_object());
+    if (!hdrOrig.has_destination_space() || hdrOrig.destination_space() == SpaceID::null()) {
+        RoutableMessageHeader hdr (hdrOrig);
+        hdr.set_destination_space(SpaceID::null());
+        hdr.set_source_object(ObjectReference(mInternalObjectReference));
+        mObjectHost->processMessage(hdr, body);
+        return;
+    }
+    SpaceDataMap::iterator where=mSpaceData->find(hdrOrig.destination_space());
+    if (where!=mSpaceData->end()) {
+        const ProxyObjectPtr &obj = where->second.mProxyObject;
+        if (obj) {
+            RoutableMessageHeader hdr (hdrOrig);
+            hdr.set_source_object(obj->getObjectReference().object());
+            mObjectHost->processMessage(hdr, body);
+        } else {
+            sendViaSpace(hdrOrig, body);
+        }
+    }
+}
+
+void HostedObject::tick() {
+    for (SpaceDataMap::iterator iter = mSpaceData->begin(); iter != mSpaceData->end(); ++iter) {
+        // send update to LOC (2) service in the space, if necessary
+        iter->second.updateLocation(this);
+        // Is it useful to call every script's tick() function?
+    }
+}
+
+void HostedObject::receivedPositionUpdate(
+    const ProxyObjectPtr &proxy,
+    const ObjLoc &objLoc,
+    bool force_reset)
+{
+    if (!proxy) {
+        return;
+    }
+    force_reset = force_reset || (objLoc.update_flags() & ObjLoc::FORCE);
+    if (!objLoc.has_timestamp()) {
+        objLoc.set_timestamp(Time::now(getSpaceTimeOffset(proxy->getObjectReference().space())));
+    }
+    Location currentLoc = proxy->globalLocation(objLoc.timestamp());
+    if (force_reset || objLoc.has_position()) {
+        currentLoc.setPosition(objLoc.position());
+    }
+    if (force_reset || objLoc.has_orientation()) {
+        currentLoc.setOrientation(objLoc.orientation());
+    }
+    if (force_reset || objLoc.has_velocity()) {
+        currentLoc.setVelocity(objLoc.velocity());
+    }
+    if (force_reset || objLoc.has_rotational_axis()) {
+        currentLoc.setAxisOfRotation(objLoc.rotational_axis());
+    }
+    if (force_reset || objLoc.has_angular_speed()) {
+        currentLoc.setAngularSpeed(objLoc.angular_speed());
+    }
+    if (force_reset) {
+        proxy->resetLocation(objLoc.timestamp(), currentLoc);
+    } else {
+        std::ostringstream os;
+        os << "Received position update to "<<currentLoc;
+        SILOG(cppoh,debug,os.str());
+        proxy->setLocation(objLoc.timestamp(), currentLoc);
+    }
+}
+
+
+static int32 query_id = 0;
+using Protocol::LocRequest;
+void HostedObject::processRPC(const RoutableMessageHeader &msg, const std::string &name, MemoryReference args, String *response) {
+    std::ostringstream printstr;
+    printstr<<"\t";
+    ProxyObjectPtr thisObj = getProxy(msg.source_space());
+
+    if (name == "LocRequest") {
+        LocRequest query;
+        printstr<<"LocRequest: ";
+        query.ParseFromArray(args.data(), args.length());
+        ObjLoc loc;
+        Time now = Time::now(getSpaceTimeOffset(msg.source_space()));
+        if (thisObj) {
+            Location globalLoc = thisObj->globalLocation(now);
+            loc.set_timestamp(now);
+            uint32 fields = 0;
+            bool all_fields = true;
+            if (query.has_requested_fields()) {
+                fields = query.requested_fields();
+                all_fields = false;
+            }
+            if (all_fields || (fields & LocRequest::POSITION))
+                loc.set_position(globalLoc.getPosition());
+            if (all_fields || (fields & LocRequest::ORIENTATION))
+                loc.set_orientation(globalLoc.getOrientation());
+            if (all_fields || (fields & LocRequest::VELOCITY))
+                loc.set_velocity(globalLoc.getVelocity());
+            if (all_fields || (fields & LocRequest::ROTATIONAL_AXIS))
+                loc.set_rotational_axis(globalLoc.getAxisOfRotation());
+            if (all_fields || (fields & LocRequest::ANGULAR_SPEED))
+                loc.set_angular_speed(globalLoc.getAngularSpeed());
+            if (response)
+                loc.SerializeToString(response);
+        } else {
+            SILOG(objecthost, error, "LocRequest message not for any known object.");
+        }
+        // loc requests need to be fast, unlikely to land in infinite recursion.
+        mObjectHost->getWorkQueue()->dequeueAll();
+        return;             /// comment out if we want scripts to see these requests
+    }
+    else if (name == "SetLoc") {
+        ObjLoc setloc;
+        printstr<<"Someone wants to set my position: ";
+        setloc.ParseFromArray(args.data(), args.length());
+        if (thisObj) {
+            printstr<<setloc.position();
+            receivedPositionUpdate(thisObj, setloc, false);
+        }
+    }
+    else if (name == "DelObj") {
+        SpaceDataMap::iterator perSpaceIter = mSpaceData->find(msg.source_space());
+        if (perSpaceIter == mSpaceData->end()) {
+            SILOG(objecthost, error, "DelObj message not for any known space.");
+            return;
+        }
+        TopLevelSpaceConnection *proxyMgr =
+            perSpaceIter->second.mSpaceConnection.getTopLevelStream().get();
+        if (thisObj && proxyMgr) {
+            proxyMgr->unregisterHostedObject(thisObj->getObjectReference().object());
+        }
+    }
+    else if (name == "RetObj") {
+        SpaceDataMap::iterator perSpaceIter = mSpaceData->find(msg.source_space());
+        if (msg.source_object() != ObjectReference::spaceServiceID()) {
+            SILOG(objecthost, error, "RetObj message not coming from space: "<<msg.source_object());
+            return;
+        }
+        if (perSpaceIter == mSpaceData->end()) {
+            SILOG(objecthost, error, "RetObj message not for any known space.");
+            return;
+        }
+        // getProxyManager() does not work because we have not yet created our ProxyObject.
+        TopLevelSpaceConnection *proxyMgr =
+            perSpaceIter->second.mSpaceConnection.getTopLevelStream().get();
+
+        Protocol::RetObj retObj;
+        retObj.ParseFromArray(args.data(), args.length());
+        if (retObj.has_object_reference() && retObj.has_location()) {
+            SpaceObjectReference objectId(msg.source_space(), ObjectReference(retObj.object_reference()));
+            ProxyObjectPtr proxyObj;
+            if (hasProperty("IsCamera")) {
+                printstr<<"RetObj: I am now a Camera known as "<<objectId.object();
+                proxyObj = ProxyObjectPtr(new ProxyCameraObject(proxyMgr, objectId));
+            } else if (hasProperty("LightInfo") && !hasProperty("MeshURI")) {
+                printstr<<"RetObj. I am now a Light known as "<<objectId.object();
+                proxyObj = ProxyObjectPtr(new ProxyLightObject(proxyMgr, objectId));
+            } else {
+                printstr<<"RetObj: I am now a Mesh known as "<<objectId.object();
+                proxyObj = ProxyObjectPtr(new ProxyMeshObject(proxyMgr, objectId));
+            }
+            proxyObj->setLocal(true);
+            perSpaceIter->second.mProxyObject = proxyObj;
+            proxyMgr->registerHostedObject(objectId.object(), getSharedPtr());
+            receivedPositionUpdate(proxyObj, retObj.location(), true);
+            perSpaceIter->second.locationWasReset(retObj.location().timestamp(), proxyObj->getLastLocation());
+            if (proxyMgr) {
+                //proxyMgr->createObject(proxyObj);
+                proxyMgr->createViewedObject(proxyObj, getTracker());
+                ProxyCameraObject* cam = dynamic_cast<ProxyCameraObject*>(proxyObj.get());
+                if (cam) {
+                    /* HACK: Because we have no method of scripting yet, we force
+                       any local camera we create to attach for convenience. */
+                    cam->attach(String(), 0, 0);
+                    uint32 my_query_id = query_id;
+                    query_id++;
+                    Protocol::NewProxQuery proxQuery;
+                    proxQuery.set_query_id(my_query_id);
+                    proxQuery.set_max_radius(1.0e+30f);
+                    String proxQueryStr;
+                    proxQuery.SerializeToString(&proxQueryStr);
+                    RoutableMessageBody body;
+                    body.add_message("NewProxQuery", proxQueryStr);
+                    String bodyStr;
+                    body.SerializeToString(&bodyStr);
+                    RoutableMessageHeader proxHeader;
+                    proxHeader.set_destination_port(Services::GEOM);
+                    proxHeader.set_destination_object(ObjectReference::spaceServiceID());
+                    proxHeader.set_destination_space(objectId.space());
+                    send(proxHeader, MemoryReference(bodyStr));
+                }
+                for (PropertyMap::const_iterator iter = mProperties.begin();
+                        iter != mProperties.end();
+                        ++iter) {
+                    receivedPropertyUpdate(proxyObj, iter->first, iter->second);
+                }
+            }
+        }
+    }
+    else if (name == "ProxCall") {
+        ObjectHostProxyManager *proxyMgr;
+        if (false && msg.source_object() != ObjectReference::spaceServiceID()) {
+            SILOG(objecthost, error, "ProxCall message not coming from space: "<<msg.source_object());
+            return;
+        }
+        if (!thisObj) {
+            SILOG(objecthost, error, "ProxCall message with null ProxyManager.");
+            return;
+        }
+
+        SpaceDataMap::iterator sditer = mSpaceData->find(msg.source_space());
+        assert (sditer != mSpaceData->end());
+        proxyMgr = sditer->second.mSpaceConnection.getTopLevelStream().get();
+
+        Protocol::ProxCall proxCall;
+        proxCall.ParseFromArray(args.data(), args.length());
+        SpaceObjectReference proximateObjectId (msg.source_space(), ObjectReference(proxCall.proximate_object()));
+        ProxyObjectPtr proxyObj (proxyMgr->getProxyObject(proximateObjectId));
+        switch (proxCall.proximity_event()) {
+          case Protocol::ProxCall::EXITED_PROXIMITY:
+            printstr<<"ProxCall EXITED "<<proximateObjectId.object();
+            if (proxyObj) {
+                PerSpaceData::ProxQueryMap::iterator iter = sditer->second.mProxQueryMap.find(proxCall.query_id());
+                if (iter != sditer->second.mProxQueryMap.end()) {
+                    std::set<ObjectReference>::iterator proxyiter = iter->second.find(proximateObjectId.object());
+                    assert (proxyiter != iter->second.end());
+                    if (proxyiter != iter->second.end()) {
+                        iter->second.erase(proxyiter);
+                    }
+                }
+                proxyMgr->destroyViewedObject(proxyObj->getObjectReference(), this->getTracker());
+            } else {
+                printstr<<" (unknown obj)";
+            }
+            break;
+          case Protocol::ProxCall::ENTERED_PROXIMITY:
+            printstr<<"ProxCall ENTERED "<<proximateObjectId.object();
+            {
+                PerSpaceData::ProxQueryMap::iterator iter =
+                    sditer->second.mProxQueryMap.insert(
+                        PerSpaceData::ProxQueryMap::value_type(proxCall.query_id(), std::set<ObjectReference>())
+                        ).first;
+                iter->second.insert(proximateObjectId.object());
+            }
+            if (!proxyObj) { // FIXME: We may get one of these for each prox query. Keep track of in-progress queries in ProxyManager.
+                printstr<<" (Requesting information...)";
+
+                {
+                    RPCMessage *locRequest = new RPCMessage(&mTracker,std::tr1::bind(&PrivateCallbacks::receivedProxObjectLocation,
+                                                                                     getWeakPtr(), _1, _2, _3,
+                                                        proxCall.query_id()));
+                    locRequest->header().set_destination_space(proximateObjectId.space());
+                    locRequest->header().set_destination_object(proximateObjectId.object());
+                    LocRequest loc;
+                    loc.SerializeToString(locRequest->body().add_message("LocRequest"));
+
+                  
+                    locRequest->setTimeout(Duration::seconds(5.0));
+                    locRequest->serializeSend();
+                }
+            } else {
+                printstr<<" (Already known)";
+                proxyMgr->createViewedObject(proxyObj, this->getTracker());
+            }
+            break;
+          case Protocol::ProxCall::STATELESS_PROXIMITY:
+            printstr<<"ProxCall Stateless'ed "<<proximateObjectId.object();
+            // Do not create a proxy object in this case: This message is for one-time queries
+            break;
+        }
+    } else {
+        printstr<<"Message to be handled in script: "<<name;
+    }
+    SILOG(cppoh,debug,printstr.str());
+    if (mObjectScript) {
+        MemoryBuffer returnCopy;
+        mObjectScript->processRPC(msg, name, args, returnCopy);
+        if (response) {
+            response->reserve(returnCopy.size());
+            std::copy(returnCopy.begin(), returnCopy.end(),
+                      std::insert_iterator<std::string>(*response, response->begin()));
+        }
+    }
+}
+const Duration&HostedObject::getSpaceTimeOffset(const SpaceID&space) {
+    static Duration nil(Duration::seconds(0));
+    SpaceDataMap::iterator where=mSpaceData->find(space);
+    if (where!=mSpaceData->end()) 
+        return where->second.mSpaceConnection.getTopLevelStream()->getServerTimeOffset();
+    return nil;
+}
+
+void HostedObject::receivedPropertyUpdate(
+        const ProxyObjectPtr &proxy,
+        const std::string &propertyName,
+        const std::string &arguments)
+{
+    if (propertyName == "MeshURI") {
+        Protocol::StringProperty parsedProperty;
+        parsedProperty.ParseFromString(arguments);
+        if (parsedProperty.has_value()) {
+            ProxyMeshObject *proxymesh = dynamic_cast<ProxyMeshObject*>(proxy.get());
+            if (proxymesh) {
+                SILOG(cppoh,info, "* Received MESH property update for " << proxy->getObjectReference().object() <<" has mesh URI "<<URI(parsedProperty.value()));
+                proxymesh->setMesh(URI(parsedProperty.value()));
+            }
+        }
+    }
+    if (propertyName == "MeshScale") {
+        Protocol::Vector3fProperty parsedProperty;
+        parsedProperty.ParseFromString(arguments);
+        if (parsedProperty.has_value()) {
+            ProxyMeshObject *proxymesh = dynamic_cast<ProxyMeshObject*>(proxy.get());
+            if (proxymesh) {
+                proxymesh->setScale(parsedProperty.value());
+            }
+        }
+    }
+    if (propertyName == "LightInfo") {
+        Protocol::LightInfoProperty parsedLight;
+        parsedLight.ParseFromString(arguments);
+        ProxyLightObject *proxylight = dynamic_cast<ProxyLightObject*>(proxy.get());
+        if (proxylight) {
+            proxylight->update(LightInfo(parsedLight));
+        }
+    }
+    if (propertyName == "PhysicalParameters") {
+        Protocol::PhysicalParameters parsedProperty;
+        parsedProperty.ParseFromString(arguments);
+        ProxyMeshObject *proxymesh = dynamic_cast<ProxyMeshObject*>(proxy.get());
+        if (proxymesh) {
+            // FIXME: allow missing fields, and do not hardcode enum values.
+            PhysicalParameters params;
+            switch (parsedProperty.mode()) {
+            case Protocol::PhysicalParameters::NONPHYSICAL:
+                params.mode = PhysicalParameters::Disabled;
+                break;
+            case Protocol::PhysicalParameters::STATIC:
+                params.mode = PhysicalParameters::Static;
+                break;
+            case Protocol::PhysicalParameters::DYNAMICBOX:
+                params.mode = PhysicalParameters::DynamicBox;
+                break;
+            case Protocol::PhysicalParameters::DYNAMICSPHERE:
+                params.mode = PhysicalParameters::DynamicSphere;
+                break;
+            case Protocol::PhysicalParameters::DYNAMICCYLINDER:
+                params.mode = PhysicalParameters::DynamicCylinder;
+                break;
+            case Protocol::PhysicalParameters::CHARACTER:
+                params.mode = PhysicalParameters::Character;
+                break;
+            default:
+                params.mode = PhysicalParameters::Disabled;
+            }
+            params.density = parsedProperty.density();
+            params.friction = parsedProperty.friction();
+            params.bounce = parsedProperty.bounce();
+            params.colMsg = parsedProperty.collide_msg();
+            params.colMask = parsedProperty.collide_mask();
+            params.hull = parsedProperty.hull();
+            params.gravity = parsedProperty.gravity();
+            params.name = proxymesh->getPhysical().name;        /// otherwise setPhysical will wipe it
+            proxymesh->setPhysical(params);
+        }
+    }
+    if (propertyName == "Parent") {
+        Protocol::ParentProperty parsedProperty;
+        parsedProperty.ParseFromString(arguments);
+        if (parsedProperty.has_value()) {
+            ProxyObjectPtr obj =proxy->getProxyManager()->getProxyObject(
+                SpaceObjectReference(
+                    proxy->getObjectReference().space(),
+                    ObjectReference(parsedProperty.value())));
+            if (obj && obj != proxy) {
+                proxy->setParent(obj, Time::now(getSpaceTimeOffset(proxy->getObjectReference().space())));
+            }
+        }
+    }
+    if (propertyName == "Name") {
+        Protocol::StringProperty parsedProperty;
+        ProxyMeshObject *proxymesh = dynamic_cast<ProxyMeshObject*>(proxy.get());
+        parsedProperty.ParseFromString(arguments);
+        if (proxymesh && parsedProperty.has_value()) {
+            PhysicalParameters params = proxymesh->getPhysical();
+            params.name = parsedProperty.value();
+            proxymesh->setPhysical(params);
+        }
+    }
+}
+
+}
diff --git a/run b/run
index 55c5524..4b6ce50 100755
--- a/run
+++ b/run
@@ -1,70 +1,70 @@
-#!/usr/bin/python
-import sys, os, time
-
-def check_for_proc(proc):
-    sin, sout = os.popen2("ps -af")
-    s = sout.read()
-##    print s
-    procs = s.split("\n")
-    running=0
-    for p in procs:
-        w = p.split()
-        if proc in w:
-            running=int(w[1])
-##    print "check_for_proc", proc, "returns:", running
-    return running
-
-#
-# Check for executable version
-#
-
-if os.path.exists("build/cmake/cppoh_d"):
-    spaceserver = "space_d"
-    proxserver = "proximity_d"
-    executable = "cppoh_d"
-else:
-    if os.path.exists("build/cmake/cppoh"):
-        spaceserver = "space"
-        proxserver = "proximity"
-        executable = "cppoh"
-    else:
-        print "can't find executable"
-        exit()
-
-#
-# Run prox & space daemons (if not already running)
-#
-
-for proc, delay in (proxserver, 4.5), (spaceserver, .5):
-
-    if not check_for_proc("./"+proc):
-        cmd = 'xterm -e "cd build/cmake; ./' + proc + '" &'
-        print cmd
-        os.system(cmd)
-        time.sleep(delay)
-
-#
-# Convert .csv files into sqlite .db files
-#
-
-if len(sys.argv) > 1:
-    fin = sys.argv[1]
-else:
-    fin = "scene.csv"
-fout = fin[:-4] + ".db"
-cmd = "python csv_converter.py " + fin +" "+ fout
-print cmd
-sin, sout = os.popen2(cmd)
-s = sout.read()
-if not "SUCCESS" in s:
-    print s
-    print "csv --> db conversion failed, aborting run"
-    exit()
-
-#
-# Run our object host
-#
-
-cmd = "cd build/cmake; ./" + executable + " --db ../../" + fout
-print cmd
-os.system(cmd)
+#!/usr/bin/python
+import sys, os, time
+
+def check_for_proc(proc):
+    sin, sout = os.popen2("ps -af")
+    s = sout.read()
+##    print s
+    procs = s.split("\n")
+    running=0
+    for p in procs:
+        w = p.split()
+        if proc in w:
+            running=int(w[1])
+##    print "check_for_proc", proc, "returns:", running
+    return running
+
+#
+# Check for executable version
+#
+
+if os.path.exists("build/cmake/cppoh_d"):
+    spaceserver = "space_d"
+    proxserver = "proximity_d"
+    executable = "cppoh_d"
+else:
+    if os.path.exists("build/cmake/cppoh"):
+        spaceserver = "space"
+        proxserver = "proximity"
+        executable = "cppoh"
+    else:
+        print "can't find executable"
+        exit()
+
+#
+# Run prox & space daemons (if not already running)
+#
+
+for proc, delay in (proxserver, 4.5), (spaceserver, .5):
+
+    if not check_for_proc("./"+proc):
+        cmd = 'xterm -e "cd build/cmake; ./' + proc + '" &'
+        print cmd
+        os.system(cmd)
+        time.sleep(delay)
+
+#
+# Convert .csv files into sqlite .db files
+#
+
+if len(sys.argv) > 1:
+    fin = sys.argv[1]
+else:
+    fin = "scene.csv"
+fout = fin[:-4] + ".db"
+cmd = "python csv_converter.py " + fin +" "+ fout
+print cmd
+sin, sout = os.popen2(cmd)
+s = sout.read()
+if not "SUCCESS" in s:
+    print s
+    print "csv --> db conversion failed, aborting run"
+    exit()
+
+#
+# Run our object host
+#
+
+cmd = "cd build/cmake; ./" + executable + " --db ../../" + fout
+print cmd
+os.system(cmd)
