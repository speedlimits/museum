<!DOCTYPE html>
<!--
attempt to compose multiple objects
 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Spinning WebGL Box</title>

<script src="resources/CanvasMatrix.js" type="text/javascript"> </script>
<script src="resources/utils3d.js" type="text/javascript"> </script>
<script id="vshader" type="x-shader/x-vertex">
    uniform mat4 u_modelViewProjMatrix;
    uniform mat4 u_normalMatrix;
    uniform vec3 lightDir;

    attribute vec3 vNormal;
    attribute vec4 vColor;
    attribute vec4 vPosition;

    varying float v_Dot;
    varying vec4 v_Color;

    void main()
    {
        gl_Position = u_modelViewProjMatrix * vPosition;
        v_Color = vColor;
        vec4 transNormal = u_normalMatrix * vec4(vNormal, 1);
        v_Dot = max(dot(transNormal.xyz, lightDir), 0.0);
    }
</script>

<script id="fshader" type="x-shader/x-fragment">
    varying float v_Dot;
    varying vec4 v_Color;

    void main()
    {
        gl_FragColor = vec4(v_Color.xyz * v_Dot, v_Color.a);
    }
</script>

<script>
	function debug(s, l){
		if (l === undefined) {
			document.getElementById("dbg").innerHTML += s + "<br>"
		}
		else {
			document.getElementById("dbg" + l).innerHTML = s + "<br>"
		}
	}

	function cleanNum(n, b) {
		if (b===undefined) b=1000.0
		if (Math.abs(n) < 1.0/b) return 0
		n = Math.floor(n*b) / b		
		return n
	}

	function makeBall(ctx, lats, longs){
		radius = Math.pow(2,.5)
		if (lats===undefined) lats = 13
		if (longs==undefined) longs = 17
		var geometryData = [];
		var normalData = [];
		var texCoordData = [];
		var indexData = [];
		
		for (var latNumber = 0; latNumber <= lats; ++latNumber) {
			for (var longNumber = 0; longNumber <= longs; ++longNumber) {
				var theta = latNumber * Math.PI / lats;
				var phi = longNumber * 2 * Math.PI / longs;
				var sinTheta = Math.sin(theta);
				var sinPhi = Math.sin(phi);
				var cosTheta = Math.cos(theta);
				var cosPhi = Math.cos(phi);
				
				var x = cosPhi * sinTheta;
				var y = cosTheta;
				var z = sinPhi * sinTheta;
				var u = 1 - (longNumber / longs);
				var v = latNumber / lats;
				
				normalData.push(x);
				normalData.push(y);
				normalData.push(z);
//				debug("normal, "+x+","+y+","+z+"<br>")
				texCoordData.push(u);
				texCoordData.push(v);
				geometryData.push(radius * x);
				geometryData.push(radius * y);
				geometryData.push(radius * z);
				debug("vertex, "+cleanNum(radius*x)+","+cleanNum(radius*y)+","+cleanNum(radius*z))
			}
		}
		
		for (var latNumber = 0; latNumber < lats; ++latNumber) {
			for (var longNumber = 0; longNumber < longs; ++longNumber) {
				var first = (latNumber * (longs + 1)) + longNumber;
				var second = first + longs + 1;
				indexData.push(first);
				indexData.push(second);
				indexData.push(first + 1);
				
				indexData.push(second);
				indexData.push(second + 1);
				indexData.push(first + 1);
			}
		}
		
		var retval = {};
		
		retval.normalObject = ctx.createBuffer();
		ctx.bindBuffer(ctx.ARRAY_BUFFER, retval.normalObject);
		ctx.bufferData(ctx.ARRAY_BUFFER, new WebGLFloatArray(normalData), ctx.STATIC_DRAW);
		
//		retval.texCoordObject = ctx.createBuffer();
//		ctx.bindBuffer(ctx.ARRAY_BUFFER, retval.texCoordObject);
//		ctx.bufferData(ctx.ARRAY_BUFFER, new WebGLFloatArray(texCoordData), ctx.STATIC_DRAW);
		
		retval.vertexObject = ctx.createBuffer();
		ctx.bindBuffer(ctx.ARRAY_BUFFER, retval.vertexObject);
		ctx.bufferData(ctx.ARRAY_BUFFER, new WebGLFloatArray(geometryData), ctx.STATIC_DRAW);
		
		retval.numVertices = geometryData.length / 3
		retval.numIndices = indexData.length;
		debug("numIndices: "+retval.numIndices)
		retval.indexObject = ctx.createBuffer();
		ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, retval.indexObject);
		ctx.bufferData(ctx.ELEMENT_ARRAY_BUFFER, new WebGLUnsignedShortArray(indexData), ctx.STREAM_DRAW);
		
		return retval;
	}

    function init()
    {
        // Initialize
        var gl = initWebGL(
            // The id of the Canvas Element
            "example",
            // The ids of the vertex and fragment shaders
            "vshader", "fshader", 
            // The vertex attribute names used by the shaders.
            // The order they appear here corresponds to their index
            // used later.
            [ "vNormal", "vColor", "vPosition"],
            // The clear color and depth values
            [ 0, 0, 0, 1 ], 10000);

        // Set up a uniform variable for the shaders
        gl.uniform3f(gl.getUniformLocation(gl.program, "lightDir"), 0, 0, 1);

        // Create a box. On return 'gl' contains a 'box' property with
        // the BufferObjects containing the arrays for vertices,
        // normals, texture coords, and indices.
        gl.box = makeBall(gl,4,4);

        // Set up the array of colors for the cube's faces
//        var colors = new WebGLUnsignedByteArray(


		var temp = []
		equator = Math.floor(gl.box.numVertices/2)
		for (var i=0; i<gl.box.numVertices; i++) {
			rgb = [.8,.8,.9]
//			if (i>=equator) rgb = [1,.1,.1]
			temp.push(rgb[0], rgb[1], rgb[2], 1)
		}
		temp[equator*4] = 0			/// something to see it spin
		
		debug("temp: " + temp.length + " equator: " + equator)
		debug("numVertices: " + gl.box.numVertices)
		var colors = new WebGLFloatArray(temp)
        // Set up the vertex buffer for the colors
        gl.box.colorObject = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.box.colorObject);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

        // Create some matrices to use later and save their locations in the shaders
        gl.mvMatrix = new CanvasMatrix4();
        gl.u_normalMatrixLoc = gl.getUniformLocation(gl.program, "u_normalMatrix");
        gl.normalMatrix = new CanvasMatrix4();
        gl.u_modelViewProjMatrixLoc =
                gl.getUniformLocation(gl.program, "u_modelViewProjMatrix");
        gl.mvpMatrix = new CanvasMatrix4();

        // Enable all of the vertex attribute arrays.
        gl.enableVertexAttribArray(0);											/// enable 3 arrays
        gl.enableVertexAttribArray(1);
        gl.enableVertexAttribArray(2);
        gl.enableVertexAttribArray(3);											/// enable 3 arrays
        gl.enableVertexAttribArray(4);
        gl.enableVertexAttribArray(5);

        // Set up all the vertex attributes for vertices, normals and colors
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.box.vertexObject);					/// make ARRAY = our geom vertex array
        gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 0, 0);					///	geom index=2; 3 floats per vertex

        gl.bindBuffer(gl.ARRAY_BUFFER, gl.box.normalObject);					///	make ARRAY = normals
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);					///	normal index=0; 3 floats per normal

        gl.bindBuffer(gl.ARRAY_BUFFER, gl.box.colorObject);						///	make ARRAY = colors
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);					///	color index=1; 4 floats per color (RGBA?)


/// test 2nd object -- switch norm/geom (should make smaller sphere)
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.box.vertexObject);					/// make ARRAY = our geom vertex array
        gl.vertexAttribPointer(3, 3, gl.FLOAT, false, 0, 0);					///	geom index=2; 3 floats per vertex

        gl.bindBuffer(gl.ARRAY_BUFFER, gl.box.normalObject);					///	make ARRAY = normals
        gl.vertexAttribPointer(5, 3, gl.FLOAT, false, 0, 0);					///	normal index=0; 3 floats per normal

        gl.bindBuffer(gl.ARRAY_BUFFER, gl.box.colorObject);						///	make ARRAY = colors
        gl.vertexAttribPointer(4, 4, gl.FLOAT, false, 0, 0);					///	color index=1; 4 floats per color (RGBA?)

        // Bind the index array
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.box.indexObject);				///	make ELEMENTS = our index list (shorts!)

        return gl;
    }

    width = -1;
    height = -1;

    function reshape(gl)
    {
        var canvas = document.getElementById('example');
        if (canvas.clientWidth == width && canvas.clientHeight == height)
            return;

        width = canvas.clientWidth;
        height = canvas.clientHeight;

        // Set the viewport and projection matrix for the scene
        gl.viewport(0, 0, width, height);
        gl.perspectiveMatrix = new CanvasMatrix4();
        gl.perspectiveMatrix.lookat(0, 0, 7, 0, 0, 0, 0, 1, 0);
        gl.perspectiveMatrix.perspective(30, width/height, 1, 10000);
    }

    function drawPicture_(gl, objnum)
    {
        // Make a model/view matrix.
        gl.mvMatrix.makeIdentity();
        gl.mvMatrix.rotate(currentAngle, 0,1,0);
        gl.mvMatrix.rotate(30, 1,0,0);
		gl.mvMatrix.translate(objnum*3-1.5,0,0)

        // Construct the normal matrix from the model-view matrix and pass it in
        gl.normalMatrix.load(gl.mvMatrix);
        gl.normalMatrix.invert();
        gl.normalMatrix.transpose();
        gl.uniformMatrix4fv(gl.u_normalMatrixLoc, false,
                            gl.normalMatrix.getAsWebGLFloatArray());

        // Construct the model-view * projection matrix and pass it in
        gl.mvpMatrix.load(gl.mvMatrix);
        gl.mvpMatrix.multRight(gl.perspectiveMatrix);
        gl.uniformMatrix4fv(gl.u_modelViewProjMatrixLoc, false,
                            gl.mvpMatrix.getAsWebGLFloatArray());

        // Draw the cube
        gl.drawElements(gl.TRIANGLES, gl.box.numIndices, gl.UNSIGNED_SHORT, objnum*0);

        // Finish up.
        gl.flush();

        // Show the framerate
        framerate.snapshot();

        currentAngle += incAngle;
        if (currentAngle > 360)
            currentAngle -= 360;
    }
	
	function drawPicture(gl) {
        // Make sure the canvas is sized correctly.
        reshape(gl);

        // Clear the canvas
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		drawPicture_(gl,0)
		drawPicture_(gl,1)
	}

    function start()
    {
        var c = document.getElementById("example");
        var w = Math.floor(window.innerWidth * 0.9);
        var h = Math.floor(window.innerHeight * 0.9);

        c.width = w;
        c.height = h;

        var gl = init();
        currentAngle = 0;
        incAngle = 0.5*1;
        framerate = new Framerate("framerate");
        setInterval(function() { drawPicture(gl) }, 10);
    }
</script>
<style type="text/css">
    canvas {
        border: 2px solid black;
    }
    .text {
        position:absolute;
        top:100px;
        left:20px;
        font-size:2em;
        color: blue;
    }
</style>
</head>

<body onload="start()">
<canvas id="example">
    If you're seeing this your web browser doesn't support the &lt;canvas>&gt; element. Ouch!
</canvas>
<div class="text">This is some text over the canvas</div>

<div id="framerate"></div>
<div id="dbg0"></div>
<div id="dbg1"></div>
<div id="dbg2"></div>
<div id="dbg3"></div>
<div id="dbg4"></div>
<div id="dbg5"></div>
<div id="dbg6"></div>
<div id="dbg"></div>
</body>

</html>
